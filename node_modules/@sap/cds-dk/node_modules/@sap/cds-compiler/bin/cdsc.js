#!/usr/bin/env node

// command line interface to the cds api resp. cds compiler
// Usage: cdsc [options] <file> ...
// Call cdsc --help for a detailed description
// Exit codes are:
//   0   for success
//   1   compilation error
//   2   command line usage error

// For recursive *.cds expansion, use
//   cdsc $(find . -name '*.cds' -type f)

'use strict';

/* eslint no-console:off */

const compiler = require('../lib/main');
const { compactModel } = require('../lib/json/to-csn');
const { toOdataWithCsn, toHanaWithCsn, toSqlWithCsn, toCdlWithCsn } = require('../lib/backends');
var util = require('util');
var fs = require('fs');
var path = require('path');
var reveal = require('../lib/model/revealInternalProperties');
const enrichCsn = require('../lib/model/enrichCsn');
const { optionProcessor } = require('../lib/optionProcessor');
const { translatePathLocations, explainMessage, hasMessageExplanation } = require('../lib/base/messages')
const { translateAssocsToJoins } = require('../lib/transform/translateAssocsToJoins');
const term = require('../lib/utils/term');
const nodeHelper = require('../lib/base/node-helpers');
const { splitLines } = require('../lib/utils/file');

// Note: Instead of throwing ProcessExitError, we would rather just call process.exit(exitCode),
// but that might truncate the output of stdout and stderr, both of which are async (or rather,
// may possibly be async, depending on OS and whether I/O goes to TTY, socket, file, ... sigh)
class ProcessExitError extends Error {
  constructor(exitCode,...args) {
    super(...args);
    this.exitCode = exitCode;
  }
}

// Parse the command line and translate it into options
try {
  let cmdLine = optionProcessor.processCmdLine(process.argv);
  // Deal with '--version' explicitly
  if (cmdLine.options.version) {
    process.stdout.write(compiler.version() + '\n');
    throw new ProcessExitError(0);
  }
  // Deal with '--help' explicitly
  if (cmdLine.command) {
    // Command specific help
    if (cmdLine.options.help || cmdLine.options[cmdLine.command] && cmdLine.options[cmdLine.command].help) {
      displayUsage(null, optionProcessor.commands[cmdLine.command].helpText, 0);
    }
  } else if (cmdLine.options.help) {
    // General help
    displayUsage(null, optionProcessor.helpText, 0);
  }

  if (cmdLine.unknownOptions.length > 0) {
    // Print an INFO message about unknown options but
    // continue with defaults and do not abort execution.
    cmdLine.unknownOptions.forEach(msg => process.stderr.write(`cdsc: INFO: ${msg}\n`));
  }

  // Report complaints if any
  if (cmdLine.cmdErrors.length > 0) {
    // Command specific errors
    displayUsage(cmdLine.cmdErrors, optionProcessor.commands[cmdLine.command].helpText, 2);
  } else if (cmdLine.errors.length > 0) {
    // General errors
    displayUsage(cmdLine.errors, optionProcessor.helpText, 2);
  }

  // Default warning level is 2 (info)
  // FIXME: Is that not set anywhere in the API?
  if (!cmdLine.options.warning) {
    cmdLine.options.warning = 2;
  }
  // Default output goes to stdout
  if (!cmdLine.options.out) {
    cmdLine.options.out = '-';
  }
  // Default color mode is 'auto'
  term.useColor(cmdLine.options.color || 'auto');

  // Set default command if required
  cmdLine.command = cmdLine.command || 'toCsn';

  // Internally, parseCdl is an option so we map the command to it.
  if (cmdLine.command === 'parseCdl') {
    cmdLine.command = 'toCsn';
    cmdLine.options.parseCdl = true;
    if (cmdLine.args.files.length > 1) {
      const err = `'parseCdl' expects exactly one file! ${cmdLine.args.files.length} provided.`;
      displayUsage(err, optionProcessor.commands['parseCdl'].helpText, 2);
    }
  }

  if (cmdLine.options.directBackend) {
    validateDirectBackendOption(cmdLine.command, cmdLine.options, cmdLine.args);
  }

  if (cmdLine.options.beta) {
    const features = cmdLine.options.beta.split(',');
    cmdLine.options.beta = {};
    features.forEach((val) => cmdLine.options.beta[val] = true);
  }

  // Enable all beta-flags if betaMode is set to true
  if(cmdLine.options.betaMode) {
    cmdLine.options.beta = {
      'toSwagger': true,
      'toRename': true,
      'subElemRedirections': true,
      'technicalConfig': true,
      'keyRefError': true,
      'odataProxies': true,
      'assocsWithParams': true,
      'uniqueconstraints': true,
      'cleanCsn': false,
      'hanaAssocRealCardinality': true,
    }
  }
  // Do the work for the selected command
  executeCommandLine(cmdLine.command, cmdLine.options, cmdLine.args);
} catch (err) {
  // This whole try/catch is only here because process.exit does not work in combination with
  // stdout/err - see comment at ProcessExitError
  if (err instanceof ProcessExitError) {
    process.exitCode = err.exitCode;
  } else {
    throw err;
  }
}

/**
 * `--direct-backend` can only be used with certain backends and with certain files.
 * This function checks these pre-conditions and emits an error if a condition isn't
 * fulfilled.
 *
 * @param {string} command
 * @param {CSN.Options} options
 * @param {object} args
 */
function validateDirectBackendOption(command, options, args) {
  if (!['toCdl', 'toOdata', 'toHana', 'toCsn', 'toSql'].includes(command)) {
    displayUsage(`Option '--direct-backend' cannot be used with command '${command}'`,
      optionProcessor.helpText, 2);
  }
  if (!args.files || args.files.length !== 1) {
    displayUsage(`Option '--direct-backend' expects exactly one JSON file, but ${args.files.length} given`,
      optionProcessor.helpText, 2);
  }
  const filename = args.files[0];
  if (!filename.endsWith('.csn') && !filename.endsWith('.json')) {
    displayUsage(`Option '--direct-backend' expects a filename with a *.csn or *.json suffix`,
      optionProcessor.helpText, 2);
  }
}

// Display help text 'helpText' and 'error' (if any), then exit with exit code <code>
function displayUsage(error, helpText, code) {
  // Display non-error output (like help) to stdout
  let out = (code === 0 && !error) ? process.stdout : process.stderr;
  // Display help text first, error at the end (more readable, no scrolling)
  out.write(`${helpText}\n`);
  if (error) {
    if (error instanceof Array) {
      out.write(error.map(error => `cdsc: ERROR: ${error}`).join('\n') + '\n');
    } else {
      out.write(`cdsc: ERROR: ${error}\n`);
    }
  }
  throw new ProcessExitError(code);
}

// Executes a command line that has been translated to 'command' (what to do), 'options' (how) and 'args' (which files)
function executeCommandLine(command, options, args) {
  const normalizeFilename = options.testMode && process.platform === 'win32';
  const messageLevels = { Error: 0, Warning: 1, Info: 2, None: 3 };
  // All messages are put into the message array, even those which should not
  // been displayed (severity 'None')

  // Create output directory if necessary
  if (options.out && options.out !== '-' && !fs.existsSync(options.out)) {
    fs.mkdirSync(options.out);
  }

  // Add implementation functions corresponding to commands here
  const commands = {
    toCdl,
    toCsn,
    toHana,
    toOdata,
    toRename,
    toSql,
    toSwagger
  };
  const commandsWithoutCompilation = {
    explain,
  };

  if (!commands[command] && !commandsWithoutCompilation[command]) {
    throw new Error(`Missing implementation for command ${command}`);
  }

  if (commandsWithoutCompilation[command]) {
    commandsWithoutCompilation[command]();
    return;
  }

  const fileCache = Object.create(null)
  const compiled = options.directBackend ?
    nodeHelper.readFile( args.files[0] ).then((str) => JSON.parse( str )) :
    compiler.compile( args.files, undefined, options, fileCache );

  compiled.then( commands[command] )
          .then( displayMessages, displayErrors )
          .catch( catchErrors );

  return; // below are only command implementations.

  // Execute the command line option '--to-cdl' and display the results.
  // Return the original model (for chaining)
  function toCdl( model ) {
    let cdlResult;
    if(options.oldTransformers){
      cdlResult = compiler.toCdl(model);
    } else {
      const csn = options.directBackend ? model : compactModel(model, options);
      csn.messages = model.messages; // pass messages as compactModel misses that
      cdlResult = toCdlWithCsn(csn, options).result
    }
    for (const name in cdlResult) {
      writeToFileOrDisplay(options.out, name + '.cds', cdlResult[name]);
    }
    return model;
  }

  // Execute the command line option '--to-csn' and display the results.
  // Return the original model (for chaining)
  function toCsn( model ) {
    if (options.directBackend) {
      displayNamedCsn(model, 'csn', options);
    } else {
      // Result already provided by caller
      displayNamedXsn(model, 'csn', options);
    }
    return model;
  }

  // Execute the command line option '--to-hana' and display the results.
  // Return the original model (for chaining)
  function toHana( model ) {
    let hanaResult;
    if(options.oldTransformers) {
      hanaResult = compiler.toHana(model);
    } else {
      let csn = options.directBackend ? model : compactModel(model, options);
      csn.messages = model.messages; // pass messages as compactModel misses that
      hanaResult = toHanaWithCsn(csn, options)
    }
    for (let name in hanaResult.hdbcds) {
      writeToFileOrDisplay(options.out, name + '.hdbcds', hanaResult.hdbcds[name]);
    }
    displayNamedXsnOrCsn(hanaResult._augmentedCsn, hanaResult.csn, 'hana_csn', options);
    return model;
  }

  // Execute the command line option '--to-odata' and display the results.
  // Return the original model (for chaining)
  function toOdata( model ) {
    let odataResult;
    if(options.toOdata && 
      options.toOdata.version === 'v4x') {
      options.toOdata.version = 'v4';
      options.toOdata.odataFormat = 'structured';
      options.toOdata.odataContainment = true;
    }
    if(options.oldTransformers) {
      odataResult = compiler.toOdata(model)
    } else {
      let csn = options.directBackend ? model : compactModel(model, options);
      csn.messages = model.messages; // pass messages as compactModel misses that
      odataResult = toOdataWithCsn(csn, options);
    }
    translatePathLocations(model.messages, model);
    for (let serviceName in odataResult.services) {
      // <service>_metadata.xml (metadata)
      if (odataResult.services[serviceName].metadata) {
        writeToFileOrDisplay(options.out, serviceName + '_metadata.xml', odataResult.services[serviceName].metadata);
      }
      // <service>_annotations.xml (annotations)
      if (odataResult.services[serviceName].annotations) {
        writeToFileOrDisplay(options.out, serviceName + '_annotations.xml', odataResult.services[serviceName].annotations);
      }
      // <service>.xml (combined)
      if (odataResult.services[serviceName].combined) {
        writeToFileOrDisplay(options.out, serviceName + '.xml', odataResult.services[serviceName].combined);
      }
      // <service>.json (metadata_json)
      if (odataResult.services[serviceName].metadata_json) {
        writeToFileOrDisplay(options.out, serviceName + '.json', odataResult.services[serviceName].metadata_json);
      }
    }
    displayNamedXsnOrCsn(odataResult._augmentedCsn, odataResult.csn, 'odata_csn', options);
    return model;
  }

  // Execute the command line option '--to-rename' and display the results.
  // Return the original model (for chaining)
  //
  /// THIS MUST SURVIVE IF WE REMOVE THE OLD API
  /// DO NOT DELETE THIS TORENAME FUNCTIONALITY!!
  function toRename( model ) {
    let renameResult = compiler.toRename(model);
    let storedProcedure = 'PROCEDURE RENAME_' + model.options.toRename.names.toUpperCase() + '_TO_PLAIN LANGUAGE SQLSCRIPT AS BEGIN\n';
    for (let name in renameResult.rename) {
      storedProcedure += '  --\n  -- ' + name + '\n  --\n';
      storedProcedure += renameResult.rename[name];
    }
    storedProcedure += "END;\n";
    writeToFileOrDisplay(options.out, 'storedProcedure_' + model.options.toRename.names + '_to_plain.sql', storedProcedure, true);
    return model;
  }

  // Execute the command line option '--to-sql' and display the results.
  // Return the original model (for chaining)
  function toSql( model ) {
    let sqlResult;
    if (options.oldTransformers) {
      sqlResult = compiler.toSql(model) ;
    } else {
      const csn = options.directBackend ? model : compactModel(model, options);
      sqlResult = toSqlWithCsn(csn, options);
    }

    ['hdbtabletype', 'hdbtable', 'hdbindex', 'hdbfulltextindex', 'hdbview', 'sql'].forEach(pluginName => {
      for(let name in sqlResult[pluginName]) {
        writeToFileOrDisplay(options.out, name + '.' + pluginName, sqlResult[pluginName][name] + '\n', true);
      }
    });
    displayNamedXsnOrCsn(sqlResult._augmentedCsn, sqlResult.csn, 'sql_csn', options);
    model.messages = sqlResult.messages;
    return model;
  }

  // Execute the command line option '--to-swagger' and display the results.
  // Return the original model (for chaining)
  function toSwagger( model ) {
    let swaggerResult = compiler.toSwagger(model);
    for (let serviceName in swaggerResult.services || {}) {
      writeToFileOrDisplay(options.out, `${serviceName}_swagger.json`, swaggerResult.services[serviceName], false);
    }
    if (swaggerResult._augmentedCsn) {
      displayNamedXsn(swaggerResult._augmentedCsn, 'swagger_csn', options);
    }
    return model;
  }

  function explain() {
    if (args.length !== 1)
      displayUsage(`Command 'explain' expects exactly one message-id.`, optionProcessor.commands['explain'].helpText, 2);

    const id = args.files[0];
    if (!hasMessageExplanation(id))
      console.error(`Message '${id}' does not have an explanation!`);
    else
      console.log(explainMessage(id));
  }

  // Display error messages in `err` resulting from a compilation.  Also set
  // process.exitCode - process.exit() will force the process to exit as quickly
  // as possible = is problematic, since console.error() might be asynchronous
  function displayErrors (err) {
    if (err instanceof compiler.CompilationError) {
      if (options.rawOutput)
        console.error( util.inspect( reveal( err.model, options.rawOutput ), false, null ));
      else
        displayMessages( err.model, err.errors );
      process.exitCode = 1;
    }
    else if (err instanceof compiler.InvocationError) {
      console.error( '' );
      for (let sub of err.errors)
        console.error( sub.message );
      console.error( '' );
      process.exitCode = 2;
    }
    else
      throw err;

    err.hasBeenReported = true;
    throw err;
  }

  function displayMessages( model, messages = model.messages ) {
    if (!Array.isArray(messages))
      return model;

    const log = console.error;

    if (options.internalMsg) {
      messages.map(msg => util.inspect( msg, { depth: null, maxArrayLength: null} ) )
        .forEach(msg => log(msg));
    }
    else if (options.noMessageContext) {
      messages.filter(msg => (messageLevels[ msg.severity ] <= options.warning))
        .forEach(msg => log(compiler.messageString(msg, normalizeFilename, !options.showMessageId)));
    }
    else {
      // Contains file-contents that are split at '\n'. Try to avoid multiple `.split()` calls.
      const splitCache = Object.create(null);
      const sourceLines = (name) => {
        if (!splitCache[name])
          splitCache[name] = fileCache[name] ? splitLines(fileCache[name]) : fileCache;
        return splitCache[name];
      };
      let hasAtLeastOneExplanation = false;
      messages.filter(msg => messageLevels[ msg.severity ] <= options.warning).forEach(msg => {
        hasAtLeastOneExplanation = hasAtLeastOneExplanation || compiler.hasMessageExplanation(msg.messageId)
        const name = msg.location && msg.location.filename;
        const fullFilePath = name ? path.resolve('', name) : undefined;
        log(compiler.messageStringMultiline(msg, normalizeFilename, !options.showMessageId));
        log(compiler.messageContext(sourceLines(fullFilePath), msg));
        log() // newline
      });
      if (options.showMessageId && hasAtLeastOneExplanation) {
        log(`${term.help('help')}: Messages marked with '…' have an explanation text. Use \`cdsc explain <message-id>\` for a more detailed error description.`)
      }
    }
    return model;
  }

  /**
   * @param {XSN.Model} xsn
   * @param {CSN.Model} csn
   * @param {string} name
   * @param {CSN.Options} options
   */
  function displayNamedXsnOrCsn(xsn, csn, name, options) {
    if(xsn && options.rawOutput) {
      displayNamedXsn(xsn, name, options);
    } else if (csn) {
      displayNamedCsn(csn, name, options);
    }
  }

  // Write the model 'model' to file '<name>.{json|raw.txt}' in directory 'options.out',
  // or display it to stdout if 'options.out' is '-'.
  // Depending on 'options.rawOutput', the model is either compacted to 'name.json' or
  // written in raw form to '<name>_raw.txt'.
  function displayNamedXsn(xsn, name, options) {
    if (options.rawOutput) {
      if(options.toCsn && options.toCsn.associations === "joins"){
        options.forHana = {};
        options.forHana.associations = options.toCsn.associations;
        writeToFileOrDisplay(options.out, name + '_raw.txt', util.inspect(reveal(translateAssocsToJoins(xsn), options.rawOutput), false, null), true);
      } else {
        writeToFileOrDisplay(options.out, name + '_raw.txt', util.inspect(reveal(xsn, options.rawOutput), false, null), true);
      }
    }
    else if (options.internalMsg) {
      writeToFileOrDisplay(options.out, name + '_raw.txt', util.inspect(reveal(xsn).messages, { depth: null, maxArrayLength: null}), true);
    }
    else if (!options.lintMode) {
      let csn = compiler.toCsn(xsn, options);
      if (options.enrichCsn)
        enrichCsn( csn, options );
      writeToFileOrDisplay(options.out, name + '.json', csn, true);
    }
  }

  /**
   * @param {CSN.Model} csn
   * @param {string} name
   * @param {CSN.Options} options
   */
  function displayNamedCsn(csn, name, options) {
    if (options.internalMsg) {
      writeToFileOrDisplay(options.out, name + '_raw.txt', csn.messages, true);
    }
    else if (!options.lintMode && !options.internalMsg) {
      writeToFileOrDisplay(options.out, name + '.json', csn, true);
    }
  }

  // Write the result 'content' to a file 'filename' in directory 'dir', except if 'dir' is '-'.
  // In that case, display 'content' to stdout.
  // If 'content' is not a string, JSON-stringify it
  // If displaying to stdout, prepend a headline containing 'filename', unless 'omitHeadline' is set.
  // For filenames, illegal characters (slash, backslash, colon) are replaced by '_'.
  function writeToFileOrDisplay(dir, filename, content, omitHeadline = false) {
    if (options.lintMode && !options.rawOutput || options.internalMsg)
      return;
    filename = filename.replace(/[:/\\]/g, '_');
    if (!(content instanceof String || typeof content === 'string')) {
      content = JSON.stringify(content, null, 2);
    }
    if (dir === '-') {
      if (!omitHeadline) {
        process.stdout.write(`// ------------------- ${filename} -------------------\n`);
      }
      process.stdout.write(`${content}\n`);
      if (!omitHeadline) {
        process.stdout.write(`\n`);
      }
    } else {
      // TODO: We might consider using async file-system API ...
      fs.writeFileSync(path.join(dir, filename), content);
    }
  }

  function catchErrors (err) {
    if (err instanceof Error && err['hasBeenReported'])
      return;
    console.error( '' );
    console.error( 'INTERNAL ERROR: %s', err );
    console.error( util.inspect(err, false, null) );
    console.error( '' );
    process.exitCode = 70;
  }
}
