// Generic ANTLR parser class with AST-building functions

// To have an AST also in the case of syntax errors, produce it by adding
// sub-nodes to a parent node, not by returning sub-ASTs (the latter is fine
// for secondary attachments).

var antlr4 = require('antlr4');
var ATNState = require('antlr4/atn/ATNState').ATNState;
var { addToDictWithIndexNo } = require('../base/dictionaries');
const locUtils = require('../base/location');
const { parseDocComment } = require('./docCommentParser');

// Class which is to be used as grammar option with
//   grammar <name> options { superclass = genericAntlrParser; }
//
// The individual AST building functions are to be used with
//   this.<function>(...)
// in the actions inside the grammar.
//
function GenericAntlrParser( ...args ) {
  // ANTLR restriction: we cannot add parameters to the constructor.
  antlr4.Parser.call( this, ...args );
  this.buildParseTrees = false;
  return this;
}

// When we define this class with the ES6 `class` syntax, we get
//   TypeError: Class constructors cannot be invoked without 'new'
// Reason: the generated ANTLR constructor calls its super constructor via
// old-style `<super>.call(this,...)`, not via `super(...)`.

GenericAntlrParser.prototype = Object.assign(
  Object.create( antlr4.Parser.prototype ), {
    message,
    attachLocation,
    startLocation,
    tokenLocation,
    combinedLocation,
    classifyImplicitName,
    identAst,
    functionAst,
    numberLiteral,
    quotedLiteral,
    pathName,
    docComment,
    addDef,
    addItem,
    assignProps,
    createPrefixOp,
    setOnce,
    setMaxCardinality,
    makeAnnotationIdentifier,
    handleComposition,
    hanaFlavorOnly,
    csnParseOnly,
    noAssignmentInSameLine,
    noSemicolonHere,
    excludeExpected,
    isStraightBefore,
    constructor: GenericAntlrParser // keep this last
  });

// Patterns for literal token tests and creation.  The value is a map from the
// `prefix` argument of function `quotedliteral` to the following properties:
//  - `test_msg`: error message which is issued if `test_fn` or `test_re` fail.
//  - `test_fn`: function called with argument `value`, fails falsy return value
//  - `test_re`: regular expression, fails if it does not match argument `value`
//  - `unexpected_msg`: error message which is issued if `unexpected_char` matches
//  - `unexpected_char`: regular expression matching an illegal character in `value`,
//    the error location is only correct for a literal <prefix>'<value>'
//  - `literal`: the value which is used instead of `prefix` in the AST
//  - `normalized`: function called with argument `value`, return value is used
//    instead of `value` in the AST
// TODO: think about laxer regexp for date/time/timestamp - normalization?
var quotedLiteralPatterns = {
  x: {
    test_msg: 'A binary literal must have an even number of characters',
    test_fn: (str => Number.isInteger(str.length / 2)),
    unexpected_msg: 'A binary literal must only contain characters 0-9, a-f and A-F',
    unexpected_char: /[^0-9a-f]/i,
    literal: 'hex'
  },
  time: {
    test_msg: 'Expected time\'HH:MM:SS\' where H, M and S are numbers and \':SS\' is optional',
    test_re: /^[0-9]{1,2}:[0-9]{1,2}(:[0-9]{1,2})?$/
  },
  date: {
    test_msg: 'Expected date\'YYYY-MM-DD\' where Y, M and D are numbers',
    test_re: /^[0-9]{1,4}-[0-9]{1,2}-[0-9]{1,2}$/
  },
  timestamp: {
    test_msg: 'Expected timestamp\'YYYY-MM-DD HH:MM:SS.u…u\' where Y, M, D, H, S and u are numbers (optional 1-7×u)',
    test_re: /^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}(:[0-9]{2}(\.[0-9]{1,7})?)?$/
  }
};


// Push message `msg` with location `loc` to array of errors:
function message( id, loc, ...args ) {
  return this.$message( id,   // function $message is set in antlrParser.js
                        (loc instanceof antlr4.CommonToken) ? this.tokenLocation(loc) : loc,
                        null, ...args );
}

// Use the following function for language constructs which we (currently)
// just being able to parse, in able to run tests from HANA CDS.  As soon as we
// create ASTs for the language construct and put it into a CSN, a
// corresponding check should actually be inside the compiler, because the same
// language construct can come from a CSN as source.
// TODO: this is not completely done this way
function hanaFlavorOnly( text, ...tokens ) {
  if (!text || this.options.hanaFlavor)
    return;
  if (typeof text !== 'string') {
    tokens = [ text, ...tokens ];
    text = tokens.map( t => t.text.toUpperCase() ).join(' ') + ' is not supported';
  }
  this.message( null, this.tokenLocation( tokens[0], tokens[ tokens.length-1 ] ), text );
}

// Use the following function for language constructs which we (currently) do
// not really compile, just use to produce a CSN for functions parseToCqn() and
// parseToExpr().
function csnParseOnly( text, ...tokens ) {
  if (!text || this.options.parseOnly)
    return;
  if (typeof text !== 'string') {
    tokens = [ text, ...tokens ];
    text = tokens.map( t => t.text.toUpperCase() ).join(' ') + ' is not supported';
  }
  this.message( null, this.tokenLocation( tokens[0], tokens[ tokens.length-1 ] ), text );
}

function noSemicolonHere() {
  let handler = this._errHandler;
  var t = this.getCurrentToken();
  this.$adaptExpectedToken = t;
  this.$adaptExpectedExcludes = ["';'", "'}'"];
  this.$nextTokensToken = t;
  this.$nextTokensContext = null; // match() of WITH does not reset
  this.$nextTokensState = ATNState.INVALID_STATE_NUMBER;
  if (t.text === ';' && handler && handler.reportIgnoredWith ) {
    handler.reportIgnoredWith( this, t );
  }
}

// Using this function "during ATN decision making" has no effect
// In front of an ATN decision, you might specify dedicated excludes
// for non-LA1 tokens via a sub-array in excludes[0].
function excludeExpected( excludes ) {
  if (excludes) {
    var t = this.getCurrentToken();
    this.$adaptExpectedToken = t;
    this.$adaptExpectedExcludes = (excludes instanceof Array) ? excludes : [excludes];
    this.$nextTokensToken = t;
    this.$nextTokensContext = null;
  }
}

// // Special function for rule `requiredSemi` before return $ctx
// function braceForSemi() {
//   if (RBRACE == null)
//     RBRACE = this.literalNames.indexOf( "'}'" );
//   console.log(RBRACE)
//   // we are called before match('}') and this.state = ...
//   let atn = this._interp.atn;
//   console.log( atn.nextTokens( atn.states[ this.state ], this._ctx ) )
//   let next = atn.states[ this.state ].transitions[0].target;
//   // if a '}' is not possible in the grammar after the fake-'}', throw error
//   if (!atn.nextTokens( next, this._ctx ).contains(RBRACE))
//     console.log( atn.nextTokens( next, this._ctx ) )
//     // throw new antlr4.error.InputMismatchException(this);
// }

function noAssignmentInSameLine() {
  var t = this.getCurrentToken();
  if (t.text === '@' && t.line <= this._input.LT(-1).line)
    this.message( 'syntax-anno-same-line', t, {},
                  'Warning', 'Annotation assignment belongs to next statement' );
}

// Use after matching ',' to allow ',' in front of the closing paren.  Be sure
// that you know what to do if successful - break/return/... = check the
// generated grammar; inside loops, you can use `break`.  This function is
// still the preferred way to express an optional ',' at the end, because it
// does not influence the error reporting.  It might also allow to match
// reserved keywords, because there is no ANTLR generated decision in front of it.
function isStraightBefore( closing ) {
  return this.getCurrentToken().text === closing;
}

// Attach location matched by current rule to node `art`.  If a location is
// already provided, only set the end location.  Use this function only
// in @after actions of parser rules, as the end position is only available
// there.
function attachLocation( art ) {
  if (!art)
    return art;
  if (!art.location)
    art.location = this.startLocation();
  let stop = this._ctx.stop;
  art.location.end = {
    offset: stop.stop + 1,      // after the last char (special for EOF?)
    line: stop.line,
    column: stop.stop - stop.start + stop.column + 2
  }
  return art;
}

/**
 * Return start location of `token`, or the first token matched by the current
 * rule if `token` is undefined
 *
 * @returns {XSN.Location}
 */
function startLocation( token = this._ctx.start ) {
  return {
    filename: this.filename,
    start: { offset: token.start, line: token.line, column: token.column + 1}
  };
}

// Return location of `token`.  If `endToken` is provided, use its end
// location as end location in the result.
function tokenLocation( token, endToken = token, val ) {
  if (!token)
    return undefined;
  let r = {
    filename: this.filename,
    start: { offset: token.start, line: token.line, column: token.column + 1},
    end: {                       // we only have single-line tokens
      offset: endToken.stop + 1, // after the last char (special for EOF?)
      line: endToken.line,
      column: endToken.stop - endToken.start + endToken.column + 2
    }
  };
  if (val !== undefined)
    return { location: r, val };
  return r;
}

// Create a location with location properties `filename` and `start` from
// argument `start`, and location property `end` from argument `end`.
function combinedLocation( start, end ) {
  if (!start || !start.location)
    start = { location: this.startLocation() };
  return locUtils.combinedLocation( start, end );
}

// If the token before the current one is a doc comment (ignoring other tokens
// on the hidden channel), put its "cleaned-up" text as value of property `doc`
// of arg `node` (which could be an array).  Complain if `doc` is already set.
function docComment( node ) {
  if(!this.options.docComment)
    return;
  const token = this._input.getHiddenTokenToLeft( this.constructor.DocComment );
  if (!token)
    return;
  if (node.doc) {
    this.message( 'syntax-duplicate-doc-comment', token, {},
                  'Warning', 'Repeated doc comment - previous doc is replaced' );
  }
  node.doc = this.tokenLocation( token, token, parseDocComment( token.text ) );
}

// Classify token (identifier category) for implicit names,
// to be used in the empty alternative to AS <explitName>.
function classifyImplicitName( category, ref ) {
  if (!ref || ref.path) {
    const implicit = this._input.LT(-1);
    if (implicit.isIdentifier)
      implicit.isIdentifier = category;
  }
}

// Return AST for identifier token `token`.  Also check that identifer is not empty.
function identAst( token, category ) {
  token.isIdentifier = category;
  let id = token.text;
  if (token.type !== this.constructor.Identifier && !/^[a-zA-Z]+$/.test( id ))
    id = '';
  if (token.text[0] === '!') {
    id = id.slice( 2, -1 ).replace( /]]/g, ']' );
    if (!id) {
      this.message( 'syntax-empty-ident', token, {},
                    'Error', 'Delimited identifier must contain at least one character' );
    }
    // XSN TODO: quoted -> $delimited (only use to complain about ![$self] usage!)
    return { id, quoted: true, location: this.tokenLocation( token ) };
  }
  if (token.text[0] !== '"')
    return { id, location: this.tokenLocation( token ) };
  // quoted:
  id = id.slice( 1, -1 ).replace( /""/g, '"' );
  if (!id) {
    this.message( 'syntax-empty-ident', token, {},
                  'Error', 'Delimited identifier must contain at least one character' );
  }
  else {
    this.message( 'syntax-deprecated-ident', token, { delimited: id }, 'Warning',
                  'Deprecated delimited identifier syntax, use $(DELIMITED) - strings are delimited by single quotes' );
  }
  return { id, quoted: true, location: this.tokenLocation( token ) };
}

function functionAst( token, xprToken ) {
  // TODO: XSN func cleanup
  const location = this.tokenLocation( token );
  const args = xprToken
        ? [ { op: { location, val: 'xpr' }, args: [], location: this.tokenLocation( xprToken ) } ]
        : [];
  return {
    op: { location, val: 'call' },
    func: { path: [ { id: token.text, location, args } ], location },
    args,
    location,
  };
}

// Return AST for number token `token` with optional token `sign`.  Represent
// the number as number in property `val` if the number can safely be
// represented as an integer.  Otherwise, represent the number by a string, the
// token lexeme.
function numberLiteral( token, sign, text = token.text ) {
  var location = this.tokenLocation( token );
  if (sign) {
    let end = location.end;
    location = this.startLocation( sign );
    location.end = end;
    text = sign.text + text;
  }
  var num = Number.parseFloat( text||'0' ); // not Number.parseInt() !
  if (!Number.isSafeInteger(num)) {
    if (sign != null)
      return { literal: 'number', val: text, location };
    this.message( 'syntax-no-integer', token, {},
                  'Error', 'An integer number is expected here' );
  }
  return { literal: 'number', val: num, location };
}

// Create AST node for quoted literals like string and e.g. date'2017-02-22'.
// This function might issue a message and might change the `literal` and
// `val` property according to `quotedLiteralPatterns` above.
function quotedLiteral( token, literal ) {
  var location = this.tokenLocation( token );
  var pos = token.text.search( '\'' ) + 1; // pos of char after quote
  var val = token.text.slice( pos, -1 ).replace( /''/g, '\'' );

  if (!literal)
    literal = token.text.slice( 0, pos-1 ).toLowerCase();
  var p = quotedLiteralPatterns[ literal ] || {};

  // TODO: make tests available for CSN parser
  if ((p.test_fn && !p.test_fn(val) || p.test_re && !p.test_re.test(val)) &&
      !this.options.parseOnly)
    this.message( null, location, p.test_msg ); // TODO: message id

  if (p.unexpected_char)
  {
    let idx = val.search(p.unexpected_char);
    if (~idx) {
      this.message( null, {     // TODO: message id
        filename: location.filename,
        start: atChar( idx ),
        end: atChar( idx + (val[idx] === '\'' ? 2 : 1) )
      }, p.unexpected_msg );
    }
  }
  return {
    literal: p.literal || literal,
    val: p.normalize && p.normalize(val) || val,
    location
  };

  function atChar(i) {
    return {
      line: location.start.line,
      column: location.start.column + pos + i,
      offset: location.start.offset + pos + i
    };
  }
}

function pathName( path, brokenName ) {
  return (path && !path.broken) ? path.map( id => id.id ).join('.') : brokenName;
}

function makeAnnotationIdentifier( at, identifier ) {
  if (!identifier)
    return identifier;
  const atLoc = { location: this.startLocation( at ) };
  if (identifier.id)
    identifier.id = '@' + identifier.id;

  // `.stop` does not point to *after* the character as opposed to XSN locations.
  if (at.stop + 1 !== identifier.location.start.offset) {
    this.message("syntax-anno-space", identifier.location, {}, 'Error',
      'Expected identifier after \'@\' but found whitespace')
  }

  identifier.location = this.combinedLocation( atLoc, identifier );

  return identifier;
}

// Add new definition to dictionary property `env` of node `parent` and return
// that definition.  Also attach the following properties to the new definition:
//  - `name`: argument `name`, which is used as key in the dictionary
//  - `kind`: argument `kind` if that is truthy
//  - `location`: argument `location` or the start location of source matched by
//    current rule
//  - properties in argument `props` which are no empty (undefined, null, {},
//    []), ANTLR tokens are replaced by their locations
//
// Hack: if argument `location` is exactly `true`, do not set `location`
// (except if part of `props`), but also include the empty properties of
// `props`.
function addDef( parent, env, kind, name, annos, props, location ) {
  if (name instanceof Array) {
    let last = name.length && name[ name.length-1 ];
    if (last && last.id)        // // A.B.C -> 'C'
      name = { id: last.id, location: last.location, calculated: true, $inferred: 'as' };
  }
  else if (name && name.id == null) {
    name.id = pathName (name.path ); // A.B.C -> 'A.B.C'
  }
  var art = this.assignProps( { name }, annos, props, location );
  if (kind)
    art.kind = kind;
  if (!parent[env])
    parent[env] = Object.create(null);
  if (!art.name || art.name.id == null) {
    // no id was parsed, but with error recovery: no further error
    env = env + '_';            // could be tested in name search
    if (!parent[env])
      parent[env] = [art];
    else
      parent[env].push(art);
  }
  else if (kind || this.options.parseOnly) {
    addToDictWithIndexNo( parent, env, art.name.id, art );
  }
  else {
    addToDictWithIndexNo( parent, env, art.name.id, art, ( name, loc ) => {
      // do not use function(), otherwise `this` is wrong:
      if (kind === 0)
        this.message( 'duplicate-argument', loc, { name },
                      'Error', 'Duplicate value for parameter $(NAME)' );
      else if (kind === '')
        this.message( 'duplicate-excluding', loc, { name },
                      'Error', 'Duplicate EXCLUDING for source element $(NAME)' );
      else
        this.message( 'duplicate-prop', loc, { name },
                      'Error', 'Duplicate value for structure property $(NAME)' );
    } );
  }
  return art;
}

// Add new definition to array property `env` of node `parent` and return
// that definition.  Also attach the following properties to the new definition:
//  - `kind`: argument `kind` if that is truthy
//  - `location`: argument `location` or the start location of source matched by
//    current rule
//  - properties in argument `props` which are no empty (undefined, null, {},
//    []); ANTLR tokens are replaced by their locations
//
// Hack: if argument `location` is exactly `true`, do not set `location`
// (except if part of `props`), but also include the empty properties of
// `props`.
function addItem( parent, env, kind, annos, props, location ) {
  var art = this.assignProps( {}, annos, props, location );
  if (kind)
    art.kind = kind;
  if (!parent[env])
    parent[env] = [ art ];
  else
    parent[env].push( art );
  return art;
}

/** Assign all non-empty (undefined, null, {}, []) properties in argument
 * `props` and argument `annos` as property `annotationAssignments` to `target`
 * and return it.  Hack: if argument `annos` is exactly `true`, return
 * `Object.assign( target, props )`, for rule `namedValue`.  ANTLR tokens are
 * replaced by their locations.
 *
 * @param {any} target
 * @param {any[]|true} [annos=[]]
 * @param {any} [props]
 * @param {any} [location]
 */
function assignProps( target, annos = [], props, location ) {
  if (annos === true)
    return Object.assign( target, props );
  target.location = location || this.startLocation( this._ctx.start );
  // Object.assign without "empty" elements/properties and with mappings:
  //  - token instanceof antlr4.CommonToken => location of token
  for (var key in props) {
    var val = props[key];
    if (val instanceof antlr4.CommonToken)
      val = this.tokenLocation( val, undefined, true);
    // only copy properties which are not undefined, null, {} or []
    if (val != null &&
        (typeof val !== 'object' ||
         (val instanceof Array ? val.length : Object.getOwnPropertyNames(val).length) ) ) {
      target[key] = val;
    }
  }
  if (annos)
    target.annotationAssignments = annos;
  return target;
}

// Create AST node for prefix operator `op` and arguments `args`
function createPrefixOp( token, args ) {
  let op = this.tokenLocation( token, undefined, token.text.toLowerCase() );
  return { op, args, location: this.combinedLocation( op, args[ args.length-1 ] ) };
}

// Set property `prop` of `target` to value `value`.  Issue error if that
// property has been set before, while mentioning the keywords previously
// provided (as arguments `tokens`).
function setOnce( target, prop, value, ...tokens ) {
  var loc = this.tokenLocation( tokens[0], tokens[tokens.length-1] );
  var prev = target[prop];
  if (prev) {
    this.message( 'syntax-repeated-option', loc, { option: prev.option },
                  'Error', 'Option $(OPTION) has already been specified' );
  }
  if (typeof value === 'boolean') {
    if (!value)
      loc.value = false;
    value = loc;
  }
  value.option = tokens.map( t => t.text.toUpperCase() ).join(' ');
  target[prop] = value;
}

function setMaxCardinality( art, token, max, inferred ) {
  let location = this.tokenLocation( token );
  if (!art.cardinality) {
    art.cardinality = { targetMax: Object.assign( {location}, max ), location };
    if (inferred)
      art.cardinality.$inferred = inferred;
  }
  else if (!inferred) {
    this.message( 'syntax-repeated-cardinality', location, { token: token.text },
                  'Warning', 'The target cardinality has already been specified - ignored $(TOKEN)' );
  }
}

function handleComposition( cardinality, isComposition ) {
  if (isComposition && !cardinality) {
    const lt1 = this._input.LT(1).type;
    const la2 = this._input.LT(2);
    if (la2.text === '{' && (lt1 === this.constructor.MANY || lt1 === this.constructor.ONE))
      la2.type = this.constructor.COMPOSITIONofBRACE;
  }
  const brace1 = (isComposition) ? 'COMPOSITIONofBRACE' : "'{'";
  const manyOne = (cardinality) ? ['MANY', 'ONE'] : [];
  this.excludeExpected( [["'}'", 'COMPOSITIONofBRACE'], brace1, ...manyOne] );
}


module.exports = {
  genericAntlrParser: GenericAntlrParser
};
