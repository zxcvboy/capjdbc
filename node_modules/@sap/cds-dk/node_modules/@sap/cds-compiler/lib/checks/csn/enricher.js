// This is very similar to lib/model/enrichCsn - but the goal and the execution differ a bit:
// - enrichCsn is used to enhance ref files for testing.
// - this file is used as a "pre-loading" step of the CSN validations.

'use strict'

const csnRefs = require('../../model/csnRefs');
const { setProp } = require('../../base/model');
/**
 * The following properties are attached as non-enumerable where appropriate:
 *
 *- `_type`, `_includes` and `_targets` have as values the
 *  referred artifacts which are returned by function `artifactRef`.
 *- `_links`, `_art` and `$scope` as sibling properties of `ref` have as values
 *  the artifacts/members returned by function `inspectRef`.
 *- `$path` has the csnPath to reach that property.
 *
 * @param {object} csn CSN to enrich in-place
 * @returns {object} CSN with all ref's pre-resolved
 */
function enrichCsn( csn ) {
  const transformers = {
    elements: dictionary,
    definitions: dictionary,
    actions: dictionary,
    params: dictionary,
    enum: dictionary,
    payload: dictionary,
    ref: pathRef,
    type: simpleRef,
    target: simpleRef,
    includes: simpleRef,
  }

  const { inspectRef, artifactRef } = csnRefs( csn );
  const csnPath = [];
  if (csn.definitions)
    dictionary( csn, 'definitions', csn.definitions );
  return csn;

  function standard( parent, prop, node ) {
    if (!node || typeof node !== 'object' || !{}.propertyIsEnumerable.call( parent, prop ) || (typeof prop === 'string' && prop.startsWith('@')))
      return;
    setProp(node, '$path', [...csnPath])

    csnPath.push( prop );

    if (node instanceof Array) {
      node.forEach( (n, i) => standard( node, i, n ) );
    }
    else {
      for (let name of Object.getOwnPropertyNames( node )) {
        const trans = transformers[name] || standard;
        trans( node, name, node[name] );
      }
    }
    csnPath.pop();
  }

  function dictionary( node, prop, dict ) {
    setProp(node, '$path', [...csnPath])

    csnPath.push( prop );
    for (let name of Object.getOwnPropertyNames( dict )) {
      standard( dict, name, dict[name] );
    }
    if (!Object.prototype.propertyIsEnumerable.call( node, prop ))
      setProp(node, '$' + prop, dict);
    csnPath.pop();
  }

  function simpleRef( node, prop ) {
    setProp(node, '$path', [...csnPath])
    let ref = node[prop];
    if (typeof ref === 'string') {
      const art = artifactRef( ref, null );
      if (art || !ref.startsWith( 'cds.'))
        setProp(node, '_' + prop, art);
    }
    else if (Array.isArray( ref )) {
      setProp(node,'_' + prop,ref.map( r => artifactRef( r, null ) ));
    }
  }

  function pathRef( node, prop, path ) {
    const { links, art, scope } = inspectRef( csnPath );
    if (links) setProp(node, '_links', links);
    if (art) setProp(node, '_art', art );
    setProp(node, "$scope", scope)
    setProp(node, '$path', [...csnPath])

    csnPath.push( prop );
    path.forEach( function step( s, i ) {
      if (s && typeof s === 'object') {
        csnPath.push( i );
        if (s.args)
          standard( s, 'args', s.args );
        if (s.where)
          standard( s, 'where', s.where );
        csnPath.pop();
      }
    } );
    csnPath.pop();
  }
}

module.exports = enrichCsn;
