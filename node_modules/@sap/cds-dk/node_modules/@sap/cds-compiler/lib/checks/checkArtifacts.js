'use strict';

const alerts = require('../base/alerts');
const { getMessageFunction } = require('../base/messages');
const { hasArtifactTypeInformation } = require('../model/modelUtils')
const builtins = require('../compiler/builtins');

// Semantic checks that are performed on artifacts

// Check that artifact 'art' is not empty and does not contain only virtual elements
// (not applicable to abstract artifacts)
function checkNotEmptyOrOnlyVirtualElems(art, model) {
  if (!art.abstract) {
    const isEmpty = isEmptyArtifact(art);
    const emptyOrOnlyVirtual = isEmpty || emptyOrOnlyVirtualElements(art);

    if (emptyOrOnlyVirtual) {
      const location = art.name && art.name.location || art.location;
      const message = getMessageFunction(model);

      if (art.kind === 'entity') {
        message('empty-entity', location, art, { '#': isEmpty ? 'empty' : 'virtual' }, 'Info', {
          virtual: 'An entity without non-virtual elements cannot be deployed or used in a service',
          empty: 'An entity without elements cannot be deployed or used in a service'
        });
      }
      else if (art.kind === 'type') {
        message('empty-type', location, art, { '#': isEmpty ? 'empty' : 'virtual' }, 'Info', {
          virtual: 'Structured type without non-virtual elements',
          empty: 'Structured type without elements'
        });
      }
    }
  }

  // Returns true if the construct is structured and has 0 elements.
  function isEmptyArtifact(construct) {
    const elements = (construct._finalType || construct).elements;
    return elements && Object.keys(elements).length === 0;
  }

  // Return true if artifact or element 'construct' is a virtual element or an empty structure
  // or a structure that (recursively) is empty or only contains virtual elements
  function emptyOrOnlyVirtualElements(construct) {
    // Structured type ?
    if ((construct._finalType || construct).elements) {
      construct = construct._finalType || construct;
      // No elements or all elements recursively empty, too ?
      return Object.keys(construct.elements)
        .map(k => construct.elements[k])
        .every(elm => emptyOrOnlyVirtualElements(elm));
    }
    // Non-structured type - just check for virtual-ness or non-existing elements for entities or views
    return construct.virtual || (( construct.kind === 'entity' || construct.kind === 'view' ) && construct.elements === undefined );
  }
}

// Check that queries in 'art' do not contain unmanaged associations in GROUP BY or ORDER BY
function checkNoUnmanagedAssocsInGroupByOrderBy(art, model) {
  const { error, signal } = alerts(model);
  for (let query of art.$queries || []) {
    for (let groupByEntry of query.groupBy || []) {
      if (groupByEntry._artifact && groupByEntry._artifact._finalType && groupByEntry._artifact._finalType.onCond) {
        // Unmanaged association - complain
        signal(error`"${art.name.absolute}": Unmanaged associations are not allowed in GROUP BY`, groupByEntry.location);
      }
    }
    for (let orderByEntry of query.orderBy || []) {
      if (orderByEntry.value && orderByEntry.value._artifact && orderByEntry.value._artifact._finalType && orderByEntry.value._artifact._finalType.onCond) {
        // Unmanaged association - complain
        signal(error`"${art.name.absolute}": Unmanaged associations are not allowed in ORDER BY`, orderByEntry.value.location);
      }
    }
  }
}

/**
 * If the given artifact is a type definition then check whether it is
 * properly defined and has valid type information, e.g. information about
 * its elements or references another valid type.
 *
 * @param {XSN.Definition} artifact
 * @param {XSN.Model} model
 */
function checkTypeDefinitionHasType(artifact, model) {
  if (artifact.kind !== 'type')
    return;

  checkArtifactHasProperType(artifact, model);
}

/**
 * Check that the given artifact has proper type information.
 * Either the artifact itself is a proper type or its `type` property
 * references a proper type (including `many type of`).
 *
 * @param {XSN.Definition} artifact
 * @param {XSN.Model} model
 */
function checkArtifactHasProperType(artifact, model) {
  function warnAboutMissingType(art) {
    // Can happen in CSN, e.g. `{ a: { kind: "type" } }` but should
    // not happen in CDL.
    const message = getMessageFunction(model);
    message('check-proper-type', art.location, art, { art: artifact },
            ['Error'], {
              std: 'Dubious type $(ART) without type information',
              element: 'Dubious element $(MEMBER) of $(ART) without type information',
            });
  }

  if (!hasArtifactTypeInformation(artifact)) {
    warnAboutMissingType(artifact);
    return;
  }

  // Check for `type of`
  if (artifact.type) {
    checkTypeOfHasProperType(artifact, model)
    return;
  }

  const items = artifact.items;
  if (!items)
    return;

  // `array of` without nested `type of`
  if (!hasArtifactTypeInformation(items))
    warnAboutMissingType(items);

  else if (items && items.type)
    // `array of type of`
    checkTypeOfHasProperType(items, model)
}

/**
 * Check that the `type of` information in the given artifact (i.e. `type` property)
 * has proper type information or warn otherwise. The artifact's final type is checked.
 *
 * @param {XSN.Artifact} artifact
 * @param {XSN.Model} model
 */
function checkTypeOfHasProperType(artifact, model) {
  if (!artifact.type)
    return;

  const finalType = artifact.type._artifact && artifact.type._artifact._finalType;
  if (finalType && !hasArtifactTypeInformation(finalType)) {
    const message = getMessageFunction(model);
    message('check-proper-type-of', artifact.type.location, artifact, { art: artifact.type },
            'Info', {
              std: 'Referred type of $(ART) does not contain proper type information',
              element: 'Referred element $(MEMBER) of $(ART) does not contain proper type information',
            });
    return;
  }
}

/**
 * Run checks on the whole enum type, e.g. that elements have a value.
 *
 * @param {XSN.Artifact} enumNode
 */
function checkIntegerEnumHasValues(enumNode, model) {
  const type = enumNode.type && enumNode.type._artifact && enumNode.type._artifact._finalType;
  if (!enumNode.enum || !type || !type.builtin)
    return;

  // Currently only run check for integer enums.
  if (!builtins.isIntegerTypeName(type.name.absolute))
    return;

  const failedAt = Object.keys(enumNode.enum).find(name => !enumNode.enum[name].value);
  if (!failedAt)
    return;

  const message = getMessageFunction(model);
  message('enum-missing-value', enumNode.enum[failedAt].location, enumNode.enum[failedAt],
    { name: failedAt }, 'Warning', 'Missing value for integer enum element $(NAME)');
}

/**
 * Check the given enum's elements and their values.  For example
 * whether the value types are valid for the used enum type.
 * `enumNode` can be also be `type.items` if the type is an arrayed enum.
 *
 * @param {XSN.Definition} enumNode
 * @param {XSN.Model} model
 */
function checkEnumValueType(enumNode, model) {
  const type = enumNode.type && enumNode.type._artifact && enumNode.type._artifact._finalType;
  if (!enumNode.enum || !type || !type.builtin)
    return;

  const isInteger = builtins.isIntegerTypeName(type.name.absolute);
  const isString = builtins.isStringTypeName(type.name.absolute);

  // Only string and integer enums are allowed. Other checks handle other types.
  if (!isString && !isInteger)
    return;

  const expectedType = isInteger ? 'number' : 'string';

  // Do not check elements that don't have a value at all or are
  // references to other enum elements.  There are other checks for that.
  const hasWrongType = element => element.value &&
    (element.value.literal !== expectedType) &&
    (element.value.literal !== 'enum');

  const message = getMessageFunction(model);

  for (const key of Object.keys(enumNode.enum)) {
    const element = enumNode.enum[key];
    if (!hasWrongType(element))
      continue;

    // Literal type is 'number' but we only support integer enums and not decimals.
    let actualType = element.value.literal;
    actualType = (actualType === 'number' ? 'integer' : actualType);

    message('enum-value-type', element.value.location, element,
      { '#': expectedType, name: key, prop: actualType }, 'Warning', {
        number: 'Expected integer value for enum element $(NAME) but was $(PROP)',
        string: 'Expected string value for enum element $(NAME) but was $(PROP)'
      });
  }
}

function checkEnumType(enumNode, model) {
  // Either the type is an enum or an arrayed enum.  We are only interested in
  // the enum and don't care whether the enum is arrayed.
  enumNode = enumNode.enum ? enumNode : enumNode.items;
  if (!enumNode || !enumNode.enum)
    return;
  const finalType = enumNode.type && enumNode.type._artifact && enumNode.type._artifact._finalType;
  if (!finalType)
    return;

  // _finalType may point to a type one level above a builtin.
  // This `.type` may be another enum so we need to check for that.
  const type = finalType.type && !finalType.enum ? finalType.type._artifact : finalType;
  const name = type.name.absolute;

  const isInteger = builtins.isIntegerTypeName(name);
  const isString = builtins.isStringTypeName(name);

  if (!isInteger && !isString) {
    const message = getMessageFunction(model);
    message('enum-invalid-type', enumNode.type.location, enumNode,
      {}, 'Warning',
      'Only string- or integer-like types are allowed for enums');
    return;
  }

  checkEnumValueType(enumNode, model);

  if (isInteger) {
    checkIntegerEnumHasValues(enumNode, model);
  }
}

module.exports = {
  checkNotEmptyOrOnlyVirtualElems,
  checkNoUnmanagedAssocsInGroupByOrderBy,
  checkTypeDefinitionHasType,
  checkTypeOfHasProperType,
  checkArtifactHasProperType,
  checkEnumType,
  checkIntegerEnumHasValues,
};
