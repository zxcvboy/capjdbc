'use strict';

const { isArtifact, isContainerArtifact } = require('../model/modelUtils');
const builtins = require('../compiler/builtins.js');
const alerts = require('../base/alerts');

// Check the annotation assignments (if any) of 'annotatable', possibly using annotation
// definitions from 'model'. Report errors on 'model.messages.
function checkAnnotationAssignments(annotatable, model) {
  const { warning, signal } = alerts(model);

  // Iterate all annotations of 'annotatable'
  Object.keys(annotatable).filter(a => a.startsWith('@')).forEach(a => {
    let anno = annotatable[a];

    // Sanity checks (ignore broken assignments)
    if (!anno.name || !anno.name.path) {
      return;
      // throw new Error('Expecting annotation assignment to have a name with a path: ' + JSON.stringify(anno));
    }

    // Artifact for first path step of annotation path has been provided by compiler if found
    let fromArtifact = anno.name.path[0]._artifact;
    if (!fromArtifact) {
      // Unchecked annotation, because not even the first path step was resolvable => nothing to check
      return;
    }
    // Resolve manually
    // FIXME: This will probably be done by the compiler some day
    // Note: Even if we just got an _artifact here, it might (depending on processing order) be an incomplete
    // one (at the time it is attached to the annotation, it might just be a USING, and currently this is not
    // really 'resolved' by the compiler for annotation assignments). The only thing the artifact is
    // guaranteed to already have is an absolute name. So we go and look that up in 'definitions' before using it.
    fromArtifact = model.definitions[fromArtifact.name.absolute];
    let { artifact, endOfPath } = resolvePathFrom(anno.name.path.slice(1), fromArtifact);

    // Check what we actually want to check
    checkAnnotationAssignment(anno, artifact, endOfPath);
  });

  // Perform checks for annotation assignment 'anno', using corresponding annotation declaration,
  // made of 'annoDecl' (artifact or undefined) and 'elementDecl' (annotation or element
  // or undefined). Report errors on 'model.messages.
  function checkAnnotationAssignment(anno, annoDecl, elementDecl) {
    // Nothing to check if no actual annotation declaration was found
    if (!annoDecl || (isContainerArtifact(annoDecl) && !elementDecl)) {
      return;
    }

    // Must be an annotation if found
    if (annoDecl.kind !== 'annotation') {
      signal(warning`"${annoDecl.name.absolute}" is a ${annoDecl.kind}, not an annotation`, anno.location || anno.name.location);
      return;
    }

    // Element must exist in annotation
    if (!elementDecl) {
      signal(warning`Element "${anno.name.path.map(step => step.id).join('.')}" not found for annotation "${annoDecl.name.absolute}"`, anno.location || anno.name.location);
      return;
    }

    // Sanity checks
    if (!elementDecl._finalType) {
      throw new Error('Expecting annotation declaration to have _finalType: ' + JSON.stringify(annoDecl));
    }

    // Must have literal or path unless it is a boolean
    if (!anno.literal && !anno.path && getFinalTypeNameOf(elementDecl) !== 'cds.Boolean') {
      if (elementDecl.type && elementDecl.type._artifact.name.absolute) {
        signal(warning`Expecting a value of type "${elementDecl.type._artifact.name.absolute}" for the annotation`, anno.location || anno.name.location);
      } else {
        signal(warning`Expecting a value for the annotation`, anno.location || anno.name.location);
      }
      return;
    }

    // Value must be assignable to type
    checkValueAssignableTo(anno, elementDecl);
  }

  // Check that annotation assignment 'value' (having 'path or 'literal' and 'val') is potentially assignable
  // to element 'element'. Complain on 'loc' if not
  function checkValueAssignableTo(value, elementDecl) {
    // FIXME: We currently do not have any element declaration that could match a 'path' value, so we simply
    // leave those alone
    if (value.path) {
      return;
    }

    // Array expected?
    if (elementDecl._finalType.items) {
      // Make sure we have an array value
      if (value.literal !== 'array') {
        signal(warning`An array value is required here`, value.location || value.name.location);
        return;
      }
      // Check each element
      for (let valueItem of value.val) {
        checkValueAssignableTo(valueItem, elementDecl._finalType.items);
      }
      return;
    }

    // Struct expected (can only happen within arrays)?
    if (elementDecl._finalType.elements) {
      if (value.literal !== 'struct') {
        signal(warning`A struct value is required here`, value.location || value.name.location);
        return;
      }
      // FIXME: Should check each element
      return;
    }

    // Handle each (primitive) expected element type separately
    let type = getFinalTypeNameOf(elementDecl);
    if (builtins.isStringTypeName(type)) {
      if (value.literal !== 'string' && value.literal !== 'enum' && !elementDecl._finalType.enum) {
        signal(warning`A string value is required for type "${type}"`, value.location || value.name.location);
      }
    } else if (builtins.isBinaryTypeName(type)) {
      if (value.literal !== 'string' && value.literal !== 'hex') {
        signal(warning`A hexadecimal string value is required for type "${type}"`, value.location || value.name.location);
      }
    } else if (builtins.isNumericTypeName(type)) {
      if (value.literal !== 'number' && value.literal !== 'enum' && !elementDecl._finalType.enum) {
        signal(warning`A numerical value is required for type "${type}"`, value.location || value.name.location);
      }
    } else if (builtins.isDateOrTimeTypeName(type)) {
      if (value.literal !== 'date' && value.literal !== 'time' && value.literal !== 'timestamp' && value.literal !== 'string') {
        signal(warning`A date/time value or a string is required for type "${type}"`, value.location || value.name.location);
      }
    } else if (builtins.isBooleanTypeName(type)) {
      if (value.literal && value.literal !== 'boolean') {
        signal(warning`A boolean value is required for type "${type}"`, value.location || value.name.location);
      }
    } else if(builtins.isRelationTypeName(type) || builtins.isGeoTypeName(type)) {
      signal(warning`Type "${type}" cannot be assigned a value`, value.location || value.name.location);
    } else {
      throw new Error('Unknown primitive type name: ' + type);
    }

    // Check enums
    let expectedEnum = elementDecl._finalType.enum;
    if (value.literal === 'enum') {
      if (expectedEnum) {
        // Enum symbol provided and expected
        if (!expectedEnum[value.symbol.id]) {
          // .. but no such constant
          signal(warning`Enum symbol "#${value.symbol.id}" not found in enum`, value.location || value.name.location);
        }
      } else {
        // Enum symbol provided but not expected
        signal(warning`Cannot use enum symbol "#${value.symbol.id}" for non-enum type "${type}"`, value.location || value.name.location);
      }
    } else {
      if (expectedEnum) {
        // Enum symbol not provided but expected
        if (!Object.keys(expectedEnum).some(symbol => expectedEnum[symbol].value.val == value.val)) {
          // ... and none of the valid enum symbols matches the value
          signal(warning`An enum value is required here`, value.location || value.name.location);
        }
      }
    }
  }

  // Return the artifact (and possibly, its element) found by following 'path' starting at 'from'.
  // The return value is an object { artifact, endOfPath } with 'artifact' being the last artifact
  // encountered on 'path' (or 'undefined' if none found), and 'endOfPath' being the element or artifact
  // represented by the full path (or 'undefined' if not found).
  // Note that only elements and artifacts are considered for path traversal (no actions, functions,
  // parameters etc.)
  function resolvePathFrom(path, from, result = {}) {
    // Keep last encountered artifacts
    if (isArtifact(from)) {
      result.artifact = from;
    }
    // Always keep current path end
    result.endOfPath = from;
    // Stop if found or failed
    if (path.length === 0 || !from) {
      return result;
    }
    // Continue search with next path step
    let nextStepEnv = (from._finalType || from).artifacts || from._finalType.elements || [];
    return resolvePathFrom(path.slice(1), nextStepEnv[path[0].id], result);
  }

  // Return the absolute name of the final type of 'node'. May return 'undefined' for
  // anonymous types
  function getFinalTypeNameOf(node) {
    let type = node._finalType;
    if (type.type)
      type = type.type._artifact;
    return type && type.name && type.name.absolute;
  }
}

module.exports = checkAnnotationAssignments;
