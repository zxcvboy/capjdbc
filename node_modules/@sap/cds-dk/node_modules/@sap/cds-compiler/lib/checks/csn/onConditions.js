'use strict';
const { forEachGeneric, isBuiltinType } = require('../../model/csnUtils');

// Only to be used with validator.js - a correct this value needs to be provided!

/**
 * Prepare the ref steps so that they are loggable
 *
 * @param {any} refStep part of a ref
 * @returns {string}
 */
function logReady(refStep){
  return refStep.id || refStep;
}

/**
 * Check that the other side of the comparison is a valid $self backlink
 *
 * - operator "="
 * - nothing but "$self", no further steps
 *
 * @param {Object[]} on On-Condition
 * @param {Number} startIndex Index of the current expression to "look around"
 * @returns {boolean}
 */
function otherSideIsValidDollarSelf(on, startIndex){
  if(on[startIndex-1] && on[startIndex-1] === '='){
    if(on[startIndex-2]){
      const ref = on[startIndex-2].ref;
      return ref && ref.length === 1 && ( ref[0] === '$self' || ref[0] === '$projection' );
    } else {
      return false;
    }
  } else if(on[startIndex+1] && on[startIndex+1] === '='){
    if(on[startIndex+2]){
      const ref = on[startIndex+2].ref;
      return ref && ref.length === 1 && ( ref[0] === '$self' || ref[0] === '$projection' );
    } else {
      return false;
    }
  } else {
    return false;
  }
}

/*
  * Check that the opposite operand to a relational term is something
  * structured that can be used for tuple expansion. This can either be a
  * real 'elements' thing or a managed association/composition with foreign keys.
  *
  * @param {Object[]} on On-Condition
  * @param {Number} startIndex Index of the current expression to "look around"
  * @param {Object} this to obtain bound functions and model
  * @returns {boolean}
  */
function otherSideIsExpandableStructure(on, startIndex, me) {
  if(on[startIndex-1] && ['=', '<', '>', '>=', '<=', '!=', '<>'].includes(on[startIndex-1])) {
    return isOk(resolveArtifactType(on[startIndex-2]._art, me));
  }
  else if(on[startIndex+1] && ['=', '<', '>', '>=', '<=', '!=', '<>'].includes(on[startIndex+1])) {
    return isOk(resolveArtifactType(on[startIndex+2]._art, me));
  }
  return false;

  function isOk(art) {
    return !!(art && (art.elements || (art.target && art.keys)));
  }

}

/*
 * @param {Object} artifact
 * @param {Object} this to obtain bound functions and model
 * @returns {Object} final artifact type
 */
function resolveArtifactType(art, me) {
  if(art && art.type) {
    // 1) Dereference 'type of'
    if(art.type.ref) { // type of
      art = me.artifactRef(art.type);
    }
    // 2) Lookup named 'type T', if not builtin
    if(art && art.type && !isBuiltinType(art.type)) {
      art = me.csn.definitions[me.effectiveType(art.type)];
    }
  }
  return art;
}

/**
 * Validate an on-condition
 *
 * - no traversal of unmanaged associations
 * - only use managed associations to access their foreign keys
 * - no filters
 * - no parameters
 * - must end in scalar type - unless $self comparison
 *
 * @param {object} member Member
 * @param {string} memberName Name of the member
 * @param {string} property Current property (part of forEachMember)
 * @param {Array} path CSN Path to current member
 */
function validateOnCondition(member, memberName, property, path){
  if(member && member.on){
    for(let i = 0; i < member.on.length; i++){
      if(member.on[i].ref){
        const ref = member.on[i].ref;
        let { _links, _art, $scope } = member.on[i];
        if(!_links) continue;
        const validDollarSelf = otherSideIsValidDollarSelf(member.on, i);
        const validStructuredElement = otherSideIsExpandableStructure(member.on, i, this);
        for(let j = 0; j < _links.length-1; j++){
          if(_links[j].art.target && !((_links[j].art === member) || ref[j] === '$self' || ref[j] === '$projection' || (validDollarSelf && j === _links.length - 1))){
            if(_links[j].art.on){
              // It's an unmanaged association - traversal is always forbidden
              this.signal(this.error`ON-Conditions can not follow unmanaged associations, step "${logReady(ref[j])}" of path ${ref.map(ps => `"${logReady(ps)}"`).join('.')}.`, path.concat(['on', i, 'ref', j]));
            } else {
              // It's a managed association - access of the foreign keys is allowed
              const nextRef = ref[j+1].id || ref[j+1];
              if(!_links[j].art.keys.some(ref => ref.ref[0] === nextRef)){
                this.signal(this.error`ON-Conditions can only follow managed associations to the foreign keys of the managed association, step "${logReady(ref[j])}" of path ${ref.map(ps => `"${logReady(ps)}"`).join('.')}`, path.concat(['on', i, 'ref', j]));
              }
            }
          }

          if(ref[j].where){
            this.signal(this.error`ON-Conditions must not contain filters, step "${logReady(ref[j])}" of path ${ref.map(ps => `"${logReady(ps)}"`).join('.')}.`, path.concat(['on', i, 'ref', j]));
          }

          if(ref[j].args){
            this.signal(this.error`ON-Conditions must not contain parameters, step "${logReady(ref[j])}" of path ${ref.map(ps => `"${logReady(ps)}"`).join('.')}.`, path.concat(['on', i, 'ref', j]));
          }
        }
        if(_art && $scope !== '$self') {
          _art = resolveArtifactType(_art, this);
          // Paths of an ON condition may end on a structured element or an association only if:
          // 1) Both operands in the expression end on a structured element or on
          //    a managed association (that are both expandable)
          // 2) Path ends on an association (managed or unmanaged) and the other operand is a '$self'

          // If this path ends structured or on an association, perform the check:
          if((_art.elements || _art.target) &&
             !( /* 1) */ (_art.elements || _art.target && _art.keys) && validStructuredElement ||
                /* 2) */ (_art.target && validDollarSelf))) {
            this.signal(this.error`The last path of an on-condition must be a scalar value, path ${ref.map(ps => `"${logReady(ps)}"`).join('.')}`, path.concat(['on', i,'ref',ref.length-1]))
          }
          else if(_art.items){
            this.signal(this.error`ON-Conditions can not use array-like elements, path ${ref.map(ps => `"${logReady(ps)}"`).join('.')}`, path.concat(['on', i, 'ref', ref.length-1]));
          }
        }
      }
    }
  }


}

function validateMixinOnCondition(query, path) {
  if(query.SELECT && query.SELECT.mixin) {
    forEachGeneric( query.SELECT, 'mixin', validateOnCondition.bind(this), path );
  }
}
module.exports = { validateOnCondition, validateMixinOnCondition };
