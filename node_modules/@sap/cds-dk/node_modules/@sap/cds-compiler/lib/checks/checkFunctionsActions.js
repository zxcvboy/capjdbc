'use strict';

const alerts = require('../base/alerts');
const { getMessageFunction } = require('../base/messages');

/**
 * @param {object} model XSN Model: only used for messages and options
 */
function getFunctionAndActionChecks(model) {
  const { warning, signal } = alerts(model);
  const message = getMessageFunction(model);
  let options = model.options;

  return {
    checkActionOrFunction,
    checkActionOrFunctionParameter,
    serviceNameFor
  }

  function checkActionOrFunction(act) {
    if (Array.isArray(act)) // duplicated declaration -> will be handled in some of the other steps of the compiler
      return;

    const location = act.location;
    const originalAction = act;

    checkIfInService(act);

    // Get the service name for the current function/action. We do it at this point because
    // if the origin of "act" is set (e.g. through a projection) then we replace "act" with the
    // original artefact which may not have a service.
    const serviceName = serviceNameFor(act);

    if (act.origin) {
      act = act.origin._artifact || /* old csn does not have the _artifact */ act;
      if (act.params) // params are still not propagated at this point, so have to be checked separately
        Object.keys(act.params).forEach(p => checkActionOrFunctionParameter(act.params[p], serviceName, location));
    }

    // check all the cases of the return statement
    if (act.returns) {
      if (act.returns._finalType.builtin && options.toOdata && options.toOdata.version === 'v2') {
        // in ODATA v2 scalar types cannot be returned
        signal(warning`Scalar return types are not allowed in OData V2`, location);
        return;
      }
      // check array return type
      if (act.returns.items)
        checkReturnTypeArray();
      // check if return type is entity from the current service
      else if (act.returns._finalType.kind === 'entity')
        checkReturnEntity();
      else if (act.returns._finalType.kind === 'type')
        checkReturnUserDefinedType();
    }

    function checkReturnTypeArray() {
      if (!act.returns.items)
        return;
      // array of array is not allowed
      if (act.returns._finalType.items._finalType.items)
        signal(warning`Array element cannot be an array`, location);

      // array of builtin not allowed in OData V2
      if (act.returns.items._finalType.builtin && options.toOdata && options.toOdata.version === 'v2')
        signal(warning`Scalar return types are not allowed in OData V2`, location);

      // array of <entity> - check if entity is from the current service
      if (act.returns.items._finalType.kind === 'entity')
        checkReturnEntity();
    }

    function checkReturnEntity() {
      // take the full name with the entity name
      const absoluteReturnTypeName = act.returns.items
        ? act.returns.items._finalType.name.absolute
        : act.returns._finalType.name.absolute;
      // remove the entity name
      const returnServiceName = getAbsNameWithoutId(absoluteReturnTypeName);
      if (serviceName && returnServiceName !== serviceName) {
        let loc;
        // The action/function may be part of a projection.
        // If it is then we should use the original's location and
        // not the one of "origin" one because in the latter case
        // we would otherwise have invalid or confusing warnings.
        if (originalAction.origin) {
          loc = originalAction.location;
        } else {
          const type = (act.returns.items ? act.returns.items.type : act.returns.type);
          loc = type ? type.location : null;
        }
        signal(warning`Entity type must be from the current service '${serviceName}'`, loc || location);
      }
    }

    function checkReturnUserDefinedType() {
      // the case when user defined is resolved to builtin
      if (act.returns._finalType.type && act.returns._finalType.type._artifact.builtin) {
        if (options.toOdata && options.toOdata.version === 'v2')
          signal(warning`Scalar return types are not allowed in OData V2`, location);
        return;
      }
    }
  }

  function checkActionOrFunctionParameter(param, serviceName, location) {
    location = location || param.location;

    const paramTypeArtifact = param.type && param.type._artifact || {};
    // check if the entity type is from the current service
    if (paramTypeArtifact.kind === 'entity')
      checkEntityParam(paramTypeArtifact);

    if (paramTypeArtifact.default) {
      message('param-default', param.name.location, param, {}, ['Error'],
        'Action and function parameters cannot have a default value')
    }

    function checkEntityParam(paramTypeArtifact) {
      if (serviceName && getAbsNameWithoutId(paramTypeArtifact.name.absolute) !== serviceName)
        signal(warning`The parameter entity type must be from the current service '${serviceName}'`, location);
    }
  }

  function checkIfInService(action) {
    if (!serviceNameFor(action)) {
      signal(warning`Functions and actions must be declared in a service`, action.location);
    }
  }
}

function getAbsNameWithoutId(name) {
  return name.split('.').slice(0, -1).join('.');
}

/**
 * Get the absolute service name for the given action or entity.
 * If the action is bound, the service name of its entity is returned.
 * @param {object} action An action or entity.
 * @returns {string} Absolute service name or an empty string if not service is set.
 */
function serviceNameFor(action) {
  if (action._service) {
    return action._service.name.absolute;

  } else if (action._main && action._main._service) {
    return action._main._service.name.absolute;
  }

  return '';
}

module.exports = getFunctionAndActionChecks;
