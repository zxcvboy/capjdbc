'use strict'

// Low-level utility functions to work with augmented CSN.

// TODO: Are these functions written with derived types in mind (or even that
// an element definition uses an association type)?  Some are, others not...

// Return true if 'node is a managed association element
// TODO: what about elements having a type, which (finally) is a assoc?
function isManagedAssociationElement(node) {
  return node.kind === 'element' && node.target != undefined && node.onCond == undefined;
}

// Return true if 'type' is an association or composition
function isAssocOrComposition(type) {
  if (!type)
    return type;
  if (type._artifact)
    type = type._artifact.name;
  return type.absolute === 'cds.Association' || type.absolute === 'cds.Composition';
}

// Return true if 'type' is an association type
function isAssociation(type) {
  if (!type)
    return type;
  if (type._artifact)
    type = type._artifact.name;
  return type.absolute === 'cds.Association';
}
// Return true if 'type' is a composition type
function isComposition(type) {
  if (!type)
    return type;
  if (type._artifact)
    type = type._artifact.name;
  return type.absolute === 'cds.Composition';
}

// Return true if 'elem' is an element (plus sanity check: must have _finalType)
function isElement(elem) {
  if (elem.kind !== 'element') {
    return false;
  }
  // Sanity checks
  if (!elem._finalType) {
    throw Error('Expecting element ' + printableName(elem) + ' to have _finalType');
  }
  return true;
}

// Return true if 'elem' is a structured element
function isStructuredElement(elem) {
  return isElement(elem) && elem._finalType.elements != undefined;
}

// Return true if 'elem' is an array-typed element
function isArrayElement(elem) {
  return isElement(elem) && elem._finalType.items != undefined;
}

// Return true if 'elem' is an association or composition element
function isAssociationElement(elem) {
  return isElement(elem) && elem._finalType.target != undefined;
}

// Return true if 'elem' is a scalar element (i.e. a primitive type, possibly an enum,
// not structured, not an array, not an association/composition)
function isScalarElement(elem) {
  return isElement(elem) && elem._finalType.type != undefined;
}

// Return true is 'elem' is an alement that has a type (in contrast e.g. to expression
// elements in views which don't)
function isElementWithType(elem) {
  return isScalarElement(elem) || isAssociationElement(elem) || isArrayElement(elem) || isStructuredElement(elem);
}

// Return true if 'node' has an artifact kind (i.e. may potentially live in 'definitions')
function isArtifact(node) {
  if (!node) {
    return false;
  }
  switch (node.kind) {
    case 'context':
    case 'service':
    case 'namespace':
    case 'entity':
    case 'view':
    case 'type':
    case 'annotation':
    case 'action':
    case 'function':
    case 'const':
    case 'role':
    case 'aspect':
    case 'accesspolicy':
      return true;
    case 'element':
    case 'query':
    case 'param':
    case 'enum':
      return false;
    default:
      throw new Error('Unknown artifact kind: ' + node.kind);
  }
}

// Return true if 'node' is an artifact that may contain other artifacts
function isContainerArtifact(node) {
  if (!isArtifact(node)) {
    return false;
  }
  switch (node.kind) {
    case 'context':
    case 'service':
    case 'namespace':
    case 'accesspolicy':
      return true;
    default:
      return false;
  }
}

/**
 * Check whether the given artifact has type information.  An artifact has type
 * information when it is either a builtin, a struct, an enum, an array, an
 * association OR if it references another type, i.e. typeOf.  For the latter
 * case an artifact's final type must be checked.
 *
 * @param {object} artifact
 * @returns {boolean}
 */
function hasArtifactTypeInformation(artifact) {
  // When is what property set?
  return artifact.builtin // => `Integer`
    || artifact.elements  // => `type A {}`
    || artifact.items     // => `type A : array of Integer`
    || artifact.enum      // => `type A : Integer enum {}`, `type` also set
    || artifact.target    // => `type A : Association to B;`
    || artifact.type;     // => `type A : [type of] Integer`
}

// Produce a printable name (for error messages) for element or artifact 'node'
function printableName(node) {
  let name = node.name && node.name.absolute ||
             node._main && node._main.name && node._main.name.absolute;
  let element = node.name && node.name.element;
  if (name && element) {
    name += ', ' + element;
  }
  return (node.kind || '<kind>') + '(' + name + ')';
}

// Add an annotation with absolute name 'absoluteName' (including '@') and string value 'theValue' to 'node'
function addStringAnnotationTo(absoluteName, theValue, node) {
  // Sanity check
  if (!absoluteName.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + absoluteName);
  }
  if(isAnnotationAssignable(node, absoluteName)) {
    // Assemble the annotation
    node[absoluteName] = {
      name: {
        absolute: absoluteName.substring(1),
      },
      val: theValue,
      literal: 'string',
    };
  }
}

/**
 * Check wether an annotation can be assigned or not
 * (must be either undefined or null value)
 * @param {object} node Assignee
 * @param {string} name Annotation name
 * @returns {boolean}
 */
function isAnnotationAssignable(node, name) {
  if (!name.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + name);
  }
  return (node[name] === undefined || node[name] && node[name].val === null);
}

// Add an annotation with absolute name 'absoluteName' (including '@') and string value 'theValue' to 'node'
function addBoolAnnotationTo(absoluteName, theValue, node) {
  // Sanity check
  if (!absoluteName.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + absoluteName);
  }
  // Assemble the annotation
  if(isAnnotationAssignable(node, absoluteName)) {
    node[absoluteName] = {
      name: {
        absolute: absoluteName.substring(1),
        location: node.location, // inherit location from main element
      },
      val: theValue,
      literal: 'boolean',
      location: node.location, // inherit location from main element
    };
  }
}

// Add an annotation with absolute name 'absoluteName' (including '@') and enum value 'theValue' to 'node'
function addEnumAnnotationTo(absoluteName, theValue, node) {
  // Sanity check
  if (!absoluteName.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + absoluteName);
  }
  if(isAnnotationAssignable(node, absoluteName)) {
    // Assemble the annotation
    node[absoluteName] = {
      name: {
        absolute: absoluteName.substring(1),
        location: node.location, // inherit location from main element
      },
      symbol: { id: theValue },
      literal: 'enum',
      location: node.location, // inherit location from main element
    };
  }
}
// Add an annotation with absolute name 'absoluteName' (including '@') and path ref 'theValue' to 'node'
function addRefAnnotationTo(absoluteName, theValue, node) {
  // Sanity check
  if (!absoluteName.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + absoluteName);
  }
  // Assemble the annotation
  if(isAnnotationAssignable(node, absoluteName)) {
        //member['@'+vlAnno] = { name: { path: vlAnno.split('.') }, path: [ { id: member.name.id } ] };

    node[absoluteName] = {
      name: {
        absolute: absoluteName.substring(1),
      },
      path: theValue
    };
  }
}

// Add an annotation with absolute name 'absoluteName' (including '@') and array 'theValue' to 'node'
function addArrayAnnotationTo(absoluteName, theValue, node) {
  // Sanity check
  if (!absoluteName.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + absoluteName);
  }
  // Assemble the annotation
  if(isAnnotationAssignable(node, absoluteName)) {
    node[absoluteName] = {
      name: {
        absolute: absoluteName.substring(1),
        location: node.location, // inherit location from main element
      },
      val: theValue,
      literal: 'array',
      location: node.location, // inherit location from main element
    };
  }
}

// Rename annotation 'fromName' in 'node' to 'toName' (both names including '@')
function renameAnnotation(node, fromName, toName) {
  let annotation = node && node[fromName];
  // Sanity checks
  if (!fromName.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + fromName);
  }
  if (!toName.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + toName);
  }
  if (annotation == undefined) {
    throw Error('Annotation ' + fromName + ' not found in ' + printableName(node));
  }
  if(isAnnotationAssignable(node, toName)) {
    // FIXME: We leave the path as it was here and only adapt the absolute name - does that make sense?
    annotation.name.absolute = toName.substring(1);
    delete node[fromName];
    node[toName] = annotation;
    // FIXME: Should we try to resolve the annotation (but currently it does not seem to have a _artifact ?)
  }
}

// Copy all annotations from 'fromNode' to 'toNode'. Overwrite existing ones only if 'overwrite' is true
function copyAnnotations(fromNode, toNode, overwrite=false) {
  // Ignore if no toNode (in case of errors)
  if (!toNode) {
    return;
  }
  for (let prop in fromNode) {
    if (prop.startsWith('@')) {
      if (toNode[prop] == undefined || overwrite) {
        toNode[prop] = fromNode[prop];
      }
    }
  }
}

// Return true if 'node' has a bool annotation 'name' with explicit value 'val'. If 'val' is omitted, it checks for
// the implicit value 'true'
function hasBoolAnnotation(node, name, val = true) {
  // Sanity check
  if (!name.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + name);
  }
  return node[name] && ( val === true ? node[name].val === undefined || node[name].val === true : node[name].val === val);
}

// For each property named 'path' in 'node' (recursively), call callback(path, node)
function foreachPath(node, callback) {
  if (node === null || typeof node !== 'object') {
    // Primitive node
    return;
  }
  for (let name in node) {
    // If path found within a non-dictionary, call callback
    if (name === 'path' && Object.getPrototypeOf(node)) {
      callback(node.path, node);
    }
    // Descend recursively
    foreachPath(node[name], callback);
  }
}

/**
 * Merge multiple 'options' objects (from right to left, i.e. rightmost wins). Structured option values are
 * merged deeply. Structured option value from the right may override corresponding bool options on the left,
 * but no other combination of struct/scalar values is allowed. Array options are not merged, i.e. their
 * content is treated like scalars.
 * Returns a new options object.
 *
 * @param {...CSN.Options} optionsObjects
 */
function mergeOptions(...optionsObjects) {
  let result = {};
  for (let options of optionsObjects) {
    result = mergeTwo(result, options, 'options');
  }
  return result;

  // Recursively used for scalars, too
  function mergeTwo(left, right, name) {
    let result;
    // Copy left as far as required
    if (isArray(left)) {
      // Shallow-copy left array
      result = left.slice();
    } else if (isObject(left)) {
      // Deep-copy left object (unless empty)
      result = Object.keys(left).length ? mergeTwo({}, left, name) : {};
    } else {
      // Just use left scalar
      result = left;
    }
    // Check against improper overwriting
    if (isObject(left) && !isArray(left) && (isArray(right) || isScalar(right))) {
      throw new Error(`Cannot overwrite structured option "${name}" with array or scalar value`);
    }
    if ((isScalar(left) && typeof left !== 'boolean' || isArray(left)) && isObject(right) && !isArray(right)) {
      throw new Error(`Cannot overwrite non-boolean scalar or array option "${name}" with structured value`);
    }

    // Copy or overwrite properties from right to left
    if (isArray(right)) {
      // Shallow-copy right array
      result = right.slice();
    } else if (isObject(right)) {
      // Object overwrites undefined, scalars and arrays
      if (result === undefined || isScalar(result) || isArray(result)) {
        result = {};
      }
      // Deep-copy right object into result
      for (let key of Object.keys(right)) {
        result[key] = mergeTwo(result[key], right[key], `${name}.${key}`);
      }
    } else {
      // Right scalar wins (unless undefined)
      result = (right !== undefined) ? right : result;
    }
    return result;
  }

  // Return true if 'o' is a non-null object or array
  function isObject(o) {
    return typeof o === 'object' && o !== null
  }

  // Return true if 'o' is a non-null array
  function isArray(o) {
    return isObject(o) && o instanceof Array;
  }

  // Return true if 'o' is a non-undefined scalar
  function isScalar(o) {
    return o !== undefined && !isObject(o);
  }
}

// Return the name of the top-level artifact surrounding the artifact 'name'
// in 'model'.
// We define "top-level artifact" to be an artifact that has either no parent or only
// ancestors of kind 'namespace'. Note that it is possible for a non-top-level artifact
// to have a namespace as parent and e.g. a context as grandparent (weird but true).
// Will return the artifact 'name' if it is a top-level artifact itself, and 'undefined'
// if there is no artifact surrounding 'name' in the model
// TODO: to be checked by author: still intended behaviour with 'cds' prefix?
function getTopLevelArtifactNameOf(name, model) {
  let dotIdx = name.indexOf('.');
  if (dotIdx == -1) {
    // No '.' in the name, i.e. no parent - this is a top-level artifact (if it exists)
    return model.definitions[name] ? name : undefined;
  }
  // If the first name part is not in the model, there is nothing to find
  if (!model.definitions[name.substring(0, dotIdx)]) {
    return undefined;
  }
  // Skip forward through '.'s until finding a non-namespace
  while (dotIdx != -1 && (!model.definitions[name.substring(0, dotIdx)] || model.definitions[name.substring(0, dotIdx)].kind === 'namespace')) {
    dotIdx = name.indexOf('.', dotIdx + 1);
  }
  if (dotIdx == -1) {
    // This is a top-level artifact
    return name;
  }
  // The skipped part of 'name' is the top-level artifact name
  return name.substring(0, dotIdx);
}

// Return the last part of 'name'.
// Examples:
//   'foo.bar.wiz' => 'wiz'
//   'foo' => 'foo';
//   'foo::bar' => 'bar'
function getLastPartOf(name) {
  return name.substring(name.search(/[^.:]+$/));
}

// Return the last part of reference array 'ref'
// Examples:
//   ['foo.bar', 'wiz'] => 'wiz'
//   ['foo.bar.wiz'] => 'wiz'
//   ['foo'] => 'foo';
//   ['foo::bar'] => 'bar'
function getLastPartOfRef(ref) {
  let lastPathStep = ref[ref.length - 1];
  return getLastPartOf(lastPathStep.id || lastPathStep);
}

// Return the name of the parent artifact of the artifact 'name' or
// '' if there is no parent.
function getParentNameOf(name) {
  return name.substring(0, name.lastIndexOf('.'));
}

// Return an array of parent names of 'name' (recursing into grand-parents)
// Examples:
//   'foo.bar.wiz' => [ 'foo.bar', 'foo' ]
//   'foo' => []
//   'foo::bar.wiz' => 'foo::bar'
//   'foo::bar' => []
function getParentNamesOf(name) {
  let remainder = name.slice(0, -getLastPartOf(name).length);
  if (remainder.endsWith('.')) {
    let parentName = remainder.slice(0, -1);
    return [parentName, ...getParentNamesOf(parentName)];
  } else {
    return [];
  }
}

// Return the resulting database name for (absolute) 'artifactName', depending on the current naming
// convention.
// - For the 'hdbcds' naming convention, this means converting '.' to '::' on
//   the border between namespace and top-level artifact.
// - For the 'plain' naming convention, it means converting all '.' to '_' and uppercasing.
// - For the 'quoted' naming convention, this is just 'artifactName'.
// No other naming conventions are accepted
function getArtifactDatabaseNameOf(artifactName, namingConvention, model) {
  if (namingConvention === 'hdbcds') {
    let topLevelName = getTopLevelArtifactNameOf(artifactName, model);
    let namespaceName = getParentNameOf(topLevelName);
    if (namespaceName) {
      return `${namespaceName}::${artifactName.substring(namespaceName.length + 1)}`;
    }
    return artifactName;
  }
  else if (namingConvention === 'plain') {
    return artifactName.replace(/\./g, '_').toUpperCase();
  }
  else if (namingConvention === 'quoted') {
    return artifactName;
  }
  else {
    throw new Error('Unknown naming convention: ' + namingConvention);
  }
}

// Return the resulting database element name for 'elemName', depending on the current naming
// convention.
// - For the 'hdbcds' naming convention, this is just 'elemName'.
// - For the 'plain' naming convention, it means converting all '.' to '_' and uppercasing.
// - For the 'quoted' naming convention, it means converting all '.' to '_'.
// No other naming conventions are accepted
function getElementDatabaseNameOf(elemName, namingConvention) {
  if (namingConvention === 'hdbcds') {
    return elemName;
  }
  else if (namingConvention === 'plain') {
    return elemName.replace(/\./g, '_').toUpperCase();
  }
  else if (namingConvention === 'quoted') {
    return elemName.replace(/\./g, '_');
  }
  else {
    throw new Error('Unknown naming convention: ' + namingConvention);
  }
}

module.exports = {
  isManagedAssociationElement,
  isAssocOrComposition,
  isAssociation,
  isComposition,
  isStructuredElement,
  isArrayElement,
  isAssociationElement,
  isScalarElement,
  isElementWithType,
  isArtifact,
  isContainerArtifact,
  hasArtifactTypeInformation,
  printableName,
  addStringAnnotationTo,
  addBoolAnnotationTo,
  addEnumAnnotationTo,
  addRefAnnotationTo,
  addArrayAnnotationTo,
  renameAnnotation,
  copyAnnotations,
  hasBoolAnnotation,
  foreachPath,
  mergeOptions,
  getTopLevelArtifactNameOf,
  getLastPartOf,
  getLastPartOfRef,
  getParentNameOf,
  getParentNamesOf,
  getArtifactDatabaseNameOf,
  getElementDatabaseNameOf,
};
