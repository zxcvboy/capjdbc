// Make internal properties of the XSN / augmented CSN visible
//
//  * Display links like _artifact as 'entity:"A"/element:"k"'.
//  * Use this form at other places to avoid listing the same property value twice.
//  * Use shorter display of the location, like in messages.
//  * Attach integer as __unique_id__ property value to all objects.
//
// This function should return a meaningful result in all circumstances:
//  * with --parse-only, with both CDL and CSN input,
//  * for the core compiler output and all transformations working on the XSN.

const msg = require('../base/messages');

function locationString( loc ) {
  return (typeof loc === 'object' && loc && loc.start)
    ? msg.locationString(loc)
    : (loc === null ? 'null' : typeof loc) + ':' + msg.locationString(loc);
}

function revealInternalProperties( model, name ) {
  var unique_id = 0;

  var transformers = {
    location: locationString,
    options: revealOptions,
    messages: reveal,
    artifacts: artifactDictionary,
    definitions: artifactDictionary,
    elements: (e,n) => (n.self ? artifactDictionary(e) : dictionary(e)),
    columns,
    actions: dictionary,
    params: dictionary,
    enum: dictionary,
    foreignKeys: dictionary,
    exclude: dictionary,
    struct: dictionary,
    queries: () => '<deprecated>',
    $queries: n => n.map( revealQuery ),
    $tableAliases: tableAliases,
    $navigation: dictionary,
    $keysNavigation: dictionary,
    $combined: artifactDictionary,
    $dictOrderBy: artifactDictionary,
    $layerNumber: n => n,
    $extra: e => e,
    _layerRepresentative: s => s.realname,
    _layerExtends: layerExtends,
    _parent: artifactIdentifier,
    _outer: artifactIdentifier,
    _main: artifactIdentifier,
    _block: artifactIdentifier,
    _artifact: artifactIdentifier,
    _navigation: artifactIdentifier,
    _origTarget: artifactIdentifier,
    _tableAlias: artifactIdentifier,
    _projections: artifactIdentifier, // array
    _redirected: artifactIdentifier, // array
    _entities: artifactIdentifier, // array
    _localized: artifactIdentifier,   // or true
    _assocSources: artifactIdentifier,   // array
    _oldAssocSources: artifactIdentifier,   // array
    $compositionTargets: d => d,   // dictionary( boolean )
    _upperAspects: artifactIdentifier, // array
    _ancestors: artifactIdentifier, // array
    _descendants: artifactDictionary, // dict of array
    _$queryNode: n => (n.location && { location: locationString( n.location ) }),
    _$next: artifactIdentifier,
    _finalType: artifactIdentifier,
    _leadingQuery: artifactIdentifier,
    _source: artifactIdentifier,
    _extend: (a) => reveal( a, null ),
    _annotate: (a) => reveal( a, null ),
    _deps: dependencyInfo,
    _xref: xrefInfo,
    _incomplete: primOrString,
    _shadowed: (a) => reveal( a, null ),
    _status: primOrString,       // is a string anyway
    _service: artifactIdentifier,
    _firstAliasInFrom: artifactIdentifier,
  }
  return reveal( parseXsnPath(name, model) );

  // Returns the desired artifact/dictionary in the XSN.
  //
  // Usage:
  //   1. Whole Model
  //      Simply pass `+`.
  //   2. Entity (e.g. in service)
  //      Use `S.E`, i.e. the artifact's name in XSN.
  //   3. Specific Element
  //      To get an element `e` of `S.E`, use `S.E/elements/e`, i.e. the
  //      JSON path delimited by "/" instead of "." (to avoid conflicts with artifact's FQN).
  //   4. All elements
  //      To list all elements, use `S.E/elements/`. The final slash is important.
  //   5. Other dictionaries or internal properties
  //      Use the JSON-like path delimited by "/". Add a final slash, e.g. `E.elements.a.kind/`.
  //
  // The string before the last slash ("/") is used as the property name to
  // reveal the properties. So if the last path segment is an element name, do
  // not add a slash or the name may be mistaken as a property name.
  //
  // Examples:
  //   `name.space/S/E/elements/a/kind/`
  //   `name.space/S/E/elements/a/type/scope/`
  function parseXsnPath(path, xsn) {
    if (!path || path === '+')
      return xsn;

    path = path.split('/');
    path.unshift('definitions');

    for (const segment of path) {
      if (xsn[segment])
        xsn = xsn[segment]
      else if (segment)
        throw new Error(`Raw Output: Path segment "${ segment }" could not be found. Path: ${ JSON.stringify(path) }!"`)
    }
    const propName = path[path.length > 1 ? path.length - 2 : 0 ];
    const obj = {};
    obj[propName] = xsn;
    return obj;
  }

  function artifactIdentifier( node, parent ) {
    if (node instanceof Array)
      return node.map( artifactIdentifier );
    if (!(node instanceof Object))
      return primOrString( node );
    if (node.__unique_id__ == null)
      Object.defineProperty( node, '__unique_id__', { value: ++unique_id } );
    let outer = '##' + node.__unique_id__;
    if (node._outer) {
      outer = (node._outer.items === node) ? '/items'
            : (node._outer.returns === node) ? '/returns' : '/returns/items';
      node = node._outer;
    }
    if (node === parent)
      return 'this';
    if (node.kind === 'source')
      return 'source:' + quoted( node.filename );
    if (node.kind === '$magicVariables')
      return '$magicVariables';
    if (!node.name) {
      try{
        return JSON.stringify(node);
      }
      catch (e) {
        return e.toString();
      }
    }
    switch (node.kind) {
      case undefined:             // TODO: remove this `returns` property for actions
        return (node._artifact && node._artifact.kind)
          ? artifactIdentifier( node._artifact )
          : JSON.stringify(node.name);
      case 'builtin':
        return '$magicVariables/' + msg.artName(node);
      case 'source':
      case 'using':
        return 'source:' + quoted( node.location && node.location.filename ) +
               '/using:' + quoted( node.name.id )
      default: {
        let kind = (node._main)
            ? node._main.kind
            : (node.kind === 'block')
            ? node._parent && node._parent.kind
            : node.kind;
        return (kind || '<kind>') + ':' + msg.artName( node ) + outer +
               // todo: get rid of $renamed / do the oData renaming late on the CSN
               (node.name.$renamed ? '-original:' + quoted( node.name.$renamed ) : '');
      }
    }
  }

  function quoted( name, undef = '<undefined>' ) {
    return (typeof name === 'number')
      ? name
      : name ? '"' + name.replace( /"/g, '""' ) + '"' : undef;
  }

  function artifactDictionary( node ) {
    if (node == null || typeof node !== 'object' || Object.getPrototypeOf(node)
        || !model.definitions || node === model.definitions )
      return dictionary( node );    // no dictionary or no definitions section
    let dict = Object.create(null);
    for (let name in node) {
      dict[name] = artifactIdentifier( node[name] );
    }
    return dict;
  }

  function dependencyInfo( deps ) {
    if (!(deps instanceof Array))
      return primOrString( deps );
    return deps
      .filter( d => d.location )
      .map( d => artifactIdentifier( d.art ) );
  }

  function xrefInfo( xref ) {
    return xref.map( d => artifactIdentifier( d.user ) );
  }

  function layerExtends( dict ) {
    let r = Object.create(null);
    // let proto = Object.getPrototypeOf(dict);
    // if (proto)
    //   r.__proto__ = proto.realname || proto;
    for (let name in dict)
      r[name] = true;
    return r;
  }

  function primOrString( node ) {
    if (node === null || typeof node !== 'object')
      // node instanceof Object would be false for dict
      return node
    if (node instanceof Array)
      return node.map( primOrString );
    if (node instanceof Object)
      return '' + node;
    else
      return '<dict>';
  }

  function columns( nodes ) {
    // If we will have specified elements, we need another test to see columns in --parse-cdl
    return nodes && nodes.map( c => (c._parent && c._parent.elements) ? artifactIdentifier( c ) : reveal( c ) );
  }

  function dictionary( node ) {
    return reveal( node, '__proto__' );
  }

  function tableAliases( dict, query ) {
    return query.join ? artifactDictionary( dict ) : dictionary( dict );
  }

  function revealQuery( node ) {
    return reveal( node, undefined, undefined, '__neverEqualKind' );
  }

  function revealOptions( node ) {
    return reveal( node.messages
                   ? Object.assign( {}, node, { messages: node.messages.length } )
                   : node );
  }

  function reveal( node, protoProp, _array, identifierKind = 'query' ) {
    // warning: 'protoProp' bound via map()
    if (node == null || typeof node !== 'object' )
      // node instanceof Object would be false for dict
      return node
    if (node instanceof Array)
      return node.map( reveal );

    let proto = Object.getPrototypeOf(node);
    if (proto !== null && proto !== Object.prototype)
      return node;
    if (proto && node.kind === identifierKind && !node.join)
      return artifactIdentifier( node );

    let r = Object.create( proto );
    // property to recognize === objects
    if (proto && node.kind && node.__unique_id__ == null)
      Object.defineProperty( node, '__unique_id__', { value: ++unique_id } );

    for (let prop of Object.getOwnPropertyNames( node )) { // also non-enumerable
      let item = node[prop];
      let func =
          (proto === null || protoProp === null ? reveal : transformers[prop]) ||
          (Object.prototype.propertyIsEnumerable.call( node, prop ) ? reveal : primOrString);
      r[prop] = func( item, node );
    }
    if (proto && protoProp === '__proto__')
      Object.defineProperty( r, protoProp, { enumerable: true, value: '' + proto } );
    return r;
  }
}

module.exports = revealInternalProperties;
