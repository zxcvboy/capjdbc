// CSN functionality for resolving references

// The functions in this module expect a well-formed CSN with valid references.
// If that is not the case, it simply throws an error (which might even be a
// plain TypeError) without any claim for the error message to be
// user-friendly.  CSN processors can provide user-friendly error messages by
// calling the Core Compiler in that case.  For details, see
// internalDoc/CoreCompiler.md#use-of-the-core-compiler-for-csn-processors.

// For details about the name resolution in CSN, see
// internalDoc/CsnSyntax.md#helper-property-for-simplified-name-resolution
// and doc/NameResolution.md.

// Terminology used in this file:
//
// - ref (reference): a { ref: <path> } object (or sometimes also a string)
//   referring an artifact or member
// - path: an array of strings or { id: â€¦ } objects for the dot-connected names
//   used as reference
// - csnPath: an array of strings and numbers (e.g. ['definitions', 'S.E',
//   'query', 'SELECT', 'from', 'ref', 0]); they are the property names and
//   array indexes which navigate from the CSN root to the current node.

'use strict'

const BUILTIN_TYPE = {};

// Properties in which artifact or members are defined - next property in the
// "csnPath" is the name or index of that property; 'args' (its value can be a
// dictionary) is handled extra here.
const artifactProperties
      = ['elements', 'columns', 'keys', 'mixin', 'enum', 'params', 'actions', 'payload', 'definitions', 'extensions'];

function csnRefs( csn ) {
  const views = Object.create(null); // cache for views - OK to add it to CSN?
  let refCsnPath = [];
  let refLinks = null;
  return { effectiveType, artifactRef, inspectRef, queryOrMain };

  // Return the type relevant for name resolution, i.e. the object which has a
  // `target`, `elements`, `enum` property, or no `type` property.  To avoid
  // confusion with the "base type", we do not use the term "final type".
  // (This function could be omitted if we would use JS prototypes for type refs.)
  function effectiveType( art ) {
    if (art._effectiveType)
      return art._effectiveType;
    else if (!art.type || art.elements || art.target || art.targetAspect || art.enum)
      return art;

    const chain = [];
    while (art._effectiveType == null && art.type &&
           !art.elements && !art.target && !art.targetAspect && !art.enum) {
      chain.push( art );
      setLink( art, '_effectiveType', 0 ); // initial setting in case of cycles
      art = artifactRef( art.type, BUILTIN_TYPE );
    }
    if (art._effectiveType === 0)
      throw new Error( 'Circular type reference');
    const type = art._effectiveType || art;
    chain.forEach( a => setLink( a, '_effectiveType', type ) );
    return type;
  }

  function navigationEnv( art ) {
    let type = effectiveType( art );
    // here, we do not care whether it is semantically ok to navigate into sub
    // elements of array items (that is the task of the core compiler /
    // semantic check)
    while (type.items)
      type = type.items;
    // cannot navigate along targetAspect!
    return (type.target) ? csn.definitions[ type.target ] : type;
  }

  // Return the object pointing to by the artifact reference (in 'type',
  // 'includes', 'target', raw 'from').
  function artifactRef( ref, notFound ) {
    if (typeof ref === 'string') {
      const art = csn.definitions[ ref ] || notFound;
      if (art !== undefined)
        return art;
    }
    else {
      const [head, ...tail] = ref.ref;
      let art = csn.definitions[ pathId( head ) ];
      for (const elem of tail) {
        art = navigationEnv( art ).elements[ pathId( elem ) ];
      }
      if (art)
        return art;
      else if (!tail.length && notFound !== undefined)
        return notFound;
    }
    throw new Error( 'Undefined reference ');
  }

  // Return the entity we select from
  function fromRef( ref ) {
    const path = ref.ref;
    const name = (path.length === 1)
          ? pathId( path[0] )
          : effectiveType( artifactRef( ref ) ).target;
    return csn.definitions[ name ];
  }

  function whereEntity( csnPath, refCsnPathIndex ) {
    if (refCsnPath.length !== refCsnPathIndex ||
        refCsnPath.some( ( prop, idx ) => prop !== csnPath[idx] )) {
      // safety: ref-where in ref-where -> first store in locals
      const path = csnPath.slice( 0, refCsnPathIndex );
      const links = inspectRef( path ).links;
      refCsnPath = path;
      refLinks = links;
    }
    return refLinks[ csnPath[ refCsnPathIndex + 1 ] ].env;
  }

  function inspectRef( csnPath ) {
    const { obj, parent, query, scope, refCsnPathIndex } = analyseCsnPath( csnPath, csn );
    const name = csnPath[1];
    const main = csn.definitions[ name ];
    const queries = views[ name ] || main.query && allQueries( name, main );

    const path = (typeof obj === 'string') ? [ obj ] : obj.ref;
    if (!Array.isArray( path ))
      throw new Error( 'Value references must look like {ref:[...]}' );
    const head = pathId( path[0] );

    // 1,2: with 'param' or 'global' property, in `keys`
    if (obj.param)
      return expandRefPath( path, main.params[ head ], 'param' );
    else if (obj.global || ['type', 'includes', 'target', 'from'].includes( scope ))
      return expandRefPath( path, csn.definitions[ head ], scope );
    else if (scope === 'keys') {
      const target = csn.definitions[ parent.target || parent.cast.target ];
      return expandRefPath( path, target.elements[ head ], 'keys' );
    }
    // 3: $magic
    if (head.charAt(0) === '$') {
      if (head === '$self' || head === '$projection') {
        let self = query ? queryOrMain( query, main ) : main;
        return expandRefPath( path, self, '$self' );
      }
      else {
        return { scope: '$magic' };
      }
    }
    // 4: where inside ref
    if (scope === 'ref-where') {
      const { elements } = whereEntity( csnPath, refCsnPathIndex );
      return expandRefPath( path, elements[ head ], scope );
    }
    // 5,6,7: outside queries, in queries where inferred elements are referred to
    if (!query)
      return expandRefPath( path, (parent || main).elements[ head ] );
    const select = query.SELECT;
    if (!select || obj.$env === true)
      // TODO: do not do this if current query has a parent query (except with obj.$env)
      return expandRefPath( path, queryOrMain( query, main ).elements[ head ] );

    // With explicitly provided $env:
    if (typeof obj.$env === 'number') { // head is mixin or table alias name
      const s = (obj.$env) ? queries[ obj.$env - 1 ].SELECT : select;
      const m = s.mixin && s.mixin[ head ];
      return expandRefPath( path, m || s._sources[ head ], (m ? 'mixin' : 'alias') );
    }
    else if (typeof obj.$env === 'string') {
      const source = select._sources[ obj.$env ];
      return expandRefPath( path, source.elements[ head ], 'source' );
    }

    // 8: try to search in MIXIN section (not in ON of JOINs)
    if (scope !== 'from-on' && select.mixin) {
      const art = select.mixin[ head ];
      if (art)
        return expandRefPath( path, art, 'mixin' );
    }
    // 9: try to search for table aliases (partially in ON of JOINs)
    if (path.length > 1 && (select.$alias || scope !== 'from-on')) {
      const art = select._sources[ head ];
      if (art)
        return expandRefPath( path, art, 'alias' );
    }
    // 10: search in elements of source entity
    // TODO: do not do this if current query has a parent query !!!
    if (scope === 'on' || scope === 'orderBy') {
      return expandRefPath( path, queryOrMain( query, main ).elements[ head ] );
    }
    if (typeof select.$alias === 'string') { // with unique source
      const source = select._sources[ select.$alias ];
      return expandRefPath( path, source.elements[ head ], 'source' );
    }
    throw new Error( 'Missing helper property $env: ' + scope );
  }

  function expandRefPath( path, art, scope = null ) {
    const links = path.map( (_v, idx) => ({ idx }) );
    links[0].art = art;
    for (let i = 1; i < links.length; ++i) { // yes, starting at 1
      art = navigationEnv( art );
      links[ i - 1 ].env = art;
      art = art.elements[ pathId( path[i] ) ];
      links[ i ].art = art;
    }
    if (scope === 'from') {
      art = navigationEnv( art );
      links[ links.length - 1 ].env = art;
    }
    return { links, art, scope };
  }

  function allQueries( name, main ) {
    const all = [];
    traverseQuery( main.query, null, function memorize( query, select ) {
      if (query.ref) {          // ref in from
        const as = query.as || implicitAs( query.ref );
        select._sources[ as ] = fromRef( query );
        select.$alias = (select.$alias != null) ? typeof select.$alias === 'string' : as;
      }
      else if (select && query.as) { // sub query in FROM
        const as = query.as;
        select._sources[ as ] = queryOrMain( query, main );
        setLink( select, '$alias',
                 (select.$alias != null) ? typeof select.$alias === 'string' : as );
      }
      if (query.SELECT) {       // every SELECT query -- TODO: remember number?
        setLink( query.SELECT, '_sources', Object.create(null) );
        setLink( query.SELECT, '$alias', null );
        all.push( query );
      }
    } );
    views[name] = all;
    return all;
  }
}

function queryOrMain( query, main ) {
  while (query.SET)
    query = query.SET.args[0];
  if (query.elements)
    return query;
  let leading = main.query;
  while (leading.SET)
    leading = leading.SET.args[0];
  const elements = leading === query && main.elements;
  if (elements)
    return main;
  throw new Error( 'Query elements not available: ' + Object.keys( query ).join('+'));
}

function traverseQuery( query, select, callback ) {
  if (query.SELECT) {
    callback( query, select );
    query = query.SELECT;
    traverseFrom( query.from, query, callback );
  }
  else if (query.SET) {
    callback( query, select );
    query = query.SET;
  }
  for (const prop of ['args', 'xpr', 'columns', 'where', 'having']) {
    // all properties which could have sub queries (directly or indirectly)
    const expr = query[prop];
    if (expr && typeof expr === 'object') {
      const args = Array.isArray( expr ) ? expr : Object.values( expr );
      args.forEach( q => traverseQuery( q, null, callback ) );
    }
  }
}

function traverseFrom( from, select, callback ) {
  if (from.ref)
    callback( from, select );
  else if (from.args) {         // join
    from.args.forEach( arg => traverseFrom( arg, select, callback ) );
    if (from.on)           // join
      from.on.forEach( arg => traverseQuery( arg, select, callback ) );
  }
  else
    traverseQuery( from, select, callback ); // sub query in FROM
}

function setLink( obj, prop, value ) {
  Object.defineProperty( obj, prop, { value, configurable: true, writable: true } );
}

function pathId( item ) {
  return (typeof item === 'string') ? item : item.id;
}

function implicitAs( ref ) {
  const id = pathId( ref[ ref.length - 1 ] );
  return id.substring( id.lastIndexOf('.') + 1 );
}

function analyseCsnPath( csnPath, obj ) {
  if (csnPath[0] !== 'definitions')
    throw new Error( 'References outside definitions not supported yet');
  let parent = null;
  let query = null;
  let scope = null;
  let art = null;
  let isName = false;
  let refCsnPathIndex = 0;

  csnPath.forEach( function loop( prop, index ) {
    if (isName || Array.isArray( obj )) { // array item, name/index of artifact/member, (named) argument
      if (typeof isName === 'string') {
        parent = art;
        art = obj[ prop ];
      }
      isName = false;
    }
    else if (artifactProperties.includes( prop )) {
      isName = prop;
      scope = prop;
    }
    else if (prop === 'items' || prop === 'returns') {
      art = obj[ prop ];
    }
    else if (prop === 'args') {
      isName = true;            // for named arguments
      if (scope === 'orderBy')
        scope = 'orderBy-xpr';  // no need to extra 'orderBy-args'
    }
    else if (prop === 'SELECT' || prop === 'SET') {
      query = obj;
      scope = prop;
    }
    else if (prop === 'where' && scope === 'ref') {
      scope = 'ref-where';
      refCsnPathIndex = index - 2;
    }
    else if (prop === 'on') {
      if (scope === 'from')
        scope = 'from-on';
      else if (scope === 'mixin')
        scope = 'mixin-on';
      else
        scope = 'on';
    }
    else if (prop !== 'xpr') {
      scope = prop;
    }
    else if (scope === 'orderBy') {
      scope = 'orderBy-xpr';
    }
    obj = obj[ prop ];
  } );
  // console.log( 'CPATH:', csnPath, scope, obj, parent.$location );
  return { obj, parent, query, scope, refCsnPathIndex };
}

csnRefs.traverseQuery = traverseQuery;
csnRefs.artifactProperties = artifactProperties;
csnRefs.implicitAs = implicitAs;
module.exports = csnRefs;

