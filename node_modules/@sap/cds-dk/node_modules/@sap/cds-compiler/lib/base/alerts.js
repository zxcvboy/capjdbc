// Implementation of alerts
//
// An alert is a message of a certain severity (Error, Warning, Info). The alerts are implemented
// by tagged template literals, e.g. error`File not found` is an alert of severity 'Error',
// warning`Cannot read ${file}` an alert of severity 'Warning'.
// The severity of every message may be changed in a global JSON document, which has each message as a key
// and defines additional properties (e.g. localized texts for different languages). One such property is
// the severity. If the message is in the document and has a severity, it supersedes the original severity.
// In order to remove a severity (so that further stages processing the alert can completely ignore it)
// severity must be set to null.
// Alerts must be handled by function signal(), which inserts it into 'model.messages' together with a location,
// if provided.
// Hint: To collect tagged template literals that correspond to known alerts in the sources, use scripts/extractAlerts.js

'use strict';

const messageBuilder = require('./message-builder');

/**
 * Return an object with functions for alert handling on 'model'
 * {
 *   info                               // tag function for INFO messages
 *   warning                            // tag function for WARN messages
 *   error                              // tag function for ERROR messages
 *   signal(taggedString, loc)          // signal an info, error, or warning message 'taggedString' at location 'loc'
 * }
 * For obtaining these functions, 'alerts(model)' should be called once, linking the reporting to 'model.messages'.
 * Alerts should be signalled with an invocation like this, to ensure that error texts can be translated:
 *   signal(error`Example error ${foo}`, location);
 *
 * @param {XSN.Model|CSN.Model} model
 * @param {CSN.Options} [options]
 */
function alerts(model, options = model.options || {}) {
  // If 'model' does not have a 'messages' array yet (may happen for plain CSNs), create one
  let collected = options.messages || model.messages ||
                  Object.defineProperty( model, 'messages',
                                         { value: [], configurable: true, writable: true } )
                    .messages;

  signal.error = error;
  signal.warning = warning;
  signal.info = info;

  let config = options.severities || {};

  return {
    info, warning, error,               // tag functions for the different alerts
    signal                              // add the alert to the message list and react depending on severity
  };

  function info(msgParts, ...values) {
    return createAlert('Info', msgParts, values);
  }

  function warning(msgParts, ...values) {
    return createAlert('Warning', msgParts, values);
  }

  function error(msgParts, ...values) {
    return createAlert('Error', msgParts, values);
  }

  // Mother of all alerts. Check if the message is in the global JSON document, take (translated) text and possibly
  // new severity from there. Substitute parameters by corresponding values. If neither translation is provided
  // nor the alert is known at all, just take the key as the message.
  function createAlert(severity, msgParts, values) {
    let key = '';
    msgParts.forEach((part, i) => {
      key += part;
      if (i < values.length)
        key += `{${i}}`;
    })
    /**
     * Replace the parameters by the corresponding values
     * @type {object} Not a primitive string but a String wrapper object.
     */
    let result = new String(key.replace(/{(\d)}/g, (_, index) => values[Number(index)]));
    result._severity = severity;
    return result;
  }

  /**
   * Link an alert to a location (if provided). If no explicit severity is given, the severity is taken
   * from the 'msg' itself (if provided). The alert is added to the list of alerts. If the alert is an
   * exception, the corresponding error is thrown.
   *
   * @param {any}      msg            Message text
   * @param {XSN.Location|CSN.Location|any[]} [location] Location information (possibly semantic location)
   * @param {string}  [severity] severity: Info, Warning, Error
   * @param {string}  [message_id=''] Message ID
   * @returns {Boolean} true, if no 'Error' alert was handled.
   */
  function signal(msg, location, severity, message_id='') {
    const err = messageBuilder(model, msg, location, message_id in config ? config[message_id] : severity, message_id, options.internalMsg);
    if (err.severity)
      // don't collect stuff that doesn't have a severity
      collected.push(err);
    switch (err.severity) {
      case 'Exception':
        throw err;
      case 'Error':
        return false;
      default:
        return true;
    }
  }
}

module.exports = alerts;
