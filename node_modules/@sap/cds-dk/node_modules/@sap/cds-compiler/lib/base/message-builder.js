const { CompileMessage, DebugCompileMessage } = require('../base/messages');

/**
 * @param {XSN.Model | CSN.Model} model
 * @param {any}       msg
 * @param {XSN.Location|CSN.Location|CSN.Path} location
 * @param {string}    severity
 * @param {string}    message_id
 * @param {boolean}   useDebugMsg
 */
function buildMessage(model, msg, location, severity, message_id, useDebugMsg){
  let semanticLocation = undefined;
  if(Array.isArray(location)){
    semanticLocation = location;
    validateSemanticLocation(semanticLocation);
    location = searchForLocation(semanticLocation);
  }
  severity =  severity || msg._severity;
  return (useDebugMsg)
    ? new DebugCompileMessage(location, msg, severity, message_id, beautifySemanticLocation(semanticLocation))
    : new CompileMessage(location, msg, severity, message_id, beautifySemanticLocation(semanticLocation));

  /** @param {CSN.Path} semanticLocation */
  function searchForLocation(semanticLocation){
    let last_location = null; // Don't display a location if we cannot find one!
    /** @type {object} */
    let currentThing = model;
    for(const step of semanticLocation){
      if(!currentThing){
        return last_location;
      }
      currentThing = currentThing[step];

      if(currentThing && currentThing.$location){
        last_location = currentThing.$location;
      }
    }

    return last_location;
  }

  /** @param {CSN.Path} semanticLocation */
  function validateSemanticLocation(semanticLocation){

    if (semanticLocation.length === 0){
      throw new Error('An empty semantic location was supplied, this should not happen!');
    }

    if (semanticLocation[0] !== 'definitions'){
      throw new Error('Semantic locations must start with "definitions", found: ' + semanticLocation[0]);
    }

    if (semanticLocation.length === 1){
      throw new Error('Semantic locations must at least point to an artifact!');
    }

    return true;
  }

  /** @param {CSN.Path} semanticLocation */
  function beautifySemanticLocation(semanticLocation){
    if(!semanticLocation){
      return semanticLocation;
    }
    const copy = [...semanticLocation];

    const art = model.definitions[copy[1]];

    copy[1] = ((art && art.kind) ? art.kind : 'artifact') + ':' + quoted(copy[1])

    return copy.slice(1).join('/');
  }
}

function quoted( name ) {
  return (name) ? '"' + name.replace( /"/g, '""' ) + '"' : '<?>'; // sync ";
}


module.exports = buildMessage;

