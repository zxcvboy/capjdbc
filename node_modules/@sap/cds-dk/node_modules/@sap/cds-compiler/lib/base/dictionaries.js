// Functions for dictionaries (Objects without prototype)

'use strict';

// Add entry `entry` with key `name` to the dictionary `dict`.  If an entry
// (called `found`) with the same name is already defined, call
// `messagerCallback` with arguments `name` and `loc` assigned to
// `entry.name.location`.  If this is the first duplicate entry and if the
// `filename`s are different, call the callback again on `found.name.location`.
function addToDict( dict, name, entry, messageCallback ) {
  var found = dict[name];
  if (!found || found.builtin) { // do not replace a builtin definition
    // XSN TODO: store duplicate definitions in prop $duplicates, do not use array (except $combined?)
    dict[name] = entry;         // also ok if array (redefined)
    return entry;
  }
  if (entry instanceof Array) {
    if (found instanceof Array) {
      dict[name] = [ ...found, ...entry ];
    }
    else {
      dict[name] = [ found, ...entry ];
      // Redefinitions from second source -> also complain in first source
      if (messageCallback && name)
        messageCallback( name, found.name.location, found );
      if (messageCallback !== null)
        found.$duplicate = true;
    }
  }
  else {
    if (found instanceof Array) {
      dict[name] = [ ...found, entry ];
    }
    else {
      dict[name] = [ found, entry ];
      // Definitions from second source -> also complain for definition in first source
      // TODO: with packages, we could also use the package hierarchy
      if (messageCallback && name)
        messageCallback( name, found.name.location, found );
      if (messageCallback !== null)
        found.$duplicate = true;
    }
    if (messageCallback && name)
      messageCallback( name, entry.name.location, entry );
    if (messageCallback !== null)
      entry.$duplicate = true;
  }
  return entry;
}

// TODO: either use dict[lengthSymbol] to store length or just use (after perf
// test) Object.keys(dict).length
// var lengthSymbol = typeof Symbol !== 'undefined' && Symbol.for && Symbol.for('dictLength')
const orderedDictionaries = {
  elements: '_elementsIndexNo',
  foreignKeys: '_foreignKeysIndexNo',
  params: '_paramsIndexNo'
};

function addToDictWithIndexNo( parent, env, name, entry, messageCallback ) {
  addToDict( parent[env], name, entry, messageCallback );
  let ordered = orderedDictionaries[env];
  if (!ordered)
    return;
  if (!(ordered in parent))
    Object.defineProperty( parent, ordered, { value: 0, configurable: true, writable: true } );
  entry.indexNo = ++parent[ordered];
}

function clearDict( parent, env, inPlace ) {
  if (!inPlace || !parent[env])
    parent[env] = Object.create(null);
  else {
    let dict = parent[env];
    let keys = Object.keys( dict );
    for (let k of keys)
      delete dict[k];
  }
  let ordered = orderedDictionaries[env];
  if (ordered)
    delete parent[ordered];
  return ordered;
}

// Push `entry` to the array value with key `name` in the dictionary `dict`.
function pushToDict( dict, name, entry ) {
  if (dict[name])
    dict[name].push(entry);
  else
    dict[name] = [entry];
}

function forEachInDict( dict, callback ) {
  let r = Object.create(null);
  for (let name of Object.keys(dict))
    r[name] = callback( dict[name], name, dict );
  return r;
}

module.exports = {
  addToDict,
  addToDictWithIndexNo,
  clearDict,
  pushToDict,
  forEachInDict,
}

