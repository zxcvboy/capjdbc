// Functions and classes for syntax messages

'use strict';

const term = require('../utils/term');
const { normalizeLocation } = require('./location');
const fs = require('fs');
const path = require('path');

// For messageIds, where no severity has been provided via code (central def)
const standardSeverities = {
  'syntax-anno-after-struct': ['Error'],
  'syntax-anno-after-enum': ['Error'],
  'syntax-anno-after-params': ['Error'],
  'ref-undefined-def': 'Error',
  'ref-undefined-art': 'Error',
  'ref-rejected-on': ['Error'], // TODO: 'Error'
  'anno-undefined-def': 'Info', // for annotate statement (for CSN or CDL path cont)
  'anno-undefined-art': 'Info', // for annotate statement (for CDL path root)
  'anno-undefined-element': 'Info',
  'anno-undefined-action': 'Info',
  'anno-undefined-param': 'Info',
}

// For messageIds, where no text has been provided via code (central def)
const standardTexts = {
  'syntax-csn-expected-object': 'Expected object for property $(PROP)',
  'syntax-csn-expected-column': 'Expected object or string \'*\' for property $(PROP)',
  'syntax-csn-expected-natnum': 'Expected non-negative number for property $(PROP)',
  'syntax-csn-expected-cardinality': 'Expected non-negative number or string \'*\' for property $(PROP)',
  'syntax-csn-expected-reference': 'Expected non-empty string or object for property $(PROP)',
  'syntax-csn-expected-term': 'Expected non-empty string or object for property $(PROP)',
  'syntax-anno-after-struct': 'Avoid annotation assignments after structure definitions',
  'syntax-anno-after-enum': 'Avoid annotation assignments after enum definitions',
  'syntax-anno-after-params': 'Avoid annotation assignments after parameters',
  'ref-undefined-def': {
    std: 'Artifact $(ART) has not been found',
    element: 'Artifact $(ART) has no element $(MEMBER)'
  },
  'ref-undefined-art': 'No artifact has been found with name $(NAME)',
  'ref-undefined-element': {
    std: 'Element $(ART) has not been found',
    element: 'Artifact $(ART) has no element $(MEMBER)'
  },
  'ref-rejected-on': {
    mixin: 'Do not refer to a mixin like $(ID) in the explicit ON of a redirection',
    alias: 'Do not refer to a source element (via table alias $(ID)) in the explicit ON of a redirection',
  },
  'anno-undefined-def': 'Artifact $(ART) has not been found',
  'anno-undefined-art': 'No artifact has been found with name $(NAME)',
  'anno-undefined-element': {
    std: 'Element $(ART) has not been found',
    element: 'Artifact $(ART) has no element $(MEMBER)',
    enum: 'Artifact $(ART) has no enum $(MEMBER)'
  },
  'anno-undefined-action': {
    std: 'Action $(ART) has not been found',
    action: 'Artifact $(ART) has no action $(MEMBER)'
  },
  'anno-undefined-param': {
    std: 'Parameter $(ART) has not been found',
    param: 'Artifact $(ART) has no parameter $(MEMBER)'
  },
  'expected-const': 'A constant value is expected here',
  'expected-struct': 'An aspect or a non-query entity without parameters is expected here',
  'expected-context': 'A context or service is expected here',
  'expected-type': 'A type or an element of a type is expected here',
  'expected-entity': 'A non-abstract entity, projection or view is expected here',
  'expected-source': 'A query source must be a non-abstract entity or an association to an entity',
}

const availableMessageExplanations = {
  'check-proper-type': true,
  'check-proper-type-of': true,
  'redirected-to-ambiguous': true,
  'redirected-to-unrelated': true,
};

/**
 * Returns true if at least one of the given messages is of severity "Error"
 * @param {CSN.Message[]} messages
 */
function hasErrors( messages ) {
  return messages && messages.some( m => m.severity === 'Error' );
}

/**
 * Return gnu-style error string for location `loc`:
 *  - 'File:Line:Col' without `loc.end`
 *  - 'File:Line:StartCol-EndCol' if Line = start.line = end.line
 *  - 'File:StartLine.StartCol-EndLine.EndCol' otherwise
 *
 * @param {CSN.Location|XSN.Location} location
 * @param {boolean} [normalizeFilename]
 */
function locationString( location, normalizeFilename ) {
  if (!location)
    return '<???>';
  const loc = normalizeLocation( location );
  let filename = (loc.filename && normalizeFilename)
      ? loc.filename.replace( /\\/g, '/' )
      : loc.filename;
  if (!(loc instanceof Object) || !loc.start)
    return loc;
  if (!loc.start || !loc.start.line) {
    return filename;
  }
  else if (!loc.end || loc.$weak) {
    return (loc.start.column)
      ? `${filename}:${loc.start.line}:${loc.start.column}`
      : `${filename}:${loc.start.line}`;
  }
  else {
    return (loc.start.line === loc.end.line)
      ? `${filename}:${loc.start.line}:${loc.start.column}-${loc.end.column}`
      : `${filename}:${loc.start.line}.${loc.start.column}-${loc.end.line}.${loc.end.column}`;
  }
}

/**
 * Class for combined compiler errors.  Additional members:
 *   `errors`: vector of errors (CompileMessage and errors from peg.js)
 *   `model`: the CSN model
 * TODO: standard param order
 * @class CompilationError
 * @extends {Error}
 */
class CompilationError extends Error {
  /**
   * Creates an instance of CompilationError.
   * @param {array} messages vector of errors (CompileMessage and errors from peg.js)
   * @param {object} [model] the CSN model
   * @param {string} [text] Text of the error
   * @param {any} args Any args to pass to the super constructor
   *
   * @memberOf CompilationError
   */
  constructor(messages, model, text, ...args) {
    super( text || 'CDS compilation failed\n' + messages.map( m => m.toString() ).join('\n'),
          // @ts-ignore Error does not take more arguments according to TypeScript...
           ...args );
    this.errors = messages;     // TODO: remove
    // this.messages = messages;   // use this instead

    /** @type {object} model */
    this.model;
    /** @type {boolean} model */
    this.hasBeenReported = false; // TODO: remove this bin/cdsc.js specifics
    // TODO: remove property `model`
    Object.defineProperty( this, 'model', { value: model, configurable: true } );
  }
  toString() {                  // does not really help -> set message
    return this.message.includes('\n')
      ? this.message
      : this.message + '\n' + this.errors.map( m => m.toString() ).join('\n');
  }
}

/**
 * Class for individual compile message.
 *
 * @class CompileMessage
 * @extends {Error}
 */
class CompileMessage {
  /**
   * Creates an instance of CompileMessage.
   * @param {any} location Location of the message
   * @param {string} msg The message text
   * @param {string} [severity='Error'] Severity: Debug, Info, Warning, Error
   * @param {string} [id] The ID of the message - visible as property messageId
   * @param {any} [home]
   *
   * @memberOf CompileMessage
   */
  constructor(location, msg, severity = 'Error', id = null, home = null) {
    this.message = msg;
    this.location = normalizeLocation( location );
    if (home)                   // semantic location, e.g. 'entity:"E"/element:"x"'
      this.home   = home;
    this.severity = severity;
    if (id)
      Object.defineProperty( this, 'messageId', { value: id } );
      // this.messageId = id;  // ids not yet finalized
  }
  toString() {                  // should have no argument...
    return messageString( this, undefined, true ); // no message-id before finalization!
  }
}
/**
 * Class for individual compile message.
 *
 * @class CompileMessage
 * @extends {Error}
 */
class DebugCompileMessage extends Error {
  /**
   * Creates an instance of DebugCompileMessage, used with option `internalMsg`
   * @param {any} location Location of the message
   * @param {string} msg The message text
   * @param {string} [severity='Error'] Severity: Debug, Info, Warning, Error
   * @param {string} [id] The ID of the message - visible as property messageId
   * @param {any} [home]
   *
   * @memberOf CompileMessage
   */
  constructor(location, msg, severity = 'Error', id = null, home = null) {
    super(msg);
    this.location = normalizeLocation( location );
    if (home)                   // semantic location, e.g. 'entity:"E"/element:"x"'
      this.home   = home;
    this.severity = severity;
    if (id)
      Object.defineProperty( this, 'messageId', { value: id } );
      // this.messageId = id;  // ids not yet finalized
  }
  toString() {                  // should have no argument...
    return messageString( this, undefined, true ); // no message-id before finalization!
  }
}

/**
 * Handle compiler messages, i.e. throw a compiler exception if there are
 * errors, otherwise sort the messages (see compareMessage()).
 *
 * @param {object} model
 * @param {CSN.Options} [options]
 */
function handleMessages( model, options = model.options || {} ) {
  let messages = options.messages || model.messages;
  if (messages && messages.length) {
    messages.sort( compareMessage );
    if (hasErrors( messages ))
      throw new CompilationError( messages, model );
  }
  return model;
}

const severitySpecs = {
  error: { name: 'Error', level: 0 },
  warning: { name: 'Warning', level: 1 },
  info: { name: 'Info', level: 2 },
  debug: { name: 'Debug', level: 3 }
}

function normalizedSeverity( severity ) {
  if (typeof severity !== 'string')
    return (severity === null) ? 'Debug' : 'Error';
  let s = severitySpecs[ severity.toLowerCase() ];
  return s && s.name || 'Error';
}

// Return message function to issue errors, warnings, info and debug messages.
// Messages are put into the `messages` property of argument `options` or `model`.
// If those do not exist, define a non-enumerable property `messages` in `model`.
function getMessageFunction( model, options = model.options || {}, transform ) {
  let messages = options.messages || model.messages ||
                 Object.defineProperty( model, 'messages',
                                        { value: [], configurable: true, writable: true } )
                   .messages;
  let config = options.severities || {};

  return function message( id, location, home, params = {}, severity = undefined, texts = undefined ) {
    if (!severity)              // TODO: check that they are always eq per messageId
      severity = standardSeverities[id];
    let s = normalizedSeverity( severity );
    if ((s !== 'Error' || severity instanceof Array) && id && id in config )
      s = normalizedSeverity( config[id] );
    let text = (typeof params === 'string')
        ? params
        : messageText( texts || standardTexts[id], params, transform );
    home = (typeof home === 'string') ? home : homeName(home);
    let msg = (options.internalMsg)
        ? new DebugCompileMessage( location, text, s, id, home )
        : new CompileMessage( location, text, s, id, home );
    messages.push( msg );
    return msg;
  }
}

const paramsTransform = {
  alias: quoted,
  anno: transformAnno,
  art: transformArg,
  target: transformArg,
  type: transformArg,
  token: t => t.match( /^[a-zA-Z]+$/ ) ? t.toUpperCase() : "'" + t + "'",
  code: n => '`' + n + '`',
  newcode: n => '`' + n + '`',
  name: quoted,
  names: transformManyWith( quoted ),
  id: quoted,
  prop: n => "'" + n + "'",
  otherprop: n => "'" + n + "'",
  kind: n => '"' + n + '"',
  delimited: n => '![' + n + ']',
  // msg: m => m,
  file: s => "'" + s.replace( /'/g, "''" ) + "'", // sync ;
};

function transformAnno( anno ) {
  return (anno.charAt(0) === '@') ? quoted( anno ) : quoted( '@' + anno );
  // if (anno.charAt(0) === '@')
  //   anno = anno.slice(1);
  // return (!anno || /[^A-Za-z_0-9.]/.test(anno)) ? msgName( '@' + anno ) : '@' + anno;
}

function transformArg( arg, r, args, texts ) {
  if (!arg || typeof arg !== 'object')
    return quoted( arg );
  if (args['#'] || args.member )
    return artName( arg );
  if (arg._artifact)
    arg = arg._artifact;
  if (arg._outer)
    arg = arg._outer;
  let name = arg.name;
  if (!name)
    return quoted( name );
  let prop = ['element','param','action','alias'].find( p => name[p] );
  if (!prop || !texts[prop] )
    return artName( arg );
  r['#'] = texts[ name.$variant ] && name.$variant || prop; // text variant (set by searchName)
  r.member = quoted( name[prop] );
  return artName( arg, prop );
}

function transformManyWith( t ) {
  return function transformMany( many, r, args, texts ) {
    let prop = ['none','one'][ many.length ];
    if (!prop || !texts[prop] || args['#'] )
      return many.map(t).join(', ');
    r['#'] = prop;              // text variant
    return many.length && t( many[0] );
  };
}

const nameProp = {
  enum: 'element',
  key: 'element',
  function: 'action',
};

function searchName( art, id, variant ) {
  if (!variant) {
    let type = art._finalType && art._finalType.kind !== 'undefined' ? art._finalType : art;
    art = type.target && type.target._artifact || type;
    variant = ['context','service','namespace'].includes(art.kind) ? 'absolute' : 'element';
  }
  let prop = nameProp[variant] || variant;
  let name = Object.assign( { $variant: variant }, (art._artifact||art).name );
  name[prop] = (name[prop]) ? name[prop] + '.' + id : id || '?';
  return { name, kind: art.kind };
}

function messageText( texts, params, transform ) {
  if (typeof texts === 'string')
    texts = { std: texts };
  let args = {};
  for (let p in params) {
    let t = transform && transform[p] || paramsTransform[p];
    args[p] = (t) ? t( params[p], args, params, texts ) : params[p];
  }
  let variant = args['#'];
  return replaceInString( variant && texts[ variant ] || texts.std, args );
}

function replaceInString( text, params ) {
  let pattern = /\$\(([A-Z_]+)\)/g;
  let parts = [];
  let start = 0;
  for (let p = pattern.exec( text ); p; p = pattern.exec( text )) {
    let prop = p[1].toLowerCase();
    parts.push( text.substring( start, p.index ),
                (prop in params ? params[prop] : p[0]) );
    delete params[prop];
    start = pattern.lastIndex;
  }
  parts.push( text.substring( start ) );
  let remain = ('#' in params) ? [] : Object.keys( params ).filter( n => params[n] );
  return (remain.length)
         ? parts.join('') + '; ' +
           remain.map( n => n.toUpperCase() + ' = ' + params[n] ).join(', ')
         : parts.join('');
}

/** @param {XSN.Location} loc */
function weakLocation( loc ) {
  // use return { ...location, $weak: true } if that is JS standard
  return { filename: loc.filename, start: loc.start, end: loc.end, $weak: true };
}

/**
 * Return message string with location if present in compact form (i.e. one line)
 *
 * Example:
 *   <source>.cds:3:11: Error: cannot find value `nu` in this scope *
 *
 * @param {CSN.Message} err
 * @param {boolean} [normalizeFilename]
 * @param {boolean} [noMessageId]
 * @param {boolean} [noHome]
 * @returns {string}
 */
function messageString( err, normalizeFilename, noMessageId, noHome ) {
  return (err.location ? locationString( err.location, normalizeFilename ) + ': ' : '') +
         (err.severity||'Error') +
         (err.messageId && !noMessageId ? ' ' + err.messageId + ': ' : ': ') +
         err.message +
         (!err.home || noHome && err.location && !err.location.$weak ? '' : ' (in ' + err.home + ')');
}

/**
 * Return message string with location if present.
 *
 * Example:
 *   Error: cannot find value `nu` in this scope
 *   <source>.cds:3:11
 *
 * @param {CSN.Message} err
 * @param {boolean} [normalizeFilename]
 * @param {boolean} [noMessageId]
 * @param {boolean} [noHome]
 * @returns {string}
 */
function messageStringMultiline( err, normalizeFilename, noMessageId, noHome ) {
  const explainHelp = hasMessageExplanation(err.messageId) ? '…' : '';
  const msgId = (err.messageId && !noMessageId) ? `[${ err.messageId }${ explainHelp }]` : '';
  const home = (!err.home || (noHome && err.location && !err.location.$weak) ? '' : ' (in ' + err.home + ')');
  const severity = err.severity || 'Error';
  const location = (err.location ?  '\n--> ' + locationString( err.location, normalizeFilename ) : '');

  return term.asSeverity(severity, severity + msgId)  + ': ' + err.message + home + location;
}

/**
 * Returns a context (code) string that is human readable (similar to rust's compiler)
 *
 * Example Output:
 *     |
 *   3 |     num * nu
 *     |           ^^
 *
 * @param {string[]} sourceLines The source code split up into lines, e.g. by `splitLines(src)`
 *                               from `lib/utils/file.js`
 * @param {CSN.Message} err Error object containing all details like line, message, etc.
 * @returns {string}
 */
function messageContext(sourceLines, err) {
  const loc = normalizeLocation(err.location);
  if (!loc || !loc.start) {
    return '';
  }

  // Lines are 1-based, we need 0-based ones for arrays
  const startLine = loc.start.line - 1;
  const endLine = loc.end ? loc.end.line - 1 : startLine;

  // check that source lines exists
  if (typeof sourceLines[startLine] !== 'string' || typeof sourceLines[endLine] !== 'string') {
    return '';
  }

  const digits = String(endLine + 1).length;
  const severity = err.severity || 'Error';
  const indent = ' '.repeat(2 + digits);
  // end column points to the place *after* the last character index,
  // e.g. for single character locations it is "start + 1"
  let endColumn = loc.end ? loc.end.column - 1 : loc.start.column;
  /** Only print N lines even if the error spans more lines. */
  const maxLine = Math.min((startLine + 2), endLine);

  let msg = indent + '|\n';

  // print source line(s)
  for (let line = startLine; line <= maxLine; line++) {
    // Replaces tabs with 1 space
    let sourceCode = sourceLines[line].replace(/\t/g, ' ');
    // Only prepend space if the line contains any sources.
    sourceCode = sourceCode.length ? ' ' + sourceCode : '';
    msg +=  ' ' + String(line + 1).padStart(digits, ' ') + ' |' + sourceCode + '\n';
  }

  if (startLine === endLine) {
    // highlight only for one-line location; at least one character is highlighted
    const highlighter = ' '.repeat(Math.max(0, loc.start.column - 1))
              .padEnd(Math.max(loc.start.column, endColumn), '^');
    msg += indent + '| ' + term.asSeverity(severity, highlighter);
  } else if (maxLine !== endLine) {
    // error spans more lines which we don't print
    msg +=  indent + '| ...';
  } else {
    msg +=  indent + '|';
  }

  return msg;
}

/**
 * Compare two messages `a` and `b`. Return 0 if they are equal, 1 if `a` is
 * larger than `b`, and -1 if `a` is smaller than `b`. Messages without a location
 * are considered larger than messages with a location.
 *
 * @param {CSN.Message} a
 * @param {CSN.Message} b
 */
function compareMessage( a, b ) {
  if (a.location && b.location) {
    let aend = !a.location.$weak && a.location.end || { line: Number.MAX_SAFE_INTEGER, column: 0 };
    let bend = !b.location.$weak && b.location.end || { line: Number.MAX_SAFE_INTEGER, column: 0 };
    return ( c( a.location.filename, b.location.filename ) ||
             c( a.location.start.line, b.location.start.line ) ||
             c( a.location.start.column, b.location.start.column ) ||
             c( aend.line, bend.line ) ||
             c( aend.column, bend.column ) ||
             c( a.message, b.message ) );
  }
  else if (!a.location === !b.location)
    return c( a.message, b.message )
  else
    return (!a.location) ? 1 : -1;

  function c( x, y ) {
    return (x === y) ? 0 : (x > y) ? 1 : -1;
  }
}

/**
 * Removes duplicate messages from the given messages array without destroying
 * references to the array.
 *
 * @param {CSN.Message[]} messages
 */
function deduplicateMessages( messages ) {
  const seen = new Set();
  const uniqueMessages = messages.filter((msg) => {
    if (!msg.location)
      return true;
    const hash = messageString(msg);
    const keep = !seen.has(hash);
    seen.add(hash);
    return keep;
  });

  messages.length = 0;
  for (const msg of uniqueMessages) {
    messages.push(msg);
  }
}

function artName( art, omit ) {
  let name = art.name;
  let r = (name.absolute) ? [ quoted( name.absolute ) ] : [];
  if (name.query || name.query != null && art.kind !== 'element' || name.$mixin ) // Yes, omit $query.0 for element - TODO: rename to block
    r.push( (art.kind === 'block' ? 'block:' : 'query:') + (name.query + 1) );
  if (name.action && omit !== 'action')
    r.push( memberActionName(art) + ':' + quoted( name.action ) );
  if (name.param && omit !== 'param') // TODO: also use for alias/mixin
    r.push( 'param:' + quoted( name.param ) );
  else if (name.alias)          // TODO: use 'param'
    r.push( (name.$mixin ? 'mixin:' : 'alias:') + quoted( name.alias ) )
  if (name.element && omit !== 'element')
    // r.push( `${ art.kind }: ${ quoted( name.element )}` ); or even better element:"assoc"/key:"i" same with enum
    r.push( (art.kind === 'enum' ? 'enum:' : 'element:') + quoted( name.element ) );
  return r.join('/');
}

function memberActionName( art ) {
  while (art && art._main) {
    if (art.kind === 'action' || art.kind === 'function')
      return art.kind;
    art = art._parent;
  }
  return 'action';
}

function homeName( art ) {
  if (!art)
    return art;
  if (art._outer)               // in returns / items property
    return homeName( art._outer );
  else if (art.kind === 'source' || !art.name) // error reported in parser or on source level
    return null;
  else if (art.kind === 'using')
    return 'using:' + quoted( art.name.id );
  else if (art.name._artifact)             // block, extend, annotate
    return homeName( art.name._artifact ); // use corresponding definition
  else
    return (art._main ? art._main.kind : art.kind) + ':' + artName( art );
}

function quoted( name ) {
  return (name) ? '"' + name.replace( /"/g, '""' ) + '"' : '<?>'; // sync ";
}

/**
* The function converts the path-locations of the messages to file-locations.
* It navigates the provided xsn to find the path and consume the corresponding file-location found there.
*/
function translatePathLocations(messages,xsn) {
  messages.forEach(msg => { // for all messages
    let location = msg.location;
    if(!(location instanceof Array))
      return; // not a path-location
    let element = xsn;
    location.forEach(name => { // deep dive
      if(element === undefined)
        return; // do not translate invalid paths
      element=element[name];
    });
    if(element && element.location)
      msg.location = element.location; // replace path-location with -file-location
    else
      delete msg.location; // delete invalid array locations as message handling doesn't support them
  });
}

/**
 * Get the explanation string for the given message-id.
 *
 * @param {string} messageId
 * @returns {string}
 * @throws May throw an ENOENT error if the file cannot be found.
 * @see hasMessageExplanation()
 */
function explainMessage(messageId) {
  const filename = path.join(__dirname, '..', '..', 'share', 'messages', `${messageId}.md`);
  return fs.readFileSync(filename, 'utf8');
}

/**
 * Returns true if the given message has an explanation file.
 *
 * @param {string} messageId
 * @returns {boolean}
 */
function hasMessageExplanation(messageId) {
  return !!availableMessageExplanations[messageId];
}

/**
 * Returns an array of message IDs that have an explanation text.
 */
function messageIdsWithExplanation() {
  return Object.keys(availableMessageExplanations);
}

module.exports = {
  hasErrors,
  weakLocation,
  locationString,
  messageString,
  messageStringMultiline,
  messageContext,
  searchName,
  getMessageFunction,
  artName,
  handleMessages,
  sortMessages: (m => m.sort(compareMessage)),
  deduplicateMessages,
  CompileMessage,
  DebugCompileMessage,
  CompilationError,
  translatePathLocations,
  explainMessage,
  hasMessageExplanation,
  messageIdsWithExplanation,
}

