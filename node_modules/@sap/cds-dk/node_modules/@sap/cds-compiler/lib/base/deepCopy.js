// Deep copy an object structure
// This makes a deep copy of the transitive closure of an object. It works on any objects and properties,
// enumerable or not. Be careful with functions that contain state, since there will be no clone of the
// internal state of a function.
// An example is the alert property of a model. It may be instantiated with an array of alert messages
// kept in the model itself, so after cloning the model you will have two alert message arrays, but alert still
// points to the alert messages in the original model. You have to reinstantiate alert in the clone to refer
// to the cloned messages.
// In order not to forget such functions that would still alter the original model it's advised to freeze the
// original model (see deepFreeze)

function deepCopy(obj) {
  let map = new WeakMap();
  let copyStack = [];
  let result = copy(obj);

  while (copyStack.length) {
    let entry = copyStack.pop();
    let {src, target, prop} = entry;
    // copy element
    let newObj = copy(src[prop]);

    // store reference to copy in target property
    let desc = (src && typeof src === 'object') ? Object.getOwnPropertyDescriptor(src, prop) : null;
    if (desc && desc.enumerable === false && desc.get === undefined && desc.set === undefined) {
      desc.value = newObj;
      if (!(prop in target))    // shudder, also used for arrays
        Object.defineProperty(target, prop, desc);
    } else {
      target[prop] = newObj;
    }
  }
  return result;

  function copy(obj) {
    let newObj;
    if (typeof obj !== 'object' || obj === null) // return primitive type, note that typeof null === 'object'
      return obj;
    if (map.has(obj))
      return map.get(obj);
    if (Array.isArray(obj))
      newObj = [];
    else if (obj.constructor) // important for classes, else prototype chain for inheritance will not be correct
      newObj = new obj.constructor()
    else if (!Object.getPrototypeOf(obj))
      newObj = Object.create(null);  // dictionary
    else
      newObj = {};
    map.set(obj, newObj);
    // loop over all properties and add them to copyStack
    // in reverse order to keep same order in copied object
    let propertiesToPush = [];
    for (let propName of Object.getOwnPropertyNames(obj)) { // we clone only own properties, not inherited one's
      if (propName === 'location' && Object.getPrototypeOf(obj)) {
        // performance optimization: only link location instead of copying the object
        newObj.location = obj.location;
      } else {
        propertiesToPush.push({ src: obj, prop: propName, target: newObj });
      }
    }
    copyStack.push(...propertiesToPush.reverse());
    return newObj;
  }
}

module.exports = deepCopy;
