//

'use strict';

const queryOps = {
  query: 'select',                // TODO: rename to SELECT
  union: 'union',
  unionAll: 'union',
  intersect: 'union',
  except: 'union',
  subquery: 'union',            // for (subquery) with ORDER BY or LIMIT/OFFSET
}

/**
 * Test for early-adaptor feature, stored in option `beta`(new-style) / `betaMode`(old-style)
 * With that, the value of `beta` is a dictionary of feature=>Boolean.
 *
 * A feature always needs to be provided - otherwise false will be returned.
 *
 * Please do not move this function to the "option processor" code.
 *
 * @param {object} options Options
 * @param {string} feature Feature to check for
 * @returns {boolean}
 */
function isBetaEnabled( options, feature ) {
  const beta = options.beta || options.betaMode;
  return beta && typeof beta === 'object' && feature && beta[feature];
}

// Apply function `callback` to all artifacts in dictionary
// `model.definitions`.  See function `forEachGeneric` for details.
function forEachDefinition( model, callback ) {
  forEachGeneric( model, 'definitions', callback );
}

// Apply function `callback` to all members of object `obj` (main artifact or
// parent member).  Members are considered those in dictionaries `elements`,
// `enum`, `actions` and `params` of `obj`, `elements` and `enums` are also
// searched inside property `items` (array of).  See function `forEachGeneric`
// for details.
function forEachMember( construct, callback, target ) {
  let obj = construct.returns || construct; // why the extra `returns` for actions?
  obj = obj.items || obj;
  forEachGeneric( target || obj, 'elements', callback );
  forEachGeneric( obj, 'enum', callback );
  forEachGeneric( obj, 'foreignKeys', callback );
  forEachGeneric( construct, 'actions', callback );
  forEachGeneric( construct, 'params', callback );
}

// Apply function `callback(member, memberName, prop)` to each member in
// `construct`, recursively (i.e. also for sub-elements of elements).
function forEachMemberRecursively( construct, callback ) {
  forEachMember( construct, ( member, memberName, prop ) => {
    callback( member, memberName, prop );
    // Descend into nested members, too
    forEachMemberRecursively( member, callback );
  });
  // If 'construct' has more than one query, descend into the elements of the remaining ones, too
  if (construct.$queries && construct.$queries.length > 1) {
    construct.$queries.slice(1).forEach(query => forEachMemberRecursively(query, callback));
  }
}

/**
 * Apply function `callback` to all members of object `obj` (main artifact or
 * parent member).  Members are considered those in dictionaries `elements`,
 * `enum`, `actions` and `params` of `obj`, `elements` and `enums` are also
 * searched inside property `items` (array of).  `$queries`, `mixin` and
 * `columns` are also visited in contrast to `forEachMember()`.
 * See function `forEachGeneric()` for details.
 *
 * @param {XSN.Artifact} construct
 * @param {(member: object, memberName: string, prop: string) => any} callback
 * @param {object} [target]
 */
function forEachMemberWithQuery( construct, callback, target ) {
  let obj = construct.returns || construct; // why the extra `returns` for actions?
  obj = obj.items || obj;
  forEachGeneric( target || obj, 'elements', callback );
  forEachGeneric( obj, 'enum', callback );
  forEachGeneric( obj, 'foreignKeys', callback );
  forEachGeneric( construct, 'actions', callback );
  forEachGeneric( construct, 'params', callback );
  // For Queries
  forEachGeneric( construct, '$queries', callback );
  forEachGeneric( construct, 'mixin', callback );
  forEachGeneric( construct, 'columns', callback );
}

/**
 * Apply function `callback(member, memberName, prop)` to each member in
 * `construct`, recursively (i.e. also for sub-elements of elements).
 * In contrast to `forEachMemberRecursively()` this function also traverses
 * queries and mixins.
 *
 * @param {XSN.Artifact} construct
 * @param {(member: object, memberName: string, prop: string) => any} callback
 */
function forEachMemberRecursivelyWithQuery( construct, callback ) {
  forEachMemberWithQuery( construct, ( member, memberName, prop ) => {
    callback( member, memberName, prop );
    // Descend into nested members, too
    forEachMemberRecursivelyWithQuery( member, callback );
  });
}

// Apply function `callback` to all objects in dictionary `dict`, including all
// duplicates (found under the same name).  Function `callback` is called with
// the following arguments: the object, the name, and -if it is a duplicate-
// the array index and the array containing all duplicates.
function forEachGeneric( obj, prop, callback ) {
  let dict = obj[prop];
  for (let name in dict) {
    let obj = dict[name];
    if (obj instanceof Array) // redefinitions
      obj.forEach( (o, i, a) => callback( o, name, prop, i, a ) )
    else
      callback( obj, name, prop );
  }
}

const forEachInOrder = forEachGeneric;

// Call function `callback` with arguments `target` and `source` where `source`
// is calculated by `sourceRef(target)._artifact`, make sure that `callback`
// had been called with `source` as `target` before, and so on.  To do so, we
// set property `_status` of the objects involved to value `status`.
function applyLinearly( status, target, sourceRef, callback ) {
  if (!target)
    return;
  let chain = [];
  let obj;
  while ((obj = sourceRef(target)) && obj._status !== status && obj._artifact) {
    setProp( obj, '_status', status );
    chain.push( target );
    target = obj._artifact;
  }
  let source = target;
  for (target of chain.reverse()) {
    callback( target, source );
    source = target;
  }
}

// Like `obj.prop = value`, but not contained in JSON / CSN
// It's important to set enumerable explicitly to false (although 'false' is the default),
// as else, if the property already exists, it keeps the old setting for enumerable.
function setProp (obj, prop, value) {
  let descriptor = { value, configurable: true, writable: true, enumerable: false };
  Object.defineProperty( obj, prop, descriptor );
}

// Clone 'node', transforming nodes therein recursively. Object 'transformers' is expected
// to contain a mapping of property 'key' names to transformer functions. The node's properties
// are walked recursively, calling each transformer function on its corresponding property
// 'key' of 'node', replacing 'value' in 'resultNode' with the function's return value
// (returning 'undefined' will delete the property).
// If no transformation function is found for 'key', the first letter of 'key' is tried
// instead (this seems to be intended for handling annotations that start with '@' ?)
// FIXME: Do we really need this ?
// If `withArtifactLink` is set, the `_artifact` links of `node` are copied too (not cloned,
// of course).
// Regardless of their names, transformers are never applied to dictionary elements.
//
// The transformer functions are called with the following signature:
//   transformer(value, node, resultNode, key)
function cloneWithTransformations(node, transformers, withArtifactLink) {

  return transformNode(node);

  // This general transformation function will be applied to each node recursively
  function transformNode(node) {
    // Return primitive values and null unchanged, but let objects and dictionaries through
    // (Note that 'node instanceof Object' would be false for dictionaries).
    if (node === null || typeof node !== 'object') {
      return node
    }
    // Simply return if node is to be ignored
    if (node._ignore)
      return undefined;
    // Transform arrays element-wise
    if (node instanceof Array) {
      return node.map(transformNode);
    }
    // Things not having 'proto' are dictionaries
    const proto = Object.getPrototypeOf(node);
    // Iterate own properties of 'node' and transform them into 'resultNode'
    const resultNode = Object.create(proto);
    for (let key of Object.keys(node)) {
      // Dictionary always use transformNode(), other objects their transformer according to key
      const transformer = !proto ? transformNode : transformers[key] || transformers[key.charAt(0)];
      // Apply transformer, or use transformNode() if there is none
      const resultValue = (transformer || transformNode)(node[key], node, resultNode, key);
      if (resultValue !== undefined) {
        resultNode[key] = resultValue;
      }
    }
    // For non-dictionaries, take over `_artifact` if requested
    if (withArtifactLink && proto) {
      let pd = Object.getOwnPropertyDescriptor(node, '_artifact')
      if (pd)
        Object.defineProperty(resultNode, '_artifact', pd);
    }
    return resultNode;
  }
}


module.exports = {
  isBetaEnabled,
  queryOps,
  forEachDefinition,
  forEachMember,
  forEachMemberRecursively,
  forEachMemberWithQuery,
  forEachMemberRecursivelyWithQuery,
  forEachGeneric,
  forEachInOrder,
  applyLinearly,
  setProp,
  cloneWithTransformations,
};
