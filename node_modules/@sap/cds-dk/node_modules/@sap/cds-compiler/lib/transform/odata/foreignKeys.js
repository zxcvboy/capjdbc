'use strict';

/**
 * The module handles the processing of foreign key for managed associations.
 */

const { copyAnnotations } = require('../../model/modelUtils');
const { dfilter } = require('../udict');

function generateForeignKeys(transformers, sortedAssociations) {
  sortedAssociations.forEach(item => {
    const { definitionName, elementName, element, parent, path } = item;
    for (let keyIndex in element.keys) {
      let key = element.keys[keyIndex];
      let keyPath = path.concat('keys', keyIndex);
      let foreignKeyElement = transformers.createForeignKeyElement(element, elementName, key, parent, definitionName, keyPath);
      transformers.toFinalBaseType(foreignKeyElement);
      copyAnnotations(element, foreignKeyElement, true);
    }
  });
}

// For an array `keys` of foreign key infos, return an array in flattened form
// in one of the two cases:
// (1) replace all foreign keys that are managed associations themselves by
// their respective foreign keys, recursively, with names flattened using
// pathDelimiter between path components.
// (2) replace all foreign keys that are structured with their respective flattened form.
//
// Note: must be done after struct flattening(flattenStructuredElement method),
// otherwise we might encounter already generated foreign key fields in types
// we have already processed.
function flattenForeignKeys(assoc, csnUtils, referenceFlattener) {

  let fkSeparator = '_';

  let targetArt = csnUtils.getCsnDef(assoc.target);

  // get all the elements from the target that have 'key' identifier
  let targetKeys = dfilter(targetArt.elements, elem => elem.key === true);
  // in case we have explicitly defined FKs
  Object.assign(targetKeys, dfilter(targetArt.elements, (elem, elemName) => {
    if (elem._flatElementNameWithDots) {
      // this is flattened elem -> keys still not flattened, have to check if starts with key ref
      // FIXME: review why join('.')? what about join(fkSeparator)?
      return assoc.keys.map(key => key.ref.join('.')).some(keyDotName => elemName.startsWith(`${keyDotName}${fkSeparator}`));
    } else {
      // exact match of the name
      return assoc.keys.map(key => key.ref.join('.')).some(keyDotName => keyDotName === elemName);
    }
  }));

  let result = [];

  // this iteration assumes the elements in the tartgetArtifact are flattened
  for (let key of assoc.keys) {

    let fKeyName = key.ref.join(fkSeparator);

    // The key is an association - (1)
    if (Object.keys(targetKeys).includes(fKeyName) && targetKeys[fKeyName].type
      && targetKeys[fKeyName].type === 'cds.Association' && targetKeys[fKeyName].target
    ) {
      // as there is no assurance that the target of the target has flattened keys already
      // has to go through both of the associations
      csnUtils.getCsnDef(targetKeys[fKeyName].target); // sanity check if the definition exists
      targetKeys[fKeyName].keys.forEach(k => result.push({ ref: [`${fKeyName}${fkSeparator}${k.ref.join(fkSeparator)}`] }));
      continue;
    }

    let generatedElements = null;
    if(referenceFlattener) {
      // collect potential flattened keys, which are the counterpart of the current key
      let paths=key.$paths;
      if(paths) {
        generatedElements = referenceFlattener.getGeneratedElementsForPath(paths[paths.length-1]);
      }
    }

    let flattenedKeys = generatedElements || [];
    // The keys is structured element
    if (flattenedKeys.length) {
      flattenedKeys.forEach(k => result.push({ ref: [k], as: k }));
    } else {
      // Otherwise simply take as it is
      result.push(key);
    }
  }

  // If the managed association is NOT NULL, we give it a target min cardinality of 1
  // if it didn't already have an explicitly specified min cardinality.
  // (No need to check again for min <= max cardinality, because max has already been checked to be > 0)
  if (assoc.notNull) {
    if (!assoc.cardinality) {
      assoc.cardinality = {};
    }
    if (assoc.cardinality.min === undefined) {
      assoc.cardinality.min = 1;
    }
  }

  assoc.keys = result;
}

/*
function flattenForeignKeysWithRefFlattener(assoc, path, structuredOData, referenceFlattener) {
  for (let keyIndex of assoc.keys) {
    let key = assoc.keys[keyIndex];
    let keyPath = path.concat('keys', keyIndex);
    if (!structuredOData) { // flatten the reference using RESOLVED references
      let resolvedIsStructured = referenceFlattener.isStructured(keyPath)
      if (resolvedIsStructured) {
        let ref = key.ref;
        let newref = []; // new flattened reference
        let previousElementIsStructured = false;
        ref.forEach((iref, i) => {
          if (previousElementIsStructured == undefined) return; // missing information - skip processing
          if (previousElementIsStructured) {
            newref[newref.length - 1] = newref[newref.length - 1] + '_' + iref; // prevous element is sructured - concat last with current
          } else {
            newref.push(iref); // prevous element is not structured - do not flatten, just push it
          }
          previousElementIsStructured = resolvedIsStructured[i]; // detect structured elements
        })
        if (key.ref.length > newref.length) { // anything flattened?
          key.ref = newref;
        }
      }
    }
  }


  // If the managed association is NOT NULL, we give it a target min cardinality of 1
  // if it didn't already have an explicitly specified min cardinality.
  // (No need to check again for min <= max cardinality, because max has already been checked to be > 0)
  if (assoc.notNull) {
    if (!assoc.cardinality) {
      assoc.cardinality = {};
    }
    if (assoc.cardinality.min === undefined) {
      assoc.cardinality.min = 1;
    }
  }
}
*/

module.exports = { generateForeignKeys, flattenForeignKeys };
