/**
 * During the OData transfromations in flat-mode, all structured elements will be flattened.
 * This module performs the complete flattening.
 * It also provides information to the reference flattener: elements produced for specific path in the CSN structure.
 * Each generated element gets hidden attributes:
 *  - $viaTransform - states that the element was generated during transformation
 *  - _flatElementNameWithDots - names in the element path concatenated with dot
 * @param {*} csn CSN-object to flatten
 * @param {*} functions instances of utility functions
 */

function flattenCSN(csn, functions) {
  const { forEachDefinition } = functions;
  forEachDefinition(csn, (def, _defName, _propertyName, path) => {
    flattenDefinition(def, path, functions);
  })
}

/**
 * Flattens one single definition and all structures in it
 * @param {*} definition definition object to flatten
 * @param {*} path path in CSN object
 * @param {*} functions utility functions
 */
function flattenDefinition(definition, path, functions) {
  const { csnUtils, cloneCsn, error, signal, setProp, copyAnnotations } = functions;
  if (definition.kind !== 'entity' && definition.kind !== 'view')
    return;

  let referenceFlattener = functions.referenceFlattener;

  // these functions are used for propagation of the annotations, collected along the path during flattening
  const { addAnnotationsForPropagationFromElement, propagateAnnotationsToElement, resetAnnotationsForRropagation } = function () {
    let toBePropagatedAnnotations = Object.create(null);
    return {
      addAnnotationsForPropagationFromElement: function (element) {
        copyAnnotations(element, toBePropagatedAnnotations);
      },
      propagateAnnotationsToElement: function (element) {
        copyAnnotations(toBePropagatedAnnotations, element);
      },
      resetAnnotationsForRropagation: function () {
        toBePropagatedAnnotations = Object.create(null);
      }
    }
  }();

  let newElements = {}; // TODO copy $path $paths
  flattenStructure(definition, path);
  definition.elements = newElements;

  // adds newly created element into the final dictionary of elements
  function addNewElement(element, elementName, elementNameWithDots, path, key, topLevel, propagateAnnotations) {
    if (newElements[elementName]) {
      signal(error`Generated element ${elementName} conflicts with other generated element`, path);
    } else {
      let newElement = createNewElement(element, key, elementNameWithDots, topLevel, propagateAnnotations);
      newElements[elementName] = newElement;
    }
  } // addNewElement

  // creates new element by copying the properties of the originating element
  function createNewElement(element, isKey, elementNameWithDots, topLevel, propagateAnnotations) {

    let newElement = cloneCsn(element);
    if (propagateAnnotations) propagateAnnotationsToElement(newElement);

    if (isKey)
      newElement.key = true;
    if (!topLevel) {
      setProp(newElement, '$viaTransform', true);
      setProp(newElement, '_flatElementNameWithDots', elementNameWithDots);
    }
    return newElement;
  } // createNewElement

  /**
   * Flattenes structured element by calling element flattener for each structured child.
   * @param {*} struct the structure to flatten
   * @param {*} path the path of the structure in the CSN tree
   * @param {*} isDefinition states if this is a top level element
   * @param {*} elementPathInStructure list of parent element names
   * @param {*} isKey true if this or the parent element is a key - will be propagated to all child elements
   */
  function flattenStructure(struct, path, isDefinition = true, elementPathInStructure = [], isKey = false, propagateAnnotations = false) {
    isDefinition ? resetAnnotationsForRropagation() : addAnnotationsForPropagationFromElement(struct);

    let resultingElementNames = []; // holds the names of all child elements of the structure
    for (let elementName in struct.elements) {
      let ikey = isKey; // parent element is key
      let element = struct.elements[elementName];
      if (element.key) ikey = true; // current element is key
      let ipath = path.concat('elements', elementName);
      // flat elements when structured   and NOT empty (allow incomplete structures - cds-compiler#4337)
      if (csnUtils.isStructured(element) && !(element.elements && Object.keys(element.elements).length === 0)) {
        let namesOfCreatedElements = flattenStructuredElement(element, elementPathInStructure.concat(elementName), ipath, ikey);
        resultingElementNames = resultingElementNames.concat(namesOfCreatedElements); // accomulate names of produced elements
      } else { // when we do not need to flat, this is scalar or empty (cds-compiler#4337) -> needs to be registered in referenceFlattener
        let newElementName = elementPathInStructure.concat(elementName).join('_');
        let elementNameWithDots = elementPathInStructure.concat(elementName).join('.');
        addNewElement(element, newElementName, elementNameWithDots, ipath, ikey, isDefinition, propagateAnnotations);
        resultingElementNames.push(newElementName);
      }
    }
    if (referenceFlattener) {
      referenceFlattener.registerGeneratedElementsForPath(path, resultingElementNames);
    }
    return resultingElementNames;
  } // flattenStructure

  // flattenes on single structured element by calling the structure flattener for it
  function flattenStructuredElement(element, elementPathInStructure, path, key) {
    if (referenceFlattener)
      referenceFlattener.registerFlattenedElement(path, element.$path);

    let elemType;
    if (!element.elements) { // structures do not have final base type
      elemType = csnUtils.getFinalBaseType(element.type);
      addAnnotationsForPropagationFromElement(element);
    }

    const struct = elemType ? elemType : element;

    //TODO what happens with 'path' if element has base type?
    return flattenStructure(struct, path, false, elementPathInStructure, key || element.key, true);
  } // flattenStructuredElement

} // flattenDefinition

module.exports = flattenCSN;
