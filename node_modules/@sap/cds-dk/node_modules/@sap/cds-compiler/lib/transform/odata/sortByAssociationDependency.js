'use strict';

/**
 * In the OData transformer, managed associations produce foreign keys.
 * If an association is also a primary key, the additionally created foreign keys become also primary keys in the parent artifact.
 * Proper FK generation requires specific order of performing that.
 * First PK association should be processed, then the non-PK associations.
 * This module provides functionality to sort managed associations depending on if they are marked as primary key or not.
 */

const {
  forEachDefinition,
  forEachMemberRecursively
} = require('../../model/csnUtils');

function buildDependenciesFor(csn) {
  const definitionsToProcess = {};
  const mapDefinitionsKeyAssociations = {};
  const mapUnprocessedKeyAssociationsCount = {};

  function registerKeyAssociation(from, name, target, path, parent, element) {
    initIntegerMember(mapUnprocessedKeyAssociationsCount, from);
    initMapMember(mapDefinitionsKeyAssociations,from);
    mapDefinitionsKeyAssociations[from][name] = { target, path, parent, element };
    mapUnprocessedKeyAssociationsCount[from]++;
  }

  function markDefinitionAsToBeProcessed(definitionName) {
    initIntegerMember(mapUnprocessedKeyAssociationsCount, definitionName);
    definitionsToProcess[definitionName] = true;
  }

  function markDefinitionsAsAlreadyProcessed(definitionName) {
    definitionsToProcess[definitionName] = false;
  }

  function setUnprocessedKeyAssocinationCountForDefinition(definitionName, count) {
    mapUnprocessedKeyAssociationsCount[definitionName] = count;
  }

  function getUnprocessedKeyAssociationsCountForDefinition(definitionName) {
    return mapUnprocessedKeyAssociationsCount[definitionName];
  }

  let associationsAlreadyInResult = {}; // map <path,bool> of associations with where added to the result

  let associationsNonPK = []; // list of sorted non-primary key associations

  // loop over definitions and their elements to find an collect PK and non-PK associations
  forEachDefinition(csn, (def, definitionName) => {
    let hasAssociations, hasKeyAssociations = false;
    let root = [ 'definitions', definitionName ];
    forEachMemberRecursively(def, (element, elementName, prop, subpath, parent) => {
      let path = root.concat(subpath);
      // go only through managed associations and compositions
      if(isAssociationOrComposition(element) && !element.on) {
        hasAssociations = true;
        markDefinitionAsToBeProcessed(definitionName);
        if(element.key) {
          registerKeyAssociation(definitionName, elementName, element.target, path, parent, element);
          hasKeyAssociations=true;
        } else {
          if(!associationsAlreadyInResult[path]) {
            associationsNonPK.push( { definitionName, elementName, element, parent, path } );
            associationsAlreadyInResult[path] = true;
          }
        }
      }
    }) // forEachMemberRecursively
    if(hasAssociations && !hasKeyAssociations) {
      //result.push(defName)
      markDefinitionsAsAlreadyProcessed(definitionName)
    }
  }) // forEachDefinition

  // Is there anything to process? This would be the list of associations which are PKs
  let totalCountOfArtifactsToProcess = Object.keys(definitionsToProcess).filter(definitionName => definitionsToProcess[definitionName]).length;
  if(totalCountOfArtifactsToProcess === 0) {
    return associationsNonPK; // nothing to do -> return
  }

  let associationsPK = []; // list of sorted primary key associations

  let loops = 0;
  do {
    // algorithm consistency check: can not process more artifacts than provided (prevent endless loop)
    if(loops > totalCountOfArtifactsToProcess)
      throw Error(`Error in sortByAssociationDependency: too many loops: ${loops}, expected at most: ${totalCountOfArtifactsToProcess}`);
    let countOfProcessed = processArtifacts();
    // consistency check: it should process at least one artifact (prevent endless loop)
    if(countOfProcessed === 0 && loops > 0)
      throw Error('Error in sortByAssociationDependency: processArtifacts did not process any artifacts');
    loops++;
  } while(prepareArtifactsToProcess());

  // return all associations starting with primary key ones as they have priority
  return associationsPK.concat(associationsNonPK);

  function processArtifacts() {
    let countOfProcessedArtifacts = 0;
    Object.keys(definitionsToProcess)
      .filter(definitionName => definitionsToProcess[definitionName])
      .forEach(definitionName => {
        if (getUnprocessedKeyAssociationsCountForDefinition(definitionName) === 0) {
          let keyAssocs = mapDefinitionsKeyAssociations[definitionName]
          for (var elementName in keyAssocs) {
            var { path, parent, element } = keyAssocs[elementName];
            if (associationsAlreadyInResult[path])
              continue;
            associationsPK.push({ definitionName, elementName, element, parent, path })
            associationsAlreadyInResult[path] = true;
          }
          markDefinitionsAsAlreadyProcessed(definitionName)
          countOfProcessedArtifacts++;
        }
      })
    return countOfProcessedArtifacts;
  }

  // if there are artifacts whose targets are still not processed returns true
  function prepareArtifactsToProcess() {
    let hasMoreToProcess = false;
    for(let artifact in mapDefinitionsKeyAssociations) {
      let aRed = mapDefinitionsKeyAssociations[artifact];
      let stillToProcessCount = 0;
      for(let memberName in aRed) {
        let target = aRed[memberName].target;
        if(definitionsToProcess[target])
          stillToProcessCount++;
      }
      if(stillToProcessCount != getUnprocessedKeyAssociationsCountForDefinition(artifact)) {
        hasMoreToProcess = true;
        setUnprocessedKeyAssocinationCountForDefinition(artifact, stillToProcessCount);
      }
    }
    return hasMoreToProcess;
  }
}

// ------------------------ helper functions ------------------------------------

// Return true if 'artifact' has an association type
function isAssociation(artifact) {
  return (artifact.type === 'cds.Association' || artifact.type === 'Association');
}

// Return true if 'artifact' has a composition type
function isComposition(artifact) {
  return (artifact.type === 'cds.Composition' || artifact.type === 'Composition')
}

function isAssociationOrComposition(artifact) {
  return isAssociation(artifact) || isComposition(artifact);
}

function initMapMember(map,name) {
  if(map[name]===undefined) map[name] = {};
}

function initIntegerMember(what,name) {
  if(what[name]===undefined) what[name] = 0;
}

module.exports = buildDependenciesFor

