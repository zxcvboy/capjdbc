const { setProp, forEachDefinition, forEachGeneric, forEachMemberRecursively } = require('../base/model');
const { CompilationError, hasErrors, sortMessages } = require('../base/messages');
const transformUtils = require('./transformUtils');
const { isAssocOrComposition } = require('../model/modelUtils');
const alerts = require('../base/alerts');

function isValidAssocOrComposition(elem) {
  return isAssocOrComposition(elem.type) && !elem._ignore
}

function preprocessModel(model) {
  // e.g. signal(error`...`, <artifact>.location);
  const { error, signal } = alerts(model);
  const { checkExposedAssoc } = transformUtils.getTransformers(model, '_');

  forEachDefinition(model, obj => {
    if (obj.kind !== 'service')
      return;
    forEachGeneric(obj, 'artifacts', art => {
      processElements(art);
      if (art.projection)       // TODO: use art.query
        processProjection(obj, art);
      if (art.kind === 'type')
        processType(obj, art);
    });
  });

  // Throw exception in case of errors
  if (hasErrors(model.messages)) {
    throw new CompilationError(sortMessages(model.messages));
  }

  // Preprocess elements of artifact in a service
  // 1. If some element has user defined type:
  //  - If the type definition is structured -> should be exposed in the current service
  //  - If the defined type is builtin -> expand it
  // 2. If a element is association checks if the target is from the current service
  function processElements(art) {
    let currentService = art._service;
    forEachMemberRecursively(art, member => {
      if (member.kind !== 'element')
        return;

      // 1. If the member has for a type a derived one - check if the type definition is
      // from the current service, it is exposed to the current service or builtin
      let memberType = member.items ? member.items.type : member.type;
      if (!memberType || !memberType._artifact)
        return;
      if (!memberType._artifact.name.absolute.startsWith('cds.') || memberType._artifact.name.absolute.startsWith('cds.foundation.')) {
        let memberTypeService = memberType._artifact._service || memberType._artifact._main && memberType._artifact._main._service;
        if (memberTypeService !== currentService) {
          // if the type is builtin and not from the current service -> expand it
          if (!art.projection && memberType._artifact.type && (memberType._artifact.type._artifact.name.absolute.startsWith('cds.')
              && !memberType._artifact.type._artifact.name.absolute.startsWith('cds.foundation')))
            member.items ? setProp(member.items, '_swaggerExpandType', true) : setProp(member, '_swaggerExpandType', true);
          else if (/* the projection case is handle in processProjection */!art.projection)// structured type not from the current service
            signal(error`The type ${memberType._artifact.name.absolute} of ${member.name.absolute} is not from the service ${currentService.name.absolute}`, member.location);
        }
      }

      // 2. check if the target of the association is part of the current service
      if (!art.projection && isValidAssocOrComposition(member)) {
        checkExposedAssoc(art, member);
      }
    });
  }

  // if an artifact is a projection on entity not from the current service,
  // then check its elements, if some of the elements:
  //   -> is an association - set a '_swaggerTarget' to the association with a value of the corresponding
  //      projection(on the target of the assoc in the underlying context) from the current service
  //      or throw an error if the target is not exposed in the current service
  //   -> has a user defined type - check if the type is exposed or not
  function processProjection(parent, art) {
    if (parent !== source(art)._service) { // parent is the service
      forEachMemberRecursively(art, elem => {
        if (elem.kind !== 'element')
          return;
        // association redirecting
        if (isValidAssocOrComposition(elem)) {
          // try to find representation of the association target in the current service
          let targetFromCurrectService = Object.keys(parent.artifacts).filter(artName => parent.artifacts[artName].projection)
            .find(projName =>
              // the projection source with which the reference to be replaced
              source(parent.artifacts[projName]).name.absolute === elem.target._artifact.name.absolute
            );
          if (targetFromCurrectService)
            setProp(elem, '_swaggerTarget', targetFromCurrectService);
          else {
            signal(error`Association ${elem.name.absolute}.${elem.name.id} cannot be implicitly redirected: Target ${elem.target._artifact.name.absolute} is not exposed in service ${parent.name.absolute} by any projection`, elem.location);
          }
        } else {
          // check the case when the element has a user defined type
          let elemType = elem.items ? elem.items.type : elem.type;
          if (!elemType || !elemType._artifact)
            return;
          if (elemType._artifact.name.absolute.startsWith('cds.') && !elemType._artifact.name.absolute.startsWith('cds.foundation.'))
            return;
          let elemTypeService = elemType._artifact._service || elemType._artifact._main && elemType._artifact._main._service;
          // the type is not from the current definition
          if (elemTypeService !== parent._service) {
            // try to find the exposition of the type in the current service
            let typeFromCurrectService = Object.keys(parent.artifacts).filter(artName => parent.artifacts[artName].kind === 'type')
              .find(typeName =>
                parent.artifacts[typeName].type && parent.artifacts[typeName].type._artifact.name.absolute == elemType._artifact.name.absolute
              );
            if (typeFromCurrectService)
              elem.items ? setProp(elem.items, '_swaggerType', typeFromCurrectService) : setProp(elem, '_swaggerType', typeFromCurrectService);
            else if (elemType._artifact.type && elemType._artifact.type._artifact.name.absolute.startsWith('cds.') && !elemType._artifact.type._artifact.name.absolute.startsWith('cds.foundation.'))
              // if the type is builtin and not from the current service -> expand it
              elem.items ? setProp(elem.items, '_swaggerExpandType', true) : setProp(elem, '_swaggerExpandType', true);
            else
              signal(error`The type ${elemType._artifact.name.absolute} of element ${elem.name.absolute}.${elem.name.id} is not exposed in service ${parent.name.absolute} via a type definition`, elem.location);
          }
        }
      })
    }
  }

  function processType(parent, art) {
    setProp(art, '_swaggerExpandType', true);
    if (art._finalType && art._finalType.builtin)
      return;
    forEachMemberRecursively(art._finalType, member => {
      let memberType = member.items ? member.items.type : member.type;
      if (!memberType || !memberType._artifact)
        return;
      if (memberType._artifact.name.absolute.startsWith('cds.') && !memberType._artifact.name.absolute.startsWith('cds.foundation.'))
        return;
      // try to find the exposition of the type in the current service
      let typeFromCurrectService = Object.keys(parent.artifacts).filter(artName => parent.artifacts[artName].kind === 'type')
        .find(typeName =>
          parent.artifacts[typeName].type &&
          parent.artifacts[typeName].type._artifact === memberType._artifact
        );
      if (typeFromCurrectService)
        member.items ? setProp(member.items, '_swaggerType', typeFromCurrectService) : setProp(member, '_swaggerType', typeFromCurrectService);
      else
        signal(error`The type ${memberType._artifact.name.absolute} of artifact ${member.name.absolute}.${member.name.id} is not exposed in service ${parent.name.absolute} via a type definition`, member.location);
    });
  }
}

// TODO: consider making the above functionality work with more than one source
function source( view ) {
  let from = view.query && view.query.from;
  return from && from[0] && from[0]._artifact;
}


module.exports = preprocessModel;
