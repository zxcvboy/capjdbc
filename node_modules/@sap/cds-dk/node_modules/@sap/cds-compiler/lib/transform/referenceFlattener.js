const { forEachRef } = require('../model/csnUtils');
const { setProp } = require('../base/model');
const walker = require('../json/walker');


/** This class is used for generic reference flattening.
 * It provides the following functionality:
 * - attach the CSN location paths of object as $path property
 * - resolve all references found in the CSN
 * The resolved references and their paths are stored in the $paths property which is attached to the reference
 * In addition, the items of the references will be checked if they point to structured elements,
 * and the result will be cached in the "structuredReference" member variable.
 * - register flattened elements - stored in the member variable "flattenedElementPaths"
 * - check if a specific path points to a structured element
 * - flatten of all references - combines already stored information to flatten the references
 *
 * Generic reference flattening works as follows:
 * - resolve all references and there the single items
 * - attach the resolved paths to the elements
 * - during flattening of elements, transformers register all flattened paths
 * - final flattening detects reference items which point to flattened elements
 *   and joins both previous and current reference items
 */

class ReferenceFlattener {

  constructor() {
    this.flattenedElementPaths={};
    this.structuredReference={};
    this.generatedElementsForPath={};
  }

  attachPaths(csn) {

    function isResolvable(path,obj,name,visible) {
      if(name) {
        if (path[0] === 'messages')
          return false;
        // ignore all hidden properties but not 'elements'
        if(!visible && name!=='elements') {
          return false;
        }
      }
      return true;
    }

    walker.walkWithPath(csn, (isNode,path,node) => {
      if(isNode) {
        setProp(node,'$path',path);
      }
    }, isResolvable)
  }

  resolveAllReferences(csn,inspectRef,isStructured) {
    forEachRef(csn, (ref, node, path) => {
      if(!path) return;
      let resolved;
      try {
        resolved = inspectRef(path);
      } catch(ex) {
        return;  // TODO: fix tests: throw Error("Could not inspectRef: " + path.join("/"));
      }
      if(!resolved)
        return; // TODO: fix tests: throw Error("Could not resolve: " + path.join("/"));
      if(!resolved.links)
        return; // TODO: fix tests:  throw Error("Could not resolve links: " + path.join("/"));
      let paths = [];
      resolved.links.forEach((element) => {
        if(!element.art)
          paths=undefined; // not resolved -> no paths
        if(paths) {
          paths.push(element.art.$path)
        }
      });
      if(paths)
        setProp(node,'$paths',paths)
      // cache also if structured or not
      let structured = resolved.links.map(link => link.art?(isStructured(link.art)):undefined)
      this.structuredReference[path.join('/')] = structured;
    });
  }

  isStructured(path) {
    return this.structuredReference[path.join('/')];
  }

  registerFlattenedElement(path,originPath) {
    let spath = path.join('/');
    this.flattenedElementPaths[spath]=true;
    if(originPath) {
      let sOriginPath = originPath.join('/');
      this.flattenedElementPaths[sOriginPath]=true;
    }
  }

  registerGeneratedElementsForPath(path,elementNames) {
    this.generatedElementsForPath[path.join("/")]=elementNames;
  }

  getGeneratedElementsForPath(path) {
    return this.generatedElementsForPath[path.join("/")];
  }

  flattenAllReferences(csn) {
    forEachRef(csn, (ref, node) => {
      if(ref.length==1) return; // too short, no flattening
      if(node.$paths) {
        let newRef=[]; // flattened reference
        let flattenWithPrevious=false;
        let anythingFlattened=false; // will be set to true if at least one node is flatted
        node.$paths.forEach((path,i) => {
          if(path == undefined) return;
          let spath = path.join('/')
          let flattened = this.flattenedElementPaths[spath];
          if(flattenWithPrevious) {
            newRef[newRef.length-1]=newRef[newRef.length-1]+'_'+ref[i];
            anythingFlattened=true;
          } else {
            newRef.push(ref[i]);
          }
          flattenWithPrevious = flattened;
        });
        if(newRef != undefined && anythingFlattened) { // do not replace unchanged references
          // check if this is a column and add alias if missing
          if(isColumnInSelect(ref.$path)) {
            if(!node.as) {
              node.as = node.ref[node.ref.length-1];
            }
          }
          node.ref=newRef;
        }
      }
    })
  }
}

/**
 * Checks if the provided path is a column inside a select
 * by exploring the possibility of the path to end with ['SELECT','columns','<an integer', <ref - not checked>]
 * @param {string[]} path - path to explore
 * @returns {boolean} the provided path matched the requirements
 */
function isColumnInSelect(path) {
  if(!path) return false;
  let len = path.length;
  if(path[len-4]=='SELECT' && path[len-3]=='columns') {
    // check if -2 element is an integer / array index
    let arrayIndex = parseInt(path[len-2],10);
    if (!isNaN(arrayIndex))
      return true;
  }
  return false;
}

module.exports = ReferenceFlattener
