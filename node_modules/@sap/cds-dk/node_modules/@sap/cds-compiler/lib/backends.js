'use strict';

// API functions for backends (i.e. functions that take a compiled
// augmented CSN and generate something from it)

const csnToSwagger = require('./render/toSwagger');
const { transformForHana } = require('./transform/forHana');
const { transformForHanaWithCsn } = require('./transform/forHanaNew');
const { compactModel, sortCsn } = require('./json/to-csn')
const { toCdsSource, toCdsSourceCsn } = require('./render/toCdl');
const { toSqlDdl } = require('./render/toSql');
const { toRenameDdl } = require('./render/toRename');
const { transform4odata } = require('./transform/forOdata');
const { transform4odataWithCsn } = require('./transform/forOdataNew');
const { csn2edm, csn2edmAll } = require('./edm/csn2edm');
const { mergeOptions }  = require('./model/modelUtils');
const alerts = require('./base/alerts');
const { handleMessages } = require('./base/messages');
const { setProp, isBetaEnabled } = require('./base/model');
const { optionProcessor } = require('./optionProcessor')
const timetrace = require('./utils/timetrace');

function deprecated( model, options, signal, backend ) {
  if (options.beta || options.betaMode) { // by intention, no test for individual beta features
    signal(signal.error`Deprecated backend '${backend}' cannot be used with beta features`);
    handleMessages( model, options );
  }
  else if (model.$newfeatures) {
    signal(signal.error`Deprecated backend '${backend}' cannot be used with most new features like ${model.$newfeatures}`);
    handleMessages( model, options );
  }
  else {
    signal(signal.warning`Deprecated backend '${backend}' - do not disable feature 'snapi'`);
  }
}

/**
 * Transform an augmented CSN 'model' into HANA-compatible CDS source.
 * The following options control what is actually generated (see help above):
 *   options : {
 *     toHana.names
 *     toHana.associations
 *     toHana.src
 *     toHana.csn
 *   }
 * Options provided here are merged with (and take precedence over) options from 'model'.
 * If 'toHana.names' is not provided, 'quoted' is used.
 * If 'toHana.associations' is not provided, 'assocs' is used.
 * If neither 'toHana.src' nor 'toHana.csn' are provided, the default is to generate only HANA CDS
 * source files.
 * If all provided options are part of 'toHana', the 'toHana' wrapper can be omitted.
 * The result object contains the generation results as follows (as enabled in 'options'):
 *   result : {
 *     csn               : the (compact) transformed CSN model
 *     _augmentedCsn     : (subject to change): the augmented CSN model
 *     hdbcds            : a dictionary of top-level artifact names, containing for each name 'X':
 *       <X>             : the HANA CDS source string of the artifact 'X'. Please note that the
 *                         name of 'X' may contain characters that are not legal for filenames on
 *                         all operating systems (e.g. ':', '\' or '/').
 *                         X reflects the naming policy set by toHana.names
 *     messages          : an array of strings with warnings (if any)
 *   }
 * Throws a CompilationError on errors.
 *
 * @param {XSN.Model}   model
 * @param {CSN.Options} [options]
 */
function toHana(model, options) {
  // In case of API usage the options are in the 'options' argument
  // put the OData specific options under the 'options.toHana' wrapper
  // and leave the rest under 'options'
  if (options && !options.toHana) {
    _wrapRelevantOptionsForCmd(options, 'toHana');
  }
  // Provide defaults and merge options with those from model
  options = mergeOptions({ toHana : getDefaultBackendOptions().toHana }, model.options, options);

  // Provide something to generate if nothing else was given (conditional default)
  if (!options.toHana.src && !options.toHana.csn) {
    options.toHana.src = true;
  }

  const { warning, signal } = alerts(model);
  deprecated( model, options, signal, 'toHana' ); // -> to.hdbcds
  // Backward compatibility for old naming modes
  // FIXME: Remove after a few releases
  if (options.toHana.names === 'flat') {
    signal(warning`Option "{ toHana.names: 'flat' }" is deprecated, use "{ toHana.names: 'plain' }" instead`);
    options.toHana.names = 'plain';
  }
  else if (options.toHana.names === 'deep') {
    signal(warning`Option "{ toHana.names: 'deep' }" is deprecated, use "{ toHana.names: 'quoted' }" instead`);
    options.toHana.names = 'quoted';
  }

  // Verify options
  optionProcessor.verifyOptions(options, 'toHana').map(complaint => signal(warning`${complaint}`));

  // Special case: For naming variant 'hdbcds' in combination with 'toHana' (and only there!), 'forHana'
  // must leave namespaces, structs and associations alone.
  if (options.toHana.names === 'hdbcds') {
    options = mergeOptions(options, { forHana : { keepNamespaces: true, keepStructsAssocs: true } });
  }

  // Prepare model for HANA (transferring the options to forHana, and setting 'dialect' to 'hana', because 'toHana' is only used for that)
  let forHanaAugmented = transformForHana(model, mergeOptions(options, { forHana: { dialect: 'hana' } }, { forHana : options.toHana } ));

  // Assemble result
  let result = {};
  if (options.toHana.src) {
    result.hdbcds = toCdsSource(forHanaAugmented);
  }
  if (options.toHana.csn) {
    result._augmentedCsn = forHanaAugmented;
    result.csn = compactModel(forHanaAugmented);
    if(options.testMode)
      result.csn = sortCsn(result.csn);
  }

  // Transfer warnings (errors would have resulted in an exception before we come here)
  if (forHanaAugmented.messages && forHanaAugmented.messages.length > 0) {
    result.messages = forHanaAugmented.messages;
  }
  return result;
}

/**
 * The twin of the toHana function but using CSN as a model *
 * @param {CSN.Model}   csn
 * @param {CSN.Options} [options]
 */
function toHanaWithCsn(csn, options) {
  timetrace.start('toHanaWithCsn');
  // In case of API usage the options are in the 'options' argument
  // put the OData specific options under the 'options.toHana' wrapper
  // and leave the rest under 'options'
  if (options && !options.toHana) {
    _wrapRelevantOptionsForCmd(options, 'toHana');
  }
  // Provide defaults and merge options with those from model
  options = mergeOptions({ toHana : getDefaultBackendOptions().toHana }, csn.options, options);

  // Provide something to generate if nothing else was given (conditional default)
  if (!options.toHana.src && !options.toHana.csn) {
    options.toHana.src = true;
  }

  const { warning, signal } = alerts(csn, options);

  // Verify options
  optionProcessor.verifyOptions(options, 'toHana', true).map(complaint => signal(warning`${complaint}`));

  // Special case: For naming variant 'hdbcds' in combination with 'toHana' (and only there!), 'forHana'
  // must leave namespaces, structs and associations alone.
  if (options.toHana.names === 'hdbcds') {
    options = mergeOptions(options, { forHana : { keepNamespaces: true, keepStructsAssocs: true } });
  }

  options = mergeOptions(options, { forHana: { dialect: 'hana' } }, { forHana : options.toHana });

  // Prepare model for HANA (transferring the options to forHana, and setting 'dialect' to 'hana', because 'toHana' is only used for that)
  let forHanaCsn = transformForHanaWithCsn(csn, options);

  // Assemble result
  let result = {};
  if (options.toHana.src) {
    if(options.testMode){
      const sorted = sortCsn(forHanaCsn, true);
      setProp(sorted, "options", forHanaCsn.options);
      setProp(sorted, "messages", forHanaCsn.messages);
      result.hdbcds = toCdsSourceCsn(sorted, options);
    } else {
      result.hdbcds = toCdsSourceCsn(forHanaCsn, options);
    }
  }
  if (options.toHana.csn) {
    result.csn = options.testMode ? sortCsn(forHanaCsn) : forHanaCsn;
  }

  // Transfer warnings (errors would have resulted in an exception before we come here)
  if (forHanaCsn.messages && forHanaCsn.messages.length > 0) {
    result.messages = forHanaCsn.messages;
  }
  timetrace.stop();
  return result;
}

// ----------- toOdata -----------


// Generate ODATA for augmented CSN `model` using `options`.
// Before anything is generated, the following transformations are applied to 'model':
// FIXME: Verify that this is still correct
// - Flatten structured elements (and foreign keys of managed associations pointing to
//   keys that are themselves managed associations).
// - Generate foreign key fields for entities with managed associations (annotated with
//   '@odata.foreignKey4'). Propagate along projections accordingly. Names are built using
//   <assoc>_<key>, conflicts are checked.
// - Complete the 'foreignKeys' property for all managed associations, so that there
//   is always a 'generatedFieldName' for the corresponding generated foreign key field.
// - Implicitly redirect associations based on exposure
// - Check that exposed associations do not point to non-exposed targets
// - Unravel derived type chains, propagating annotations upwards.
// - Rename annotations according to a fixed list of short-hands
// The following options control what is actually generated (see help above):
//   options : {
//     toOdata.version
//     toOdata.odataFormat
//     toOdata.xml
//     toOdata.json
//     toOdata.separate
//     toOdata.combined
//     toOdata.csn
//     toOdata.names
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If 'toOdata.version' is not provided, 'v4' is used.
// If neither 'toOdata.xml' nor 'toOdata.json' nor 'toOdata.csn' are provided, the default is
// to generate only XML output. If neither 'toOdata.separate' nor 'toOdata.combined' are provided,
// the default is to generate only combined XML output.
// If all provided options are part of 'toOdata', the 'toOdata' wrapper can be omitted.
//
// The result object contains the generation results as follows (as enabled in 'options'):
//   result : {
//     csn               : the (compact) transformed CSN model including all services
//     _augmentedCsn     : (subject to change): the augmented CSN model including all services
//     services          : a dictionary of service names, containing for each name:
//       <servicename> : {
//         annotations   : an XML string with EDMX annotations for service 'svc'
//         metadata      : an XML string with EDMX metadata for service 'svc'
//         combined      : an XML string with both EDMX metadata and annotations for service 'svc'
//         metadata_json : a JSON object (not a string!) with EDM metadata for service 'svc'
//       }
//     messages          : an array of strings with warnings (if any)
//   }
// If 'model' does not contain any services, 'csn' will still contain the transformed model, but
// 'services' will be an empty dictionary.
//
// Throws a CompilationError on errors.
function toOdata(model, options) {
  const { error, warning, signal } = alerts(model);

  // In case of API usage the options are in the 'options' argument
  // put the OData specific options under the 'options.toOdata' wrapper
  // and leave the rest under 'options'
  if (options && !options.toOdata) {
    _wrapRelevantOptionsForCmd(options, 'toOdata');
  }
  // Provide defaults and merge options with those from model
  options = mergeOptions({ toOdata : getDefaultBackendOptions().toOdata }, model.options, options);
  deprecated( model, options, signal, 'toOdata' ); // -> for.odata / to.edm / to.edmx

  // Provide something to generate if nothing else was given (conditional default)
  if (!options.toOdata.xml && !options.toOdata.json && !options.toOdata.csn) {
    options.toOdata.xml = true;
  }
  if (!options.toOdata.separate && !options.toOdata.combined) {
    options.toOdata.combined = true;
  }

  // Backward compatibility for old naming modes
  // FIXME: Remove after a few releases
  if (options.toOdata.names === 'flat') {
    signal(warning`Option "{ toOdata.names: 'flat' }" is deprecated, use "{ toOdata.names: 'plain' }" instead`);
    options.toOdata.names = 'plain';
  }
  else if (options.toOdata.names === 'deep') {
    signal(warning`Option "{ toOdata.names: 'deep' }" is deprecated, use "{ toOdata.names: 'quoted' }" instead`);
    options.toOdata.names = 'quoted';
  }

  // Verify options
  optionProcessor.verifyOptions(options, 'toOdata').map(complaint => signal(warning`${complaint}`));

  // Prepare model for ODATA processing
  let forOdataAugmented = transform4odata(model, options);

  // Assemble result object
  let result = {
    services: Object.create(null),
    messages: model.messages,
  }
  if (options.toOdata.csn) {
    result.csn = compactModel(forOdataAugmented);
    result._augmentedCsn = forOdataAugmented;
  }

  // Create annotations and metadata once per service
  if (options.toOdata.xml || options.toOdata.json) {
    // Compact the model
    let compactedModel = compactModel(forOdataAugmented);
    setProp(compactedModel, 'messages', forOdataAugmented.messages);

    let allServices = csn2edmAll(compactedModel, options);
    for(let serviceName in allServices) {
      let l_edm = allServices[serviceName];

      result.services[serviceName] = {};
      if (options.toOdata.xml) {
        if (options.toOdata.separate) {
          result.services[serviceName].annotations = l_edm.toXML('annotations');
          result.services[serviceName].metadata = l_edm.toXML('metadata');
        }
        if (options.toOdata.combined) {
          result.services[serviceName].combined = l_edm.toXML('all');
        }
      }
      if (options.toOdata.json) {
        // JSON output is not available for ODATA V2
        if (options.toOdata.version === 'v2') {
          signal(error`ODATA JSON output is not available for ODATA V2`);
        }
        // FIXME: Why only metadata_json - isn't this rather a 'combined_json' ? If so, rename it!
        result.services[serviceName].metadata_json = l_edm.toJSON();
      }
    }
  }

  return result;
}

/**
 * Generate ODATA for `csn` using `options`.
 * The twin of the toOdata function but using CSN
 *
 * @param {CSN.Model}   csn
 * @param {CSN.Options} [options]
 */
function toOdataWithCsn(csn, options) {
  // In case of API usage the options are in the 'options' argument
  // put the OData specific options under the 'options.toOdata' wrapper
  // and leave the rest under 'options'
  if (options && !options.toOdata) {
    _wrapRelevantOptionsForCmd(options, 'toOdata');
  }
  // Provide defaults and merge options with those from csn
  options = mergeOptions({ toOdata : getDefaultBackendOptions().toOdata }, csn.options, options);

  // Provide something to generate if nothing else was given (conditional default)
  if (!options.toOdata.xml && !options.toOdata.json && !options.toOdata.csn) {
    options.toOdata.xml = true;
  }
  if (!options.toOdata.separate && !options.toOdata.combined) {
    options.toOdata.combined = true;
  }

  const { error, warning, signal } = alerts(csn, options);

  // Verify options
  optionProcessor.verifyOptions(options, 'toOdata', true).map(complaint => signal(warning`${complaint}`));

  // Prepare model for ODATA processing
  let forOdataCSN = transform4odataWithCsn(csn, options);
  // Assemble result object
  let result = {
    services: Object.create(null),
    messages: forOdataCSN.messages,
  }
  if (options.toOdata.csn) {
    result.csn = forOdataCSN;
  }

  // Create annotations and metadata once per service
  if (options.toOdata.xml || options.toOdata.json) {
    let allServices = csn2edmAll(forOdataCSN, options);
    for(let serviceName in allServices) {
      let l_edm = allServices[serviceName];


      result.services[serviceName] = {};
      if (options.toOdata.xml) {
        if (options.toOdata.separate) {
          result.services[serviceName].annotations = l_edm.toXML('annotations');
          result.services[serviceName].metadata = l_edm.toXML('metadata');
        }
        if (options.toOdata.combined) {
          result.services[serviceName].combined = l_edm.toXML('all');
        }
      }
      if (options.toOdata.json) {
        // JSON output is not available for ODATA V2
        if (options.toOdata.version === 'v2') {
          signal(error`ODATA JSON output is not available for ODATA V2`);
        }
        // FIXME: Why only metadata_json - isn't this rather a 'combined_json' ? If so, rename it!
        result.services[serviceName].metadata_json = l_edm.toJSON();
      }
    }
  }

  return result;
}

// Generate edmx for given 'service' based on 'csn' (new-style compact, already prepared for OData)
// using 'options'
function preparedCsnToEdmx(csn, service, options) {
  // Merge options with those from model
  options = mergeOptions(csn.options, options);
  let edmx = csn2edm(csn, service, options).toXML('all');
  return {
    edmx,
    messages: options.messages || csn.messages,
  };
}

// Generate edmx for given 'service' based on 'csn' (new-style compact, already prepared for OData)
// using 'options'
function preparedCsnToEdmxAll(csn, options) {
  // Merge options with those from model
  options = mergeOptions(csn.options, options);
  let edmx = csn2edmAll(csn, options);
  for(const service in edmx){
    edmx[service] = edmx[service].toXML('all');
  }
  return {
    edmx,
    messages: options.messages || csn.messages,
  };
}

// Generate edm-json for given 'service' based on 'csn' (new-style compact, already prepared for OData)
// using 'options'
function preparedCsnToEdm(csn, service, options) {
  // Merge options with those from model, override OData version as edm json is always v4
  options = mergeOptions(csn.options, options, { toOdata : { version : 'v4' }});
  let edmj = csn2edm(csn, service, options).toJSON();
  return {
    edmj,
    messages: options.messages || csn.messages,
  };
}

// Generate edm-json for given 'service' based on 'csn' (new-style compact, already prepared for OData)
// using 'options'
function preparedCsnToEdmAll(csn, options) {
  // Merge options with those from model, override OData version as edm json is always v4
  options = mergeOptions(csn.options, options, { toOdata : { version : 'v4' }});
  let edmj = csn2edmAll(csn, options);
  for(const service in edmj){
    edmj[service] = edmj[service].toJSON();
  }
  return {
    edmj,
    messages: options.messages || csn.messages,
  };
}

// ----------- toCdl -----------

/**
 * Generate CDS source text for augmented CSN model 'model'.
 * The following options control what is actually generated:
 *   options : {
 *     FIXME: This option should be removed and something like 'toCdl.dialect: 'hana' be
 *            used instead.
 *     toHana : if true, HANA-specific source dialect is generated (affects e.g. the
 *              translation of '$self.foo' in paths and ::-ish namespace declarations)
 *   }
 * One source is created per top-level artifact.
 * Return a dictionary of top-level artifacts
 * by their names, like this:
 * { "foo" : "using XY; context foo {...};",
 *   "bar::wiz" : "namespace bar::; entity wiz {...};"
 * }
 * Throws a CompilationError on errors.
 *
 * @param {XSN.Model}   model
 * @param {CSN.Options} [options]
 */
function toCdl(model, options) {
  const { signal } = alerts(model);
  options = handleToCdlOptions(model, options);
  deprecated( model, options, signal, 'toCdl' ); // -> to.cdl/to.hdbcds
  return toCdsSource(model, options);
}

/**
 * @param {XSN.Model | CSN.Model} model
 * @param {CSN.Options} options
 * @param {boolean} [silent]
 */
function handleToCdlOptions(model, options, silent=false){
  // In case of API usage the options are in the 'options' argument
  // put the OData specific options under the 'options.toCdl' wrapper
  // and leave the rest under 'options'
  if (options && !options.toCdl) {
    _wrapRelevantOptionsForCmd(options, 'toCdl');
  }

  // Merge options with those from model
  options = mergeOptions({ toCdl : true }, model.options, options);

  const { warning, signal } = alerts(model, options);

  // Verify options
  optionProcessor.verifyOptions(options, 'toCdl', silent).map(complaint => signal(warning`${complaint}`));

  return options;
}

/**
 * @param {CSN.Model} csn
 * @param {CSN.Options} options
 */
function toCdlWithCsn(csn, options) {
  options = handleToCdlOptions(csn, options, true);
  const result = toCdsSourceCsn(csn, options);
  return { result, options };
}

// ----------- toSwagger -----------

// Generate OpenAPI JSON version 3 for the augmented CSN 'model'.
// The following options control what is actually generated:
//   options : {
//     toSwagger.json      : if true, generate OpenAPI JSON output
//     toSwagger.csn       : if true, generate the transformed CSN model
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If neither 'toSwagger.json' nor 'toSwagger.csn' are provided, the default is to generate
// only OpenAPI JSON.
// If all provided options are part of 'toSwagger', the 'toSwagger' wrapper can be omitted.
// One OpenAPI JSON object is created per service.
// The result object contains the generation results as follows (as enabled in 'options'):
//   result: {
//     csn               : the (compact) transformed CSN model including all services
//     _augmentedCsn     : (subject to change): the augmented CSN model including all services
//     services: {
//       <servicename>: {
//         openapi: '3.0.0',
//         info: { ... },
//         paths: { ...},
//         components: {
//           schemas: { ... }
//         }
//       }
//     }
//   }
//
// Throws a CompilationError on errors.
function toSwagger(model, options) {
  const { warning, error, signal } = alerts(model);

  // In case of API usage the options are in the 'options' argument
  // put the OData specific options under the 'options.toSwagger' wrapper
  // and leave the rest under 'options'
  if (options && !options.toSwagger) {
    _wrapRelevantOptionsForCmd(options, 'toSwagger');
  }

  // Merge options with those from model
  options = mergeOptions(model.options, options);

  // hide to swagger behind betaMode
  if (isBetaEnabled(options, 'toSwagger')) {
    signal(warning`The to swagger backend is experimental`);
  } else {
    signal(error`The to swagger backend is only available in beta-mode and is experimental`);
  }

  // If neither 'json' nor 'csn' is specified as output option, produce 'json'
  if (!options.toSwagger || (!options.toSwagger.json && !options.toSwagger.csn)) {
    options = mergeOptions({ toSwagger: { json: true } }, options);
  }
  // Verify options
  optionProcessor.verifyOptions(options, 'toSwagger').map(complaint => signal(warning`${complaint}`));
  // Actual implementation
  return csnToSwagger(model, options);
}

// ----------- toSql -----------

// Generate SQL DDL statements for augmented CSN 'model'.
// The following options control what is actually generated (see help above):
//   options : {
//     toSql.names
//     toSql.associations
//     toSql.dialect
//     toSql.user.id
//     toSql.user.locale
//     toSql.src
//     toSql.csn
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If neither 'toSql.src' nor 'toSql.csn' are provided, the default is to generate only SQL DDL
// source files.
// If all provided options are part of 'toSql', the 'toSql' wrapper can be omitted.
// The result object contains the generation results as follows (as enabled in 'options'):
//   result : {
//     csn               : the (compact) transformed CSN model
//     _augmentedCsn     : (subject to change): the augmented CSN model
//     sql               : a dictionary of top-level artifact names, containing for each name 'X':
//       <X>             : a string with SQL DDL statements for artifact 'X', terminated with ';'.
//                         Please note that the name of 'X' may contain characters that are not
//                         legal for filenames on all operating systems (e.g. ':', '\' or '/').
//     messages          : an array of strings with warnings (if any)
//   }
// Throws a CompilationError on errors.
function toSql(model, options) {
  const { warning, error, signal } = alerts(model);
  // when toSql is invoked via the CLI - toSql options are under model.options
  // ensure the desired format of the user option
  if (model.options && model.options.toSql &&(model.options.toSql.user || model.options.toSql.locale)) {
    transformUserOption(model.options.toSql);
  }

  // In case of API usage the options are in the 'options' argument
  // put the OData specific options under the 'options.toSql' wrapper
  // and leave the rest under 'options'
  if (options && !options.toSql) {
    _wrapRelevantOptionsForCmd(options, 'toSql');
  }

  // when the API funtion is used directly - toSql options are in options
  // ensure the desired format of the user option
  if (options && (options.toSql.user || options.toSql.locale)){
    transformUserOption(options.toSql);
  }

  // Provide defaults and merge options with those from model
  options = mergeOptions({ toSql : getDefaultBackendOptions().toSql }, model.options, options);
  deprecated( model, options, signal, 'toSql' ); // -> to.sql, to.hdi

  // Provide something to generate if nothing else was given (conditional default)
  if (!options.toSql.src && !options.toSql.csn) {
    options.toSql.src = 'sql';
  }

  // Backward compatibility for old naming modes
  // FIXME: Remove after a few releases
  if (options.toSql.names === 'flat') {
    signal(warning`Option "{ toSql.names: 'flat' }" is deprecated, use "{ toSql.names: 'plain' }" instead`);
    options.toSql.names = 'plain';
  }
  else if (options.toSql.names === 'deep') {
    signal(warning`Option "{ toSql.names: 'deep' }" is deprecated, use "{ toSql.names: 'quoted' }" instead`);
    options.toSql.names = 'quoted';
  }

  // Verify options
  optionProcessor.verifyOptions(options, 'toSql').map(complaint => signal(warning`${complaint}`));

  // FIXME: Currently, '--to-sql' implies transformation for HANA (transferring the options to forHana)
  let forHanaOptions = options.toSql;

  // Special case: For naming variant 'hdbcds' in combination with 'toSql', 'forHana' must leave
  // namespaces alone (but must still flatten structs because we need the leaf element names).
  if (options.toSql.names === 'hdbcds') {
    forHanaOptions.keepNamespaces = true;
  }

  // It doesn't make much sense to use 'sqlite' dialect with associations
  if (options.toSql.dialect === 'sqlite' && options.toSql.associations !== 'joins') {
    signal(warning`Option "{ toSql.dialect: 'sqlite' }" should always be combined with "{ toSql.assocs: 'joins' }"`);
  }

  if(options.toSql.dialect !== 'hana') {
    // CDXCORE-465, 'quoted' and 'hdbcds' are to be used in combination with dialect 'hana' only
    if(['quoted', 'hdbcds'].includes(options.toSql.names)) {
      signal(error`Option "{ toSql.dialect: '${options.toSql.dialect}' }" cannot be combined with "{ toSql.names: '${options.toSql.names}' }"`);
    }
    // No non-HANA SQL for HDI
    if(options.toSql.src === 'hdi') {
      signal(error`Option "{ toSql.dialect: '${options.toSql.dialect}' }" cannot be combined with "{ toSql.src: '${options.toSql.src}' }"`);
    }
  }

  // Because (even HANA) SQL cannot deal with associations in mixins that are published in the same view,
  // the association processing must at least be 'mixin', even if callers specified 'assocs'
  if (forHanaOptions.associations === 'assocs') {
    forHanaOptions.associations = 'mixin';
  }

  // FIXME: Should not be necessary
  forHanaOptions.alwaysResolveDerivedTypes = true;

  let forSqlAugmented = transformForHana(model, mergeOptions(options, { forHana : forHanaOptions } ));

  // Assemble result
  /** @type {object} */
  let result = {};
  if (options.toSql.src) {
    result = toSqlDdl(compactModel(forSqlAugmented), forSqlAugmented.options);
  }
  if (options.toSql.csn) {
    result._augmentedCsn = forSqlAugmented;
    result.csn = compactModel(forSqlAugmented);
  }

  // Transfer warnings (errors would have resulted in an exception before we come here)
  if (forSqlAugmented.messages && forSqlAugmented.messages.length > 0) {
    result.messages = forSqlAugmented.messages;
  }
  return result;

  // If among the options user, user.id or user.locale are specified via the CLI or
  // via the API, then ensure that at the end there is a user option, which is an object and has(have)
  // "id" and/or "locale" prop(s)
  function transformUserOption(options) {
    // move the user option value under user.id if specified as a string
    if (options.user && typeof options.user === 'string' || options.user instanceof String) {
      options.user = { id: options.user };
    }

    // move the locale option(if provided) under user.locale
    if (options.locale) {
      options.user
        ? Object.assign(options.user, { locale: options.locale })
        : options.user = { locale: options.locale };
      delete options.locale;
    }

  }
}

/**
 * The twin of the toSql function but using CSN as a model
 *
 * @param {CSN.Model}   model
 * @param {CSN.Options} [options]
 */
function toSqlWithCsn(model, options) {
  timetrace.start('toSqlWithCsn');
  // when toSql is invoked via the CLI - toSql options are under model.options
  // ensure the desired format of the user option
  if (model.options && model.options.toSql &&(model.options.toSql.user || model.options.toSql.locale)) {
    transformUserOption(model.options.toSql);
  }

  // In case of API usage the options are in the 'options' argument
  // put the OData specific options under the 'options.toSql' wrapper
  // and leave the rest under 'options'
  if (options && !options.toSql) {
    _wrapRelevantOptionsForCmd(options, 'toSql');
  }

  // when the API funtion is used directly - toSql options are in options
  // ensure the desired format of the user option
  if (options && (options.toSql.user || options.toSql.locale)){
    transformUserOption(options.toSql);
  }

  // Provide defaults and merge options with those from model
  options = mergeOptions({ toSql : getDefaultBackendOptions().toSql }, model.options, options);

  // Provide something to generate if nothing else was given (conditional default)
  if (!options.toSql.src && !options.toSql.csn) {
    options.toSql.src = 'sql';
  }

  const { warning, error, signal } = alerts(model, options);

  // Verify options
  optionProcessor.verifyOptions(options, 'toSql', true).map(complaint => signal(warning`${complaint}`));

  // FIXME: Currently, '--to-sql' implies transformation for HANA (transferring the options to forHana)
  let forHanaOptions = options.toSql;

  // Special case: For naming variant 'hdbcds' in combination with 'toSql', 'forHana' must leave
  // namespaces alone (but must still flatten structs because we need the leaf element names).
  if (options.toSql.names === 'hdbcds') {
    forHanaOptions.keepNamespaces = true;
  }

  // It doesn't make much sense to use 'sqlite' dialect with associations
  if (options.toSql.dialect === 'sqlite' && options.toSql.associations !== 'joins') {
    signal(warning`Option "{ toSql.dialect: 'sqlite' }" should always be combined with "{ toSql.assocs: 'joins' }"`);
  }

  if(options.toSql.dialect !== 'hana') {
    // CDXCORE-465, 'quoted' and 'hdbcds' are to be used in combination with dialect 'hana' only
    if(['quoted', 'hdbcds'].includes(options.toSql.names)) {
      signal(error`Option "{ toSql.dialect: '${options.toSql.dialect}' }" cannot be combined with "{ toSql.names: '${options.toSql.names}' }"`);
    }
    // No non-HANA SQL for HDI
    if(options.toSql.src === 'hdi') {
      signal(error`Option "{ toSql.dialect: '${options.toSql.dialect}' }" cannot be combined with "{ toSql.src: '${options.toSql.src}' }"`);
    }
  }

  // Because (even HANA) SQL cannot deal with associations in mixins that are published in the same view,
  // the association processing must at least be 'mixin', even if callers specified 'assocs'
  if (forHanaOptions.associations === 'assocs') {
    forHanaOptions.associations = 'mixin';
  }

  // FIXME: Should not be necessary
  forHanaOptions.alwaysResolveDerivedTypes = true;

  let forSqlCsn = transformForHanaWithCsn(model, mergeOptions(options, { forHana : forHanaOptions } ));

  // Assemble result
  /** @type {object} */
  let result = {};
  if (options.toSql.src) {
    result = toSqlDdl(forSqlCsn, forSqlCsn.options);
  }
  if (options.toSql.csn) {
    result.csn = options.testMode ? sortCsn(forSqlCsn) : forSqlCsn;
  }

  // Transfer warnings (errors would have resulted in an exception before we come here)
  if (forSqlCsn.messages && forSqlCsn.messages.length > 0) {
    result.messages = forSqlCsn.messages;
  }
  timetrace.stop();
  return result;

  // If among the options user, user.id or user.locale are specified via the CLI or
  // via the API, then ensure that at the end there is a user option, which is an object and has(have)
  // "id" and/or "locale" prop(s)
  function transformUserOption(options) {
    // move the user option value under user.id if specified as a string
    if (options.user && typeof options.user === 'string' || options.user instanceof String) {
      options.user = { id: options.user };
    }

    // move the locale option(if provided) under user.locale
    if (options.locale) {
      options.user
        ? Object.assign(options.user, { locale: options.locale })
        : options.user = { locale: options.locale };
      delete options.locale;
    }

  }
}
// ----------- toRename -----------

// FIXME: Not yet supported, only in beta mode
// Generate SQL DDL rename statements for a migration, renaming existing tables and their
// columns so that they match the result of "toHana" or "toSql" with the "{ names: 'plain' }
// option.
// Expects the naming convention of the existing tables to be either 'quoted' or 'hdbcds' (default).
// The following options control what is actually generated (see help above):
//   options : {
//     toRename.names
//   }
// Return a dictionary of top-level artifacts by their names, like this:
// { "foo" : "RENAME TABLE \"foo\" ...",
//   "bar::wiz" : "RENAME VIEW \"bar::wiz\" ..."
// }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If all provided options are part of 'toRename', the 'toRename' wrapper can be omitted.
// The result object contains the generation results as follows:
//   result : {
//     rename            : a dictionary of top-level artifact names, containing for each name 'X':
//       <X>             : a string with SQL DDL statements for artifact 'X', terminated with ';'.
//                         Please note that the name of 'X' may contain characters that are not
//                         legal for filenames on all operating systems (e.g. ':', '\' or '/').
//     messages          : an array of strings with warnings (if any)
//   }
// Throws a CompilationError on errors.
function toRename(model, options) {
  const { error, warning, signal } = alerts(model);

  // In case of API usage the options are in the 'options' argument
  // put the OData specific options under the 'options.toRename' wrapper
  // and leave the rest under 'options'
  if (options && !options.toRename) {
    _wrapRelevantOptionsForCmd(options, 'toRename');
  }

  // Provide defaults and merge options with those from model
  options = mergeOptions({ toRename : getDefaultBackendOptions().toRename }, model.options, options);

  // Backward compatibility for old naming modes
  // FIXME: Remove after a few releases
  if (options.toRename.names === 'flat') {
    signal(warning`Option "{ toRename.names: 'flat' }" is deprecated, use "{ toRename.names: 'plain' }" instead`);
    options.toRename.names = 'plain';
  }
  else if (options.toRename.names === 'deep') {
    signal(warning`Option "{ toRename.names: 'deep' }" is deprecated, use "{ toRename.names: 'quoted' }" instead`);
    options.toRename.names = 'quoted';
  }

  // Verify options
  optionProcessor.verifyOptions(options, 'toRename').map(complaint => signal(warning`${complaint}`));

  // Requires beta mode
  if (!isBetaEnabled(options, 'toRename')) {
    signal(error`Generation of SQL rename statements is not supported yet (only in beta mode)`);
  }

  // Special case: For naming variant 'hdbcds' in combination with 'toRename', 'forHana' must leave
  // namespaces alone (but must still flatten structs because we need the leaf element names).
  if (options.toRename.names === 'hdbcds') {
    options = mergeOptions(options, { forHana : { keepNamespaces: true } });
  }

  // FIXME: Currently, '--to-rename' implies transformation for HANA (transferring the options to forHana)
  let forHanaAugmented = transformForHana(model, mergeOptions(options, { forHana : options.toRename } ));

  // Assemble result
  let result = {
    rename : toRenameDdl(forHanaAugmented),
  };

  // Transfer warnings (errors would have resulted in an exception before we come here)
  if (forHanaAugmented.messages && forHanaAugmented.messages.length > 0) {
    result.messages = forHanaAugmented.messages;
  }
  return result;
}

// ----------- toCsn -----------

// Generate compact CSN for augmented CSN 'model'
// The following options control what is actually generated:
//   options : {
//     testMode     : if true, the result is extra-stable for automated tests (sorted, no 'version')
//     toCsn.flavor : if 'gensrc', the result CSN is only suitable for use as a source, e.g. for combination with
//                    additional extend/annotate statements, but not for consumption by clients or backends
//                    (default is to produce 'client' CSN with all properties propagated and inferred as required
//                    by consumers and backends)
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// Throws a CompilationError on errors.
function toCsn(model, options) {
  const { warning, signal } = alerts(model);
  // In case of API usage the options are in the 'options' argument
  // put the OData specific options under the 'options.toCsn' wrapper
  // and leave the rest under 'options'
  if (options && !options.toCsn) {
    _wrapRelevantOptionsForCmd(options, 'toCsn');
  }

  // Merge options with those from model
  options = mergeOptions({ toCsn : {} }, model.options, options);

  // Verify options
  optionProcessor.verifyOptions(options, 'toCsn').map(complaint => signal(warning`${complaint}`));

  return compactModel(model);
}

// Return a set of options containing the defaults that would be applied by the backends.
// Note that this only contains simple mergeable default values, not conditional defaults
// that depend in any way on other options (e.g. toSql provides 'src' if neither 'src' nor
// 'csn' is given: this is a conditional default).
function getDefaultBackendOptions() {
  return {
    toHana: {
      names : 'plain',
      associations: 'assocs',
    },
    toOdata: {
      version : 'v4',
      odataFormat: 'flat',
    },
    toRename: {
      names: 'hdbcds',
    },
    toSql: {
      names : 'plain',
      associations: 'joins',
      dialect: 'sqlite',
    },
  };
}

// Internal function moving command specific options under a command
// wrapper in the options object
function _wrapRelevantOptionsForCmd(options, command) {
  // take the command's specific options
  let cmdOptions = optionProcessor.camelOptionsForCommand(command);
  if (!options[command])
    options[command] = Object.create(null);
  for (let opt in options) {
    if (cmdOptions.includes(opt)) {
      Object.assign(options[command], { [opt]: options[opt] });
      delete options[opt];
    }
  }
}

module.exports = {
  toHana,
  toHanaWithCsn,
  toOdata,
  toOdataWithCsn,
  preparedCsnToEdmx,
  preparedCsnToEdmxAll,
  preparedCsnToEdm,
  preparedCsnToEdmAll,
  toCdl,
  toCdlWithCsn,
  toSwagger,
  toSql,
  toSqlWithCsn,
  toCsn,
  getDefaultBackendOptions,
  toRename,
}
