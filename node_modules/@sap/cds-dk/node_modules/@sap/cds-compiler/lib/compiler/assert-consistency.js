// Consistency checker on model (XSN = augmented CSN)

// Docs about XSN: internalDoc/IdeasModelChanges.md, internalDoc/Model.md (the
// latter is quite outdated).  The use of the XSN is PACKAGE-INTERNAL!  If you
// want to use it, you MUST contact us.
//
// The consistency check gives the consumer of XSN same safety of what values
// they can expect to see at certain places in the model.  It gives produces
// some safety that they have produced a consistent model.  That being said,
// the consistency check is work-in-progress.
//
// The consistency check is NOT A SYNTAX CHECK: it accepts invalid CDS models,
// it is usually not run in productive use, and its error message contains
// property names the user is not aware of.  It is considered an _internal
// error_ if the consistency check throws an error.

// A value in the model is one of:
//
// - Simple value: String, Boolean, Integer, null, undefined.
// - Dictionary: object without prototype - its property names are _user
//   defined_ and all property values have same "type" (example: elements).
// - Array: all items have same "type" (which is often a "union type").
// - Standard object: object with `Object.prototype` as prototype - its
//   property names are predefined (or at least their first char: `@` for
//   annotation assignments) and the value type depends on the property name.
// - Special object: currently just for the messages.
//
// The CENTRAL CHARACTERISTIC in XSN (as well as plain CSN) is: in ALL standard
// objects, the SAME PROPERTY NAME contains values of the SAME TYPE - we might
// restrict the value space in certain contexts, though.  Example: the value of
// a `type` property looks the same in objects for definitions or in the object
// which is the value of the `items` property.  TODO: check `technicalConfig`.

// The model is described by a schema which specifies the type for all property
// names in standard objects.  Such a type can be a "union type", e.g. can
// allow a simple value or array.  This is done by a assert function in
// property `test` of a properties' specification in the schema.  The test
// function can use other properties in the specification.  If no such function
// is specified, it uses function `standard` which checks for a standard
// objects with:
//
// - Certain required sub properties whose names are listed in the array value
//   of `requires` in the specification.  This can be loosened: by default, no
//   property is required with syntax errors (overwritten by `isRequired`).
// - Optional sub properties are listed in `optional`, which can also be a
//   function returning true if the property is allowed.
//
// The above mentioned restriction of the value space in certain contexts can
// be specified by a property `schema` of the properties' specification in the
// schema.  With it, direct sub properties are checked against that
// specification.  Specifications can also inherit properties from other
// specifications by using the name as value of `inherits` in the
// specification.

// The consistency check also checks the following conventions for names in
// standard objects:
//
// - A property is non-enumerable if and only if its name starts with `_`.
//   This convention can be overwritten by `enumerable` of the properties'
//   specification in the schema.  Such properties should be used for "links"
//   to other nodes in the model.
// - A property must not be produced by a parser if its name starts with `_` or
//   `$`.  This convention can be overwritten by `parser` of the properties'
//   specification in the schema.  Such properties must not be used for links,
//   and should be used for information which does not make it into plain CSN.

'use strict';

const { locationString, hasErrors } = require('../base/messages');
const { queryOps } = require('../base/model');

function assertConsistency( model, stage ) {
  const stageParser = typeof stage === 'object';
  const options = stageParser && stage || model.options || { testMode: true };
  if (!options.testMode || options.parseOnly && !stageParser)
    return;

  const schema = {
    ':model': {                 // top-level from compiler
      requires: [ 'options', 'definitions', 'sources' ],
      optional: [
        'messages',
        'extensions',
        'version', '$version',  // version without --test-mode
        'meta',
        '$magicVariables',
        '$builtins',
        '$internal',
        '$compositionTargets',
        '$lateExtensions',
        '_entities', '$entity',
        '$newfeatures',
      ],
    },
    ':parser': {                // top-level from parser
      requires: [ '$frontend' ],
      optional: [
        'messages', 'options', 'definitions', 'extensions',
        'artifacts', 'artifacts_', 'namespace', 'usings', // CDL parser
        'filename', 'dirname',  // TODO: move filename into a normal location? Only in model.sources
        'dependencies',         // for USING..FROM
        'kind',                 // TODO: remove from parser
        'meta',
        '@sql_mapping',         // TODO: it is time that a 'header' attribute replaces 'version'
        '$withLocalized',
      ],
    },
    location: {                 // location req if at least one property:
      isRequired: parent => noSyntaxErrors() || Object.keys( parent ).length,
      requires: [ 'filename', 'start' ],
      optional: [ 'end', '$weak', '$notFound' ],
      schema: {
        start: {
          requires: [ 'line', 'column' ],
          optional: [ 'offset' ],
          schema: {
            line: { test: isNumber },
            column: { test: isNumber },
            offset: { test: isNumber },
          },
        },
        end: {
          requires: [ 'line', 'column' ],
          optional: [ 'offset' ],
          schema: {
            line: { test: isNumber },
            column: { test: isNumber },
            offset: { test: isNumber },
          },
        },
        $weak: { test: isBoolean, parser: true },
        $notFound: { test: isBoolean },
      },
    },
    sources: { test: isDictionary( isObject ) },
    filename: { test: isString },
    dirname: { test: isString },
    realname: { test: isString },
    dependencies: {
      test: isArray(),
      requires: [ 'literal', 'location', 'val' ],
    },
    fileDep: { test: TODO },
    $frontend: { parser: true, test: isString, enum: [ 'cdl', 'json', 'xml' ] },
    $newfeatures: { test: TODO }, // if new features have been used which break the old backends
    messages: {
      enumerable: () => true,  // does not matter (non-enum std), enum in CSN/XML parser
      test: isArray( TODO ),
    },
    options: { test: TODO },              // TODO: check option object
    definitions: {
      test: isDictionary( definition ),
      requires: [ 'kind', 'location', 'name' ],
      optional: thoseWithKind,
    },
    extensions: {
      kind: [ 'context' ],        // syntax error (as opposed to HANA CDS), but still there
      inherits: 'definitions',
      test: isArray(),
      schema: { name: { inherits: 'name', isRequired: noSyntaxErrors } },
      // name is required in parser, too
    },
    _localized: { kind: true, test: TODO }, // true or artifact
    _assocSources: { kind: true, test: TODO }, // just null: isArray( inDefinitions ) during resolve
    $magicVariables: {
      // $magicVariables contains "builtin" artifacts that differ from
      // "normal artifacts" and therefore have a custom schema
      requires: [ 'kind', 'artifacts' ],
      schema: {
        kind: { test: isString, enum: [ '$magicVariables' ] },
        artifacts: {
          // Do not use "normal" definitions spec because of these artifacts
          // are missing the location property
          test: isDictionary( definition ),
          requires: [ 'kind', 'name' ],
          optional: [ 'elements', '$autoElement', '_finalType', '_deps' ],
          schema: {
            kind: { test: isString, enum: [ 'builtin' ] },
            name: { test: isObject, requires: [ 'id', 'element' ] },
            $autoElement: { test: isString },
            // missing location for normal "elements"
            elements: { test: TODO },
          },
        },
      },
    },
    $builtins: { test: TODO },
    builtin: { kind: true, test: builtin },
    $internal: {
      test: standard,
      requires: [ '$frontend' ],
      schema: {
        $frontend: { test: isString, enum: [ '$internal' ] },
      },
    },
    version: { test: TODO }, // TODO: describe - better: 'header'
    $version: { test: isString },
    meta: { test: TODO }, // never tested due to --test-mode
    namespace: {
      test: (model.$frontend !== 'json') ? standard : TODO,
      // TODO: the JSON parser should augment 'namespace' correctly or better: hide it
      requires: [ 'location' ],
      optional: [ 'path', 'dcPath' ],  // dcPath with --hana-flavor
    },
    usings: {
      test: isArray(),
      requires: [ 'kind', 'location' ],
      optional: [ 'name', 'extern', 'usings', 'annotationAssignments', 'fileDep' ],
      // TODO: get rid of annotationAssignments: []
    },
    extern: {
      requires: [ 'location', 'path' ],
      optional: [ 'dcPath' ],
      schema: { path: { inherits: 'path', optional: [ 'quoted' ] } },
    },
    dcPath: { inherits: 'path', optional: [ 'quoted' ] },
    elements: { kind: true, inherits: 'definitions' },
    elements$: { kind: true, enumerable: false, test: TODO },
    // TODO: introduce real "specified elements" instead
    elements_: { kind: true, parser: true, test: TODO }, // TODO: remove
    _elementsIndexNo: { kind: true, parser: true, test: TODO }, // TODO: remove
    actions: { kind: true, inherits: 'definitions' },
    actions_: { kind: true, parser: true, test: TODO }, // TODO: remove
    enum: { kind: true, inherits: 'definitions' },
    enum_: { kind: true, parser: true, test: TODO }, // TODO: remove
    foreignKeys: { kind: true, inherits: 'definitions' },
    $keysNavigation: { kind: true, test: TODO },
    foreignKeys_: { kind: true, parser: true, test: TODO }, // TODO: remove
    _foreignKeysIndexNo: { kind: true, parser: true, test: TODO }, // TODO: remove
    params: { kind: true, inherits: 'definitions' },
    params_: { kind: true, parser: true, test: TODO }, // TODO: remove
    _paramsIndexNo: { kind: true, parser: true, test: TODO }, // TODO: remove
    mixin: { inherits: 'definitions' },
    query: {
      kind: true,
      test: query,              // properties below are "sub specifications"
      union: {
        schema: { args: { inherits: 'query', test: isArray( query ) } },
        requires: [ 'op', 'location', 'args' ],
        optional: [
          'name', 'quantifier', 'orderBy', 'limit', 'offset', '_leadingQuery',
          'name', 'kind', '_parent', '_main', '_finalType', '$navigation', // in FROM
        ],
      },
      select: {                   // sub query
        requires: [ 'op', 'location', 'from' ],
        optional: [
          '_tableAlias',        // for sub query in FROM
          'name', 'quantifier', 'mixin', 'exclude', 'columns', 'elements', '_deps',
          'where', 'groupBy', 'having', 'orderBy', '$orderBy', 'limit', 'offset',
          '_elementsIndexNo', '_projections', '_block', '_parent', '_main', '_finalType',
          '$tableAliases', 'kind', '_firstAliasInFrom', 'queries', '_$next', '$combined',
          '$dictOrderBy',
        ],
      },
      none: { optional: () => true }, // parse error
    },
    from: {
      inherits: 'query',
      test: isArray( query ), // TODO: not array
      op: {                                      // join
        schema: { args: { inherits: 'from', test: isArray( query ) } },
        requires: [ 'op', 'location', 'args', 'join' ],
        optional: [
          'on', 'kind', 'name',
          '$tableAliases', 'queries', '$combined',
          '_block', '_parent', '_main', '_leadingQuery', '_$next', '_deps',
        ],
      },
      path: {
        requires: [ 'location', 'path' ],
        optional: [
          'name', '_tableAlias', '_status', // TODO: only in from
          'scope', '_artifact', '$inferred', // TODO: remove the rest
        ],
      },
    },
    columns: {
      kind: [ 'extend' ],
      inherits: 'definitions',
      test: isArray( column ),
      enum: [ '*' ],
      requires: [ 'location' ],
      // schema: { kind: { isRequired: () => {} } } // kind not required
    },
    exclude: {                          // TODO: -> excluding, re-think structure
      test: isDictionary( definition ), // definition since redef
      requires: [ 'location', 'name' ],
      optional: [ 'annotationAssignments' ], // TODO: get rid of annos: []
    },
    orderBy: {
      test: isArray(),
      requires: [ 'value' ],
      optional: [ 'location', 'sort', 'nulls', '_$queryNode' ],
    },
    sort: { test: locationVal( isString ), enum: [ 'asc', 'desc' ] },
    nulls: { test: locationVal( isString ), enum: [ 'first', 'last' ] },
    $orderBy: { inherits: 'orderBy' },
    _$queryNode: { test: TODO }, // TODO: remove
    $dictOrderBy: { test: TODO },
    groupBy: { inherits: 'value', test: isArray( expression ) },
    limit: { inherits: 'value' },
    offset: { inherits: 'value' },
    $combined: { test: TODO },
    _typeIsExplicit: {
      kind: true,
      enumerable: true,
      parser: true,
      test: TODO,
    }, // TODO: remove
    type: {
      kind: true,
      requires: [ 'location', 'path' ],
      optional: [
        'scope', '_artifact', '$inferred', // TODO: remove the rest
        'calculated',                    // TODO: remove calculated
      ],
    },
    targetAspect: {
      kind: true,
      requires: [ 'location' ],
      optional: [
        'path', 'elements', '_elementsIndexNo', '_outer',
        'scope', '_artifact', '$inferred', // TODO: remove the rest
        'calculated',                    // TODO: remove calculated
      ],
    },
    target: {
      kind: true,
      requires: [ 'location' ],
      optional: [
        'path', 'elements', '_elementsIndexNo', '_outer',
        'scope', '_artifact', '$inferred', // TODO: remove the rest
        'calculated',                    // TODO: remove calculated
      ],
    },
    path: {
      test: isArray( pathItem ),
      requires: [ 'location', 'id' ], // TODO: it can be `func` instead of `id` later
      // TODO: rename namedArgs to args
      optional: [
        'quoted',               // TODO remove?
        'args', 'namedArgs',
        'where', 'cardinality',
        '_artifact', '_navigation',
        '$inferred',
      ],
    },
    id: { test: isString },
    quoted: { test: isBoolean },
    scope: { test: isScope }, // TODO: clarify where scope can occur
    func: { test: TODO },  // TODO: change structure
    kind: {
      isRequired: !stageParser && (() => true),
      // required to be set by Core Compiler even with parse errors
      test: isString,
      enum: [
        'context', 'service', 'view', 'entity', 'type', 'const', 'annotation',
        'element', 'enum', 'action', 'function', 'param', 'key', 'event',
        'annotate', 'extend',
        'query', 'mixin',
        'source', 'namespace', 'using',
        '$tableAlias',
      ],
    },
    $syntax: {
      parser: true,
      kind: [ 'entity', 'view', 'type' ],
      test: isString,            // CSN parser should check for 'entity', 'view', 'projection'
    },
    value: {
      kind: true,
      test: expression,         // properties below are "sub specifications"
      ref: { inherits: 'type' },
      none: { optional: [ 'location' ] },
      // TODO: why optional / enough in name?
      // TODO: "yes" instead "none": val: true, optional literal/location
      val: {
        requires: [ 'literal', 'location' ],
        // TODO: remove augmented, rename symbol to sym
        // TODO: struct only for annotation assignments
        optional: [ 'val', 'symbol', 'name', '$inferred', 'augmented' ],
      },
      op: {
        schema: { args: { inherits: 'args', args: 'positional' } },
        requires: [ 'op', 'location' ],
        optional: [
          'args', 'namedArgs',
          'func',
          'quantifier',
          '$inferred', 'augmented', // TODO: remove augmented
          '_artifact',          // _artifact with "localized data"s 'coalesce'
        ],
      },
      query: { inherits: 'query' },
    },
    literal: {                  // TODO: check value against literal
      test: isString,
      enum: [
        'string', 'number', 'boolean', 'hex',
        'time', 'date', 'timestamp',
        'struct', 'array', 'enum', 'null', 'token',
      ],
    },
    symbol: { requires: [ 'location', 'id' ], optional: [ 'quoted', 'augmented' ] },
    val: {
      test: isVal,              // the following for array/struct value
      requires: [ 'location' ],
      optional: [ 'literal', 'val', 'symbol', 'struct', 'path', 'name', 'augmented', '$duplicate' ],
      // TODO: restrict path to #simplePath
    },
    struct: { inherits: 'val', test: isDictionary( definition ) }, // def because double @
    args: { inherits: 'value', test: args },
    namedArgs: { inherits: 'value', optional: [ 'name', '$duplicate' ], test: args },
    onCond: { kind: true, inherits: 'value' },
    on: { kind: true, inherits: 'value', test: expressionOrString },
    // TODO: rename 'onCond' to 'on', remove 'on'
    where: { inherits: 'value' },
    having: { inherits: 'value' },
    op: { test: locationVal( isString ) },
    join: { test: isString },
    quantifier: { test: locationVal( isString ) },
    augmented: { enumerable: false, test: TODO }, // FIXME: remove
    // preliminary -----------------------------------------------------------
    doc: { kind: true, test: locationVal( isStringOrNull ) }, // doc comment
    '@': {
      kind: true,
      inherits: 'value',
      optional: [ 'name', '_block', 'priority', '$duplicate', '$inferred' ],
      // TODO: name requires if not in parser?
    },
    priority: { test: TODO }, // TODO: rename to $priority
    annotationAssignments: { kind: true, test: TODO }, // TODO: rename to $assignments
    name: {
      isRequired: stageParser && (() => false), // not required in parser
      kind: true,
      schema: {
        query: { test: TODO },
        $mixin: { test: TODO },
      }, // TODO: rename query prop in name, delete $mixin
      requires: [ 'location' ],
      optional: [
        'path', 'id', 'quoted', 'variant', // TODO: req path, opt id for main, req id for member
        '$mixin',                        // TODO: delete, use kind = 'mixin'
        '_artifact', '$inferred',
        'calculated',                    // TODO: remove calculated
        'absolute', 'element', 'alias', 'query', 'action', 'param',
      ],
    },
    absolute: { test: isString },
    variant: { test: TODO }, // TODO: not set in CDL parser, only in annotationAssignment
    element: { test: TODO }, // TODO: { test: isString },
    action: { test: isString },
    param: { test: isString },
    alias: { test: isString },
    expectedKind: { kind: [ 'extend' ], inherits: 'kind' },
    abstract: { kind: true, test: locationVal() },
    virtual: { kind: true, test: locationVal() },
    key: { kind: true, test: locationVal(), also: [ null, undefined ] },
    masked: { kind: true, test: locationVal() },
    notNull: { kind: true, test: locationVal() },
    includes: { kind: true, inherits: 'type', test: isArray() },
    returns: {
      kind: [ 'action', 'function' ],
      requires: [ 'location' ],
      optional: [
        'type', 'typeArguments', 'length', 'precision', 'scale', 'srid', 'enum',
        'elements', 'cardinality', 'target', 'on', 'onCond', 'foreignKeys', 'items',
        '_outer', '_finalType', 'notNull',
        'elements_', '_elementsIndexNo', '$syntax', // TODO: remove
      ],
    },
    items: { kind: true, inherits: 'returns' }, // yes, also optional 'items'
    dbType: { kind: true, test: locationVal() },
    source: { kind: true, test: TODO }, // TODO: remove in JSON/CDL parser - only in old
    projection: { kind: true, test: TODO }, // TODO: remove in JSON/CDL parser
    technicalConfig: { enumerable: () => true, kind: [ 'entity' ], test: TODO }, // TODO: some spec
    sequenceOptions: { kind: true, test: TODO }, // hanaFlavor
    targetElement: { kind: true, inherits: 'type' },   // for foreign keys
    indexNo: { kind: true, test: TODO },         // TODO: remove
    artifacts: { kind: true, inherits: 'definitions', test: isDictionary( inDefinitions ) },
    artifacts_: { kind: true, parser: true, test: TODO }, // TODO: remove
    blocks: { kind: true, test: TODO },    // TODO: make it $blocks ?
    length: { kind: true, inherits: 'value' }, // for number is to be checked in resolver
    precision: { kind: true, inherits: 'value' },
    scale: { kind: true, inherits: 'value' },
    srid: { kind: true, inherits: 'value' },
    localized: { kind: true, test: locationVal() },
    cardinality: {
      kind: true,
      requires: [ 'location' ],
      optional: [ 'sourceMax', 'targetMin', 'targetMax' ],
    },
    sourceMax: { test: locationVal( isNumber ), also: [ '*' ] },
    targetMin: { test: locationVal( isNumber ) },
    targetMax: { test: locationVal( isNumber ), also: [ '*' ] },
    default: { kind: true, inherits: 'value' },
    typeArguments: { kind: true, test: TODO }, // TODO $typeArgs: only in CDL parser or w errors
    $tableAliases: { kind: true, test: TODO }, // containing $self outside queries
    _block: { kind: true, test: TODO },
    _parent: { kind: true, test: TODO },
    _service: { kind: true, test: TODO },
    _main: { kind: true, test: TODO },
    _artifact: { test: TODO },
    _base: { test: TODO, kind: true },
    _navigation: { test: TODO },
    _finalType: { kind: true, test: TODO },
    _tableAlias: { test: TODO },
    _firstAliasInFrom: { test: TODO },
    _outer: { test: TODO },              // for returns/items
    queries: { kind: true, test: TODO }, // TODO: $queries with other structure
    $queries: {
      kind: [ 'entity', 'view' ],
      test: isArray(),
      requires: [
        'kind', 'location', 'name',
        '_parent', '_main', '_$next', '_block',
        // query specific
        'op', 'from', 'elements',
        '$combined',
        '$tableAliases', '_firstAliasInFrom',
        'queries', // TODO: deprecated?
      ],
      optional: [
        '_finalType',
        '_deps',
        // query specific
        'where', 'columns', 'mixin', 'quantifier', 'offset',
        'orderBy', '$orderBy', 'groupBy', 'exclude', 'having',
        'limit', '_tableAlias', '_elementsIndexNo',
      ],
    },
    _leadingQuery: { kind: true, test: TODO },
    $navigation: { kind: true, test: TODO },
    $replacement: { kind: true, test: TODO }, // for smart * in queries
    origin: { kind: true, test: TODO }, // TODO: define some _origin
    _origin: { kind: [ 'entity' ], test: TODO }, // origin composition aspect for entity
    $from: { kind: true, test: TODO }, // all table refs necesary to compute elements
    _redirected: { kind: true, test: TODO }, // for REDIRECTED TO:
    // ...array of table aliases for targets from orig to new
    _$next: { kind: true, test: TODO }, // next lexical search environment for values
    _extend: { kind: true, test: TODO }, // for collecting extend/annotate on artifact
    _annotate: { kind: true, test: TODO }, // for collecting extend/annotate on artifact
    _extension: { kind: true, test: TODO }, // on artifact to its "super extend/annotate" statement
    _deps: { kind: true, test: TODO },      // for cyclic calculation
    _xref: { kind: true, test: TODO },
    _scc: { kind: true, test: TODO },       // for cyclic calculation
    _sccCaller: { kind: true, test: TODO }, // for cyclic calculation
    _status: { kind: true, test: TODO },    // TODO: $status
    _projections: { kind: true, test: TODO }, // for mixin definitions
    $entity: { kind: true, test: TODO },
    _entities: { test: TODO },
    $compositionTargets: { test: isDictionary( isBoolean ) },
    $lateExtensions: { test: TODO },
    _upperAspects: { kind: [ 'type', 'entity', 'view' ], test: isArray( TODO ) },
    _ancestors: { kind: [ 'type', 'entity', 'view' ], test: isArray( TODO ) },
    _descendants: { kind: [ 'entity', 'view' ], test: isDictionary( isArray( TODO ) ) },
    $duplicate: { parser: true, kind: true, test: isBoolean },
    $extension: { kind: true, test: TODO }, // TODO: introduce $applied instead or $status
    $inferred: { parser: true, kind: true, test: isString },
    $autoexpose: { kind: [ 'entity' ], test: isBoolean, also: [ null, 'Composition' ] },
    _ignore: { kind: true, enumerable: true, test: TODO },    // TODO: rename to $ignore/$delete
    calculated: { kind: true, test: TODO }, // TODO remove
    viaAll: { kind: true, test: TODO },     // TODO remove
    implicitForeignKeys: { kind: true, test: TODO }, // TODO: do it with $inferred with object value
    redirected: { kind: true, test: TODO }, // TODO: do it with not-$inferred
    $extra: { parser: true, test: TODO },   // for unexpectex properties in CSN
    $withLocalized: { test: isBoolean },
  };
  let _noSyntaxErrors = null;
  assertProp( model, null, stageParser ? ':parser' : ':model', null, true );
  return;

  function noSyntaxErrors() {
    if (_noSyntaxErrors == null)
      _noSyntaxErrors = !hasErrors( options.messages || model.messages ); // TODO: check messageId?
    return _noSyntaxErrors;
  }

  function assertProp( node, parent, prop, extraSpec, noPropertyTest ) {
    let spec = extraSpec || schema[prop] || schema[prop.charAt(0)];
    if (!spec)
      throw new Error( `Property '${ prop }' has not been specified`);
    spec = inheritSpec( spec );

    if (!noPropertyTest) {
      const char = prop.charAt(0);
      const parser = ('parser' in spec) ? spec.parser : char !== '_' && char !== '$';
      if (stageParser && !parser)
        throw new Error( `Non-parser property '${ prop }' set by ${ model.$frontend || '' } parser${ at( [ node, parent ] ) }` );
      const enumerable = ('enumerable' in spec) ? spec.enumerable : char !== '_';
      if (enumerable instanceof Function
          ? !enumerable( parent, prop )
          : {}.propertyIsEnumerable.call( parent, prop ) !== enumerable)
        throw new Error( `Unexpected enumerability ${ !enumerable }${ at( [ node, parent ], prop ) }` );
    }
    (spec.test || standard)( node, parent, prop, spec,
                             typeof noPropertyTest === 'string' && noPropertyTest );
  }

  function definition( node, parent, prop, spec, name ) {
    if (!(node instanceof Array))
      node = [ node ];
    // TODO: else check that there is a redefinition error
    for (const art of node)
      standard( art, parent, prop, spec, name );
  }

  /**
   * `builtin` property that is set in the definer. Must only be used for `cds`
   * and `localized` namespaces.
   */
  function builtin( node, parent, prop, spec, name ) {
    if (![ 'string', 'boolean' ].includes(typeof node))
      throw new Error(`Property '${ prop }' must be a boolean or string but was '${ typeof node }'${ at( [ node, parent ], prop, name ) }` );

    if (parent.kind !== 'namespace')
      throw new Error(`Property '${ prop }' must be inside artifact that is a namespace but was '${ parent.kind }'${ at( [ node, parent ], prop, name ) }` );

    const parentName = parent.name && parent.name.absolute;
    if (parentName !== 'cds' && parentName !== 'localized')
      throw new Error(`Property '${ prop }' must be inside namespace 'cds' or 'localized' but was '${ parentName }'${ at( [ node, parent ], prop, name ) }` );
  }

  function column( node, ...rest ) {
    if (node.val)
      locationVal( isString )( node, ...rest );
    else if (stageParser)
      standard( node, ...rest );
    else
      isObject( node, ...rest ); // TODO: and inside elements
  }

  function pathItem( node, ...rest ) {
    if (node !== null || noSyntaxErrors())
      standard( node, ...rest );
  }

  function standard( node, parent, prop, spec, name ) {
    isObject( node, parent, prop, spec, name );

    const names = Object.getOwnPropertyNames( node );
    const requires = spec.requires || [];
    // Do not test 'requires' with parse errors:
    for (const p of requires) {
      if (!names.includes(p)) {
        const req = spec.schema && spec.schema[p] && spec.schema[p].isRequired;
        if ((req || schema[p] && schema[p].isRequired || noSyntaxErrors)( node ))
          throw new Error( `Required property '${ p }' missing in object${ at( [ node, parent ], prop, name ) }` );
      }
    }
    const optional = spec.optional || [];
    for (const n of names) {
      const opt = (optional instanceof Array)
        ? optional.includes( n ) || optional.includes( n.charAt(0) )
        : optional( n, spec );
      if (!(opt || requires.includes( n ) || n === '$extra'))
        throw new Error( `Property '${ n }' is not expected${ at( [ node[n], node, parent ], prop, name ) }` );

      assertProp( node[n], node, n, spec.schema && spec.schema[n] );
    }
  }

  function thoseWithKind( prop, spec ) {
    const those = spec.schema && spec.schema[prop] || schema[prop] || schema[prop.charAt(0)];
    return those && those.kind;
  }

  function query( node, parent, prop, spec, idx ) {
    while (node instanceof Array) {
      if (node.length !== 1)
        throw new Error( `Unexpected length ${ node.length } for query expression${ at( [ node, parent ], prop, idx ) }` );
      // TODO: also check getOwnPropertyNames(node)
      [ node ] = node;
    }
    // select from <EOF> produces from: [null]
    if (node !== null || noSyntaxErrors()) {
      isObject( node, parent, prop, spec, idx );

      // eslint-disable-next-line no-nested-ternary
      const op = node.op && node.op.val   // NOSONAR (isObject ensures that node.op does not throw)
        ? (queryOps[node.op.val] || 'op')
        : (node.path) ? 'path' : 'none';
      if (spec[op])
        assertProp( node, parent, prop, spec[op], op );
      else
        throw new Error( `No specification for computed variant '${ op }'${ at( [ node, parent ], prop, idx ) }` );
    }
  }

  function inheritSpec( spec ) {
    if (!spec.inherits)
      return spec;
    const chain = [ spec ];
    while (spec.inherits) {
      spec = schema[spec.inherits];
      chain.push( spec );
    }
    chain.reverse();
    return Object.assign( {}, ...chain );
  }

  function expressionOrString( node, ...rest ) { // TODO: remove with onCond
    if (typeof node !== 'string')
      expression( node, ...rest );
  }

  function expression( node, parent, prop, spec, idx ) {
    // TODO CSN parser?: { val: <token>, literal: 'token' } for keywords
    if (typeof node === 'string')
      return;
    while (node instanceof Array) {
      // TODO: also check getOwnPropertyNames(node)
      if (node.length !== 1) {
        node.forEach( n => expression( n, parent, prop, spec ) );
        return;
      }
      [ node ] = node;
    }
    if (node == null && !noSyntaxErrors())
      return;
    isObject( node, parent, prop, spec, idx );

    const s = spec[expressionSpec(node)] || {};
    const sub = Object.assign( {}, s.inherits && schema[s.inherits], s );
    if (spec.requires && sub.requires)
      sub.requires = [ ...sub.requires, ...spec.requires ];
    if (spec.optional && sub.optional)
      sub.optional = [ ...sub.optional, ...spec.optional ];
    // console.log(expressionSpec(node) );
    (sub.test || standard)( node, parent, prop, sub, idx );
  }

  function expressionSpec( node ) {
    if (node.path)
      return 'ref';
    else if (node.literal || node.val)
      return 'val';
    else if (!node.op)
      return 'none';
    else if (typeof node.op.val === 'string' && queryOps[node.op.val])
      return 'query';
    return 'op';
  }

  function args( node, parent, prop, spec ) {
    if (node instanceof Array) {
      if (parent.op && parent.op.val === 'xpr') // remove keywords for `xpr` expressions
        node = node.filter( a => typeof a !== 'string');
      node.forEach( (item, idx) => expression( item, parent, prop, spec, idx ) );
    }
    else if (spec.args === 'positional') {
      throw new Error( `Expected array${ at( [ null, parent ], prop ) }` );
    }
    else if (node && typeof node === 'object' && !Object.getPrototypeOf( node )) {
      for (const n in node)
        expression( node[n], parent, prop, spec, n );
    }
    else {
      throw new Error( `Expected array or dictionary${ at( [ null, parent ], prop ) }` );
    }
  }

  function at( nodes, prop, name ) {
    const n = name && (typeof name === 'number' ? ` for index ${ name }` : ` for "${ name }"`);
    const loc = nodes.find( o => o && typeof o === 'object' && (o.location || o.start) );
    const f = (prop) ? `${ n || '' } in property '${ prop }'` : n;
    const l = loc && locationString( loc.location || loc ) || model.filename;
    return (!l) ? f : `${ f } at ${ l }`;
  }

  function isDictionary( func ) {
    return function dictionary( node, parent, prop, spec ) {
      // if (!node || typeof node !== 'object' || Object.getPrototypeOf( node ))
      //   console.log(node,prop,model.$frontend)
      if (!node || typeof node !== 'object' || Object.getPrototypeOf( node ))
        throw new Error( `Expected dictionary${ at( [ null, parent ], prop ) }` );
      for (const n in node)
        func( node[n], parent, prop, spec, n );
    };
  }

  function isArray( func = standard ) {
    return function vector( node, parent, prop, spec ) {
      if (!(node instanceof Array))
        throw new Error( `Expected array${ at( [ null, parent ], prop ) }` );
      node.forEach( (item, n) => func( item, parent, prop, spec, n ) );
    };
  }

  function locationVal( func = isBoolean ) {
    return function valWithLocation( node, parent, prop, spec, name ) {
      const valSchema = { val: Object.assign( {}, spec, { test: func } ) };
      const requires = [ 'val', 'location' ];
      const optional = [ 'literal', '$inferred', 'augmented' ]; // TODO: remove augmented
      standard( node, parent, prop, { schema: valSchema, requires, optional }, name );
    };
  }

  function isBoolean( node, parent, prop, spec ) {
    if ((spec.also) ? spec.also.includes( node ) : (node === null))
      return;
    if (typeof node !== 'boolean')
      throw new Error( `Expected boolean or null${ at( [ node, parent ], prop ) }` );
  }

  function isNumber( node, parent, prop, spec ) {
    if (spec.also && spec.also.includes( node ))
      return;
    if (typeof node !== 'number')
      throw new Error( `Expected number${ at( [ node, parent ], prop ) }` );
  }

  function isStringOrNull( node, parent, prop, spec ) {
    if (node !== null)
      isString(node, parent, prop, spec);
  }

  function isString( node, parent, prop, spec ) {
    if (typeof node !== 'string')
      throw new Error( `Expected string${ at( [ node, parent ], prop ) }` );
      // TODO: also check getOwnPropertyNames(node)
    if (spec.enum && !spec.enum.includes( node ))
      throw new Error( `Unexpected value '${ node }'${ at( [ node, parent ], prop ) }` );
  }

  function isVal( node, parent, prop, spec ) {
    if (node instanceof Array)
      node.forEach( (item, n) => standard( item, parent, prop, spec, n ) );
    else if (node !== null && ![ 'string', 'number', 'boolean' ].includes( typeof node ))
      throw new Error( `Expected array or simple value${ at( [ null, parent ], prop ) }` );
  }

  function isObject( node, parent, prop, spec, name ) {
    if (!node || typeof node !== 'object' || Object.getPrototypeOf( node ) !== Object.prototype)
      throw new Error( `Expected standard object${ at( [ null, parent ], prop, name ) }` );
  }

  function inDefinitions( art, parent, prop, spec, name ) {
    if (art instanceof Array)   // do not check with redefinitions
      return;
    isObject( art, parent, prop, spec, name );
    if (stageParser) {
      if (prop === 'artifacts')
        standard( art, parent, prop, spec, name );
    }
    else if (!art.name.absolute || !model.definitions[art.name.absolute]) {
      // TODO: sign ignored artifacts with $inferred = 'IGNORED'
      if (parent.kind === 'source' ||
          art.name.absolute && art.name.absolute.startsWith('localized.'))
        standard( art, parent, prop, spec, name );
      else
        throw new Error( `Expected definition${ at( [ art, parent ], prop, name ) }` );
    }
  }

  function isScope(node, parent, prop) {
    // artifact refs in CDL have scope:0 in XSN
    if (Number.isInteger(node))
      return;
    const validValues = [ 'typeOf', 'global', 'param' ];
    if (!validValues.includes(node))
      throw new Error( `Property '${ prop }' must be either "${ validValues.join('", "') }" or a number but was "${ node }"` );
  }

  function TODO() {}
}

module.exports = assertConsistency;
