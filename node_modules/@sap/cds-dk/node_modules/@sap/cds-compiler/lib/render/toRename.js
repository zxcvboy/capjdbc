
'use strict';

const { CompilationError, hasErrors, sortMessages } = require('../base/messages');
const { mergeOptions, getTopLevelArtifactNameOf, getParentNameOf, getParentNamesOf } = require('../model/modelUtils');
const { compactModel } = require('../json/to-csn');

// Render the augmented CSN 'model' to SQL DDL statements renaming existing tables and their
// columns so that they match the result of "toHana" or "toSql" with the 'plain' option for names.
// Expects the naming convention of the existing tables to be either 'quoted' or 'hdbcds' (default).
// The following options control what is actually generated:
//   options : {
//     toRename.names      :  existing names, either 'quoted' or 'hdbcds' (default)
//   }
// Return a dictionary of top-level artifacts by their names, like this:
// { "foo" : "RENAME TABLE \"foo\" ...",
//   "bar::wiz" : "RENAME VIEW \"bar::wiz\" ..."
// }
function toRenameDdl(model, options) {
  // Merge options (arguments first, then model options and default)
  options = mergeOptions({toRename: {names: 'hdbcds'}}, model.options, options);
  let result = Object.create(null);

  // FIXME: Currently requires 'options.forHana', because it requires the 'forHana' transformations
  if (!options.forHana) {
    throw new Error('toRenameDdl can currently only be used with HANA preprocessing');
  }

  // FIXME: This should happen in the caller
  let csn = compactModel(model);

  // Create artificial namespace objects, so that each artifact has parents up to top-level.
  // FIXME: This is actually only necessary to make 'getParentNameOf' work - should be reworked
  for (let artifactName in csn.definitions) {
    for (let parentName of getParentNamesOf(artifactName)) {
      if (!csn.definitions[parentName]) {
        csn.definitions[parentName] = {
          kind : 'namespace',
        };
      }
    }
  }

  // Render each artifact on its own
  for (let artifactName in csn.definitions) {
    let sourceStr = renameTableAndColumns(artifactName, csn.definitions[artifactName]);

    if (sourceStr !== '') {
      result[artifactName] = sourceStr;
    }
  }
  // Throw exception in case of errors
  if (hasErrors(model.messages)) {
    throw new CompilationError(sortMessages(model.messages), model);
  }
  return result;

  // If 'art' is a non-view entity, generate SQL statements to rename the corresponding
  // table and its columns from the naming conventions given in 'options.toRename.name'
  // (either 'quoted' or 'hdbcds') to 'plain'. In addition, drop any existing associations
  // from the columns (they would likely become invalid anyway).
  // Do not rename anything if the names are identical.
  function renameTableAndColumns(artifactName, art) {
    let resultStr = '';
    if (art.kind === 'entity' && !art.query) {
      let beforeTableName = quoteSqlId(absoluteCdsName(artifactName));
      let afterTableName = plainSqlId(artifactName);

      if (beforeTableName != afterTableName) {
        resultStr += "  EXEC 'RENAME TABLE " + beforeTableName + ' TO ' + afterTableName + "';\n";
      }

      resultStr += Object.keys(art.elements).map(name => {
        let e = art.elements[name];
        let result = '';

        let beforeColumnName = quoteSqlId(name);
        let afterColumnName = plainSqlId(name);

        if (!e._ignore) {
          if (e.target) {
            resultStr += ' ';
            result = "  EXEC 'ALTER TABLE " + afterTableName + ' DROP ASSOCIATION ' + beforeColumnName + "';\n";
          }
          else if (beforeColumnName != afterColumnName) {
            resultStr += ' ';
            result = "    EXEC 'RENAME COLUMN " +  afterTableName + '.' + beforeColumnName + ' TO ' + afterColumnName + "';\n";
          }
        }
        return result;
      }).join('');
    }
    return resultStr;
  }

  // Return 'name' in the form of an absolute CDS name - for the 'hdbcds' naming convention,
  // this means converting '.' to '::' on the border between namespace and top-level artifact.
  // For all other naming conventions, this is a no-op.
  function absoluteCdsName(name) {
    if (options.toRename.names !== 'hdbcds') {
      return name;
    }
    let topLevelName = getTopLevelArtifactNameOf(name, csn);
    let namespaceName = getParentNameOf(topLevelName);
    if (namespaceName) {
      return `${namespaceName}::${name.substring(namespaceName.length + 1)}`;
    }
    return name;
  }

  // Return 'name' with appropriate "-quotes, also replacing '::' by '.' if 'options.toRename.names'
  // is 'quoted'
  function quoteSqlId(name) {
    if (options.toRename.names === 'quoted') {
      name = name.replace(/::/g, '.');
    }
    return '"' + name.replace(/"/g, '""') + '"';
  }

  // Return 'name' with uppercasing and appropriate "-quotes, also replacing '::' and '.' by '_'
  // (to be used by 'plain' naming convention).
  function plainSqlId(name) {
    return '"' + name.toUpperCase().replace(/(::|\.)/g, '_').replace(/"/g, '""') + '"';
  }
}

module.exports = {
  toRenameDdl,
};
