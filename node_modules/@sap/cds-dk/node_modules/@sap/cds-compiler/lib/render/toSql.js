
'use strict';

const { getTopLevelArtifactNameOf, getParentNameOf, getParentNamesOf, getLastPartOf, getLastPartOfRef } = require('../model/modelUtils');
const { hasBoolAnnotation, isBuiltinType } = require('../model/csnUtils');
const keywords = require('../base/keywords');
const alerts = require('../base/alerts');
const version = require('../../package.json').version;
const { renderFunc } = require('./renderUtil');
const DuplicateChecker = require('./DuplicateChecker');
const { checkCSNVersion } = require('../json/csnVersion');
const { handleMessages } = require('../base/messages');
const timetrace = require('../utils/timetrace');
const { isBetaEnabled } = require('../base/model');

// Type mapping from cds type names to DB type names:
// (in the future, we would introduce an option for the mapping table)
const cdsToSqlTypes = {
  standard: {
    // characters and binaries
    'cds.String': 'NVARCHAR',
    'cds.hana.NCHAR': 'NCHAR',
    'cds.LargeString' : 'NCLOB',
    'cds.hana.VARCHAR': 'VARCHAR',
    'cds.hana.CHAR': 'CHAR',
    'cds.hana.CLOB': 'CLOB',
    'cds.Binary': 'VARBINARY',  // not a Standard SQL type, but HANA and MS SQL Server
    'cds.hana.BINARY': 'BINARY',
    'cds.LargeBinary': 'BLOB',
    // numbers: exact and approximate
    'cds.Decimal': 'DECIMAL',
    'cds.DecimalFloat': 'DECIMAL',
    'cds.Integer64': 'BIGINT',
    'cds.Integer': 'INTEGER',
    'cds.hana.SMALLINT': 'SMALLINT',
    'cds.hana.TINYINT': 'TINYINT', // not a Standard SQL type
    'cds.Double': 'DOUBLE',
    'cds.hana.REAL': 'REAL',
    // other: date/time, boolean
    'cds.Date': 'DATE',
    'cds.Time': 'TIME',
    'cds.DateTime': 'TIMESTAMP', // https://github.wdf.sap.corp/cdx/cds-compiler/issues/2758
    'cds.Timestamp': 'TIMESTAMP',
    'cds.Boolean': 'BOOLEAN',
    'cds.UUID': 'NVARCHAR',  // changed to cds.String earlier
    // (TODO: do it later; TODO: why not CHAR or at least VARCHAR?)
  },
  hana: {
    'cds.hana.SMALLDECIMAL': 'SMALLDECIMAL',
    'cds.DateTime': 'SECONDDATE',
    'cds.hana.ST_POINT': 'ST_POINT',
    'cds.hana.ST_GEOMETRY': 'ST_GEOMETRY',
  },
  sqlite: {
    'cds.Binary': 'CHAR',
    'cds.hana.BINARY': 'CHAR',
    'cds.hana.SMALLDECIMAL': 'DECIMAL',
  },
};

/**
 * Render the CSN model 'model' to SQL DDL statements. One statement is created
 * per top-level artifact into dictionaries 'hdbtable', 'hdbview', ..., without
 * leading CREATE, without trailing semicolon. All statements (in proper order)
 * are copied into dictionary 'sql', with trailing semicolon.
 * Return an object like this:
 * { "hdbtable": {
 *     "foo" : "COLUMN TABLE foo ...",
 *    },
 *   "hdbview": {
 *     "bar::wiz" : "VIEW \"bar::wiz\" AS SELECT \"x\" FROM ..."
 *   },
 *   "sql: {
 *     "foo" : "CREATE TABLE foo ...;\n",
 *     "bar::wiz" : "CREATE VIEW \"bar::wiz\" AS SELECT \"x\" FROM ...;\n"
 *   }
 * }
 *
 * @param {CSN.Model} csn
 * @param {object}    [options=csn.options]
 */
function toSqlDdl(csn, options = csn.options) {
  timetrace.start('SQL rendering');
  const { error, signal, warning, info } = alerts(csn, options);

  // FIXME: Currently requires 'options.forHana', because it can only render HANA-ish SQL dialect
  if (!options.forHana) {
    throw new Error('toSql can currently only be used with HANA preprocessing');
  }

  checkCSNVersion(csn, options);


  // Create artificial namespace objects, so that each artifact has parents up to top-level.
  // FIXME: This is actually only necessary to make 'getParentNameOf' work - should be reworked
  for (let artifactName in csn.definitions) {
    for (let parentName of getParentNamesOf(artifactName)) {
      if (!csn.definitions[parentName]) {
        csn.definitions[parentName] = {
          kind : 'namespace',
        };
      }
    }
  }

  // The final result in hdb-kind-specific form, without leading CREATE, without trailing newlines
  // (note that the order here is relevant for transmission into 'resultObj.sql' below and that
  // the attribute names must be the HDI plugin names for --src hdi)
  let resultObj = {
    hdbtabletype: Object.create(null),
    hdbtable: Object.create(null),
    hdbindex: Object.create(null),
    hdbfulltextindex: Object.create(null),
    hdbview: Object.create(null),
    alterTable: Object.create(null)
  }

  // Registries for artifact and element names per CSN section
  let definitionsDuplicateChecker = new DuplicateChecker();
  let extensionsDuplicateChecker = new DuplicateChecker();

  // Render each artifact on its own
  for (let artifactName in csn.definitions) {
    // This environment is passed down the call hierarchy, for dealing with
    // indentation issues
    let env = {
      // Current indentation string
      indent: '',
    }
    renderArtifactInto(artifactName, csn.definitions[artifactName], resultObj, env);
  }

  // Render each artifact extension
  for (let artifactIndex in csn.extensions) {
    if ('extend' in csn.extensions[artifactIndex]) {
      const artifactName = csn.extensions[artifactIndex]['extend']
      // This environment is passed down the call hierarchy, for dealing with
      // indentation issues
      let env = {
        // Current indentation string
        indent: '',
      }
      renderArtifactExtensionInto(artifactName, csn.extensions[artifactIndex], resultObj, env);
    }
  }

  // trigger artifact and element name checks
  definitionsDuplicateChecker.check(signal, error);
  extensionsDuplicateChecker.check(signal, error);

  // Throw exception in case of errors
  handleMessages(csn, options);

  // Transfer results from hdb-specific dictionaries into 'sql' dictionary in proper order if toSql.src === 'sql'
  // (relying on the order of dictionaries above)
  // FIXME: Should consider inter-view dependencies, too
  let sql = Object.create(null);
  let sqlVersionLine = `-- generated by cds-compiler version ${version}\n`;

  // Handle hdbKinds separately from alterTable case
  const { alterTable, ...hdbKinds } = resultObj;
  for (let hdbKind of Object.keys(hdbKinds)) {
    for (let name in resultObj[hdbKind]) {
      if (options.toSql.src === 'sql') {
        let sourceString = resultObj[hdbKind][name];
        // Hack: Other than in 'hdbtable' files, in HANA SQL COLUMN is not mandatory but default.
        if (options.toSql.dialect === 'hana' && hdbKind === 'hdbtable' && sourceString.startsWith('COLUMN ')) {
          sourceString = sourceString.slice('COLUMN '.length);
        }
        sql[name] = `${options.testMode ? '' : sqlVersionLine}CREATE ${sourceString};`;
      }
      else {
        if (!options.testMode) {
          resultObj[hdbKind][name] = sqlVersionLine + resultObj[hdbKind][name];
        }
      }
    }
    if (options.toSql.src === 'sql') {
      delete resultObj[hdbKind];
    }
  }
  if (options.toSql.src === 'sql') {
    resultObj.sql = sql;
  }
  for (let name in alterTable) {
    alterTable[name][0] = `${options.testMode ? '' : sqlVersionLine}` + alterTable[name][0];
  }

  timetrace.stop();
  return resultObj;

  // Render an artifact into the appropriate dictionary of 'resultObj'.
  function renderArtifactInto(artifactName, art, resultObj, env) {
    // Ignore whole artifacts if forHana says so
    if (art._ignore || hasBoolAnnotation(art, '@cds.persistence.exists', true)) {
      return;
    }
    switch (art.kind) {
      case 'entity':
      case 'view':
        if (art.query) {
          let result = renderView(artifactName, art, env);
          if (result) {
            resultObj.hdbview[artifactName] = result;
          }
        } else {
          renderEntityInto(artifactName, art, resultObj, env);
        }
        break;
      case 'type': {
        let result = renderType(artifactName, art, env);
        if (result) {
          resultObj.hdbview[artifactName] = result;
        }
        break;
      }
      case 'context':
      case 'service':
      case 'namespace':
      case 'annotation':
      case 'action':
      case 'function':
      case 'event':
        // Ignore: not SQL-relevant
        return;
      default:
        throw new Error('Unknown artifact kind: ' + art.kind);
    }
  }

  // Render an artifact extension into the appropriate dictionary of 'resultObj'.
  function renderArtifactExtensionInto(artifactName, art, resultObj, env) {
    // Property kind is always omitted for elements and can be omitted for
    // top-level type definitions, it does not exist for extensions.
    if (artifactName && !art.query) {
      renderExtendInto(artifactName, art, resultObj, env)
    }
    if (!artifactName) throw new Error('Undefined artifact name: ' + artifactName);
  }

  // Render a (non-projection, non-view) entity (and possibly its indices) into the appropriate
  // dictionaries of 'resultObj'.
  function renderEntityInto(artifactName, art, resultObj, env) {
    let childEnv = increaseIndent(env);
    let hanaTc = art.technicalConfig && art.technicalConfig.hana;
    let result = '';
    // Only HANA has row/column tables
    if (options.toSql.dialect === 'hana') {
      if (hanaTc && hanaTc.storeType) {
        // Explicitly specified
        result += art.technicalConfig.hana.storeType.toUpperCase() + ' ';
      } else {
        // in 'hdbtable' files, COLUMN or ROW is mandatory, and COLUMN is the default
        result += 'COLUMN ';
      }
    }
    let tableName = quoteSqlId(absoluteCdsName(artifactName));
    definitionsDuplicateChecker.addArtifact(tableName, art && art.$location, artifactName)
    result += 'TABLE ' + tableName;
    result += ' (\n';
    let elements = Object.keys(art.elements).map(eltName => {
      return renderElement(artifactName, eltName, art.elements[eltName], definitionsDuplicateChecker, getFzIndex(eltName, hanaTc), childEnv);
    }).filter(s => s !== '').join(',\n');
    if (elements !== '') {
      result += elements;
    } else {
      signal(error`"${artifactName}": Entity must have at least one element that is non-virtual`, art.location);
    }
    let primaryKeys = Object.keys(art.elements).filter(name => art.elements[name].key)
                                               .filter(name => !art.elements[name]._ignore)
                                               .map(name => quoteSqlId(name))
                                               .join(', ');
    let uniqueFields = Object.keys(art.elements).filter(name => art.elements[name].unique && !art.elements[name]._ignore)
                                                .map(quoteSqlId)
                                                .join(', ');
    if (uniqueFields !== '') {
      result += ',\n' + childEnv.indent + 'UNIQUE(' + uniqueFields + ')'
    }
    if (primaryKeys !== '') {
      result += ',\n' + childEnv.indent + 'PRIMARY KEY(' + primaryKeys + ')'
    }
    // Append table constraints if any
    // 'CONSTRAINT <name> UNIQUE (<column_list>)
    // OR create a unique index for HDI
    for(const cn in art.$tableConstraints) {
      const c = art.$tableConstraints[cn];
      if(options.toSql.src === 'hdi') {
        resultObj.hdbindex[`${artifactName}.${cn}`] =
          `UNIQUE INVERTED INDEX ${quoteSqlId( absoluteCdsName(artifactName) + '_' + cn )} ON ${tableName} (${c.map(cpath => quoteSqlId(cpath.ref[0])).join(', ')})`;
      }
      else {
        result += ',\n' + childEnv.indent + 'CONSTRAINT ' + cn + ' UNIQUE (' +
          c.map(cpath => quoteSqlId(cpath.ref[0])).join(', ') + ')';
      }
    }
    result += env.indent + '\n)';

    if (options.toSql.dialect === 'hana') {
      result += renderTechnicalConfiguration(art.technicalConfig, childEnv);
    }

    let associations = Object.keys(art.elements).map(name => renderAssociationElement(name, art.elements[name], childEnv))
                                                .filter(s => s !== '')
                                                .join(',\n');
    if (associations !== '' && options.toSql.dialect === 'hana') {
      result += env.indent + ' WITH ASSOCIATIONS (\n' + associations + '\n';
      result += env.indent + ')';
    }
    // Only HANA has indices
    // FIXME: Really? We should provide a DB-agnostic way to specify that
    if (options.toSql.dialect === 'hana') {
      renderIndexesInto(art.technicalConfig && art.technicalConfig.hana.indexes, artifactName, resultObj, env);
    }
    resultObj.hdbtable[artifactName] = result;
  }

  // Render an extended entity into the appropriate dictionaries of 'resultObj'.
  function renderExtendInto(artifactName, art, resultObj, env) {

    let tableName = quoteSqlId(absoluteCdsName(artifactName));
    extensionsDuplicateChecker.addArtifact(tableName, art && art.$location, artifactName)

    // Only extend with 'ADD' for elements/associations
    // TODO: May also include 'RENAME' at a later stage
    let elements = Object.keys(art.elements).map((eltName) => {
      const eltStr = renderElement(artifactName, eltName, art.elements[eltName], extensionsDuplicateChecker, null, env);
      if (options.toSql.dialect === 'sqlite') {
        return eltStr.length ? 'ALTER TABLE ' + tableName + ' ADD COLUMN ' + eltStr  + ';': eltStr;
      }
      return eltStr.length ? eltStr : eltStr;
    })
    .filter(s => s !== '')

    if (options.toSql.dialect === 'hana' && elements.length) {
      elements = ['ALTER TABLE ' + tableName + ' ADD (' + elements.join(', ') + ');'];
    }

    let associations = Object.keys(art.elements).map(name => {
      const eltStr = renderAssociationElement(name, art.elements[name], env);
      return eltStr.length ? 'ALTER TABLE ' + tableName + ' ADD ASSOCIATION (' + eltStr + ');': eltStr;
    })
      .filter(s => s !== '');

    // In order to render a statement, elements for sql dialect 'hana' must be at least one of type or association
    if ((elements.length > 0 && options.toSql.dialect === 'sqlite') ||
       ((elements.length > 0 || associations.length > 0) && options.toSql.dialect === 'hana')) {

      let resultsArray = [];
      resultsArray.push(...elements);
      if (options.toSql.dialect === 'hana') {
        resultsArray.push(...associations);
      }

      resultObj.alterTable[artifactName] = resultsArray;
    }
  }

  // Retrieve the 'fzindex' (fuzzy index) property (if any) for element 'elemName' from hanaTc (if defined)
  function getFzIndex(elemName, hanaTc) {
    if (!hanaTc || !hanaTc.fzindexes || !hanaTc.fzindexes[elemName]) {
      return undefined;
    }
    if (hanaTc.fzindexes[elemName][0] instanceof Array) {
      // FIXME: Should we allow multiple fuzzy search indices on the same column at all?
      // And if not, why do we wrap this into an array?
      return hanaTc.fzindexes[elemName][hanaTc.fzindexes[elemName].length - 1];
    }
    else {
      return hanaTc.fzindexes[elemName];
    }
  }

  // Render an element 'elm' with name 'elementName' (of an entity or type, not of a
  // projection or view), optionally with corresponding fuzzy index 'fzindex' from the
  // technical configuration.
  // Ignore association elements (those are rendered later by renderAssociationElement).
  // Use 'artifactName' only for error output.
  // Return the resulting source string (no trailing LF).
  function renderElement(artifactName, elementName, elm, duplicateChecker, fzindex, env) {
    // Ignore if forHana says so, or if it is an association
    if (elm.virtual)
      elm._ignore = true; // this has the side effect, that it's also ignored in the primary key generation
    if (elm._ignore || elm.target) {
      return '';
    }
    const quotedElementName = quoteSqlId(elementName);
    duplicateChecker.addElement(quotedElementName, elm && elm.$location, elementName);

    let result = env.indent + quotedElementName + ' '
                            + renderTypeReference(artifactName, elementName, elm)
                            + renderNullability(elm, true);
    if (elm.default) {
      result += ' DEFAULT ' + renderExpr(elm.default, env);
    }
    // Only HANA has fuzzy indizes
    if (fzindex && options.toSql.dialect === 'hana') {
      result += ' ' + renderExpr(fzindex, env);
    }
    return result;
  }

  // Render an element 'elm' with name 'elementName' if it is an association, in the style required for
  // HANA native associations (e.g. 'MANY TO ONE JOIN "source" AS "assoc" ON (condition)').
  // Return a string with one line per association element, or an empty string if the element
  // is not an association.
  function renderAssociationElement(elementName, elm, env) {
    let result = '';
    if (elm.target && !elm._ignore) {
      result += env.indent;
      if(elm.cardinality) {
        if(isBetaEnabled(options, 'hanaAssocRealCardinality') && elm.cardinality.src && elm.cardinality.src === 1) {
          result += 'ONE TO ';
        } else {
          result += 'MANY TO ';
        }
        if (elm.cardinality.max && (elm.cardinality.max === '*' || Number(elm.cardinality.max) > 1)) {
          result += 'MANY';
        } else {
          result += 'ONE';
        }
      } else {
        result += 'MANY TO ONE';
      }
      result += ' JOIN ';
      result += quoteSqlId(absoluteCdsName(elm.target)) + ' AS ' + quoteSqlId(elementName) + ` ON (`;
      result += renderExpr(elm.on, env) + ')';
    }
    return result;
  }

  // Render the 'technical configuration { ... }' section of an entity that comes as a suffix
  // to the CREATE TABLE statement (includes migration, unload prio, extended storage,
  // auto merge, partitioning, ...).
  // Return the resulting source string.
  function renderTechnicalConfiguration(tc, env) {
    let result = '';

    if (!tc) {
      return result;
    }

    // FIXME: How to deal with non-HANA technical configurations?
    // This also affects renderIndexes
    tc = tc.hana;
    if (!tc) {
      throw new Error('Expecting a HANA technical configuration');
    }
    if (tc.tableSuffix) {
      // Although we could just render the whole bandwurm as one stream of tokens, the
      // compactor has kindly stored each part (e.g. `migration enabled` `row store`, ...)
      // in its own `xpr` (for the benefit of the `toCdl` renderer, which needs semicolons
      // between parts). We use this here for putting each one one line)

      // The ignore array contains technical configurations that are illegal in HANA SQL
      let ignore = [
        'PARTITION BY KEEPING EXISTING LAYOUT',
        'ROW STORE',
        'COLUMN STORE',
        'MIGRATION ENABLED',
        'MIGRATION DISABLED'
      ];
      for (let xpr of tc.tableSuffix) {
        let clause = renderExpr(xpr, env);
        if(!ignore.includes(clause.toUpperCase())) {
          result += '\n' + env.indent + clause;
        }
      }
    }
    return result;
  }

  // Render the array `indexes` from the technical configuration of an entity 'artifactName'
  function renderIndexesInto(indexes, artifactName, resultObj, env) {
    // Indices and full-text indices
    for (let idxName in indexes || {}) {
      let result = '';
      if (indexes[idxName][0] instanceof Array) {
        // FIXME: Should we allow multiple indices with the same name at all? (last one wins)
        for (let index of indexes[idxName]) {
          result = renderExpr(insertTableName(index), env);
        }
      }
      else {
        result = renderExpr(insertTableName(indexes[idxName]), env);
      }
      // FIXME: Full text index should already be different in compact CSN
      if (result.startsWith('FULLTEXT')) {
        resultObj.hdbfulltextindex[`${artifactName}.${idxName}`] = result;
      }
      else {
        resultObj.hdbindex[`${artifactName}.${idxName}`] = result;
      }
    }

    // Insert 'artifactName' (quoted according to naming style) into the index
    // definition 'index' in two places:
    //   CDS:  unique index            "foo" on             (x, y)
    // becomes
    //   SQL:  unique index "<artifact>.foo" on "<artifact>"(x, y)
    // CDS does not need this because the index lives inside the artifact, but SQL does.
    function insertTableName(index) {
      let i = index.indexOf('index');
      let j = index.indexOf('(');
      if (i > index.length - 2 || !index[i + 1].ref || j < i || j > index.length - 2) {
        throw new Error(`Unexpected form of index: "${index}"`);
      }
      let indexName = `${absoluteCdsName(artifactName)}.${index[i + 1].ref}`;
      if (options.toSql.names === 'plain') {
        indexName = indexName.replace(/(\.|::)/g, '_');
      }
      let result = index.slice(0, i + 1); // CREATE UNIQUE INDEX
      result.push({ ref: [indexName] }); // "<artifact>.foo"
      result.push(...index.slice(i + 2, j)); // ON
      result.push({ ref: [absoluteCdsName(artifactName)] }); // <artifact>
      result.push(...index.slice(j)); // (x, y)
      return result;
    }
  }

  // Render the source of a query, which may be a path reference, possibly with an alias,
  // or a subselect, or a join operation. Use 'artifactName' only for error output.
  // FIXME: Misleading name, should be something like 'renderQueryFrom'. All the query
  // parts should probably also be rearranged.
  // Returns the source as a string.
  function renderViewSource(artifactName, source, env) {
    // Sub-SELECT
    if (source.SELECT || source.SET) {
      let result = `(${renderQuery(artifactName, source, increaseIndent(env))})`;
      if (source.as) {
        result += ` AS ${quoteSqlId(source.as)}`;
      }
      return result;
    }
    // JOIN
    else if (source.join) {
      // One join operation, possibly with ON-condition
      let result = `${renderViewSource(artifactName, source.args[0], env)}`;
      for (let i = 1; i < source.args.length; i++) {
        result = `(${result} ${source.join.toUpperCase()} JOIN ${renderViewSource(artifactName, source.args[i], env)}`
        if (source.on) {
          result += ` ON ${renderExpr(source.on, env)}`;
        }
        result += ')';
      }
      return result;
    }
    // Ordinary path, possibly with an alias
    else {
      // Sanity check
      if (!source.ref) {
        throw new Error(`Expecting ref in ${JSON.stringify(source)}`);
      }
      return renderAbsolutePathWithAlias(artifactName, source, env);
    }
  }

  // Render a path that starts with an absolute name (as used for the source of a query),
  // possibly with an alias, with plain or quoted names, depending on options. Expects an object 'path' that has a
  // 'ref' and (in case of an alias) an 'as'. If necessary, an artificial alias
  // is created to the original implicit name.  Use 'artifactName' only for error output.
  // Returns the name and alias as a string.
  function renderAbsolutePathWithAlias(artifactName, path, env) {
    // This actually can't happen anymore because assoc2joins should have taken care of it
    if (path.ref[0].where) {
      throw new Error(`"${artifactName}": Filters in FROM are not supported for conversion to SQL`);
    }

    // SQL needs a ':' after path.ref[0] to separate associations
    let result = renderAbsolutePath(path, ':', env);

    // Take care of aliases
    let implicitAlias = getLastPartOfRef(path.ref);
    if (path.as) {
      // Source had an alias - render it
      result += ' AS ' + quoteSqlId(path.as);
    }
    else if (getLastPartOf(result) != quoteSqlId(implicitAlias)) {
      // Render an artificial alias if the result would produce a different one
      result += ' AS ' + quoteSqlId(implicitAlias);
    }
    return result;
  }

  // Render a path that starts with an absolute name (as used e.g. for the source of a query),
  // with plain or quoted names, depending on options. Expects an object 'path' that has a 'ref'.
  // Uses <seperator> (typically ':': or '.') to separate the first artifact name from any
  // subsequent associations.
  // Returns the name as a string.
  function renderAbsolutePath(path, sep, env) {
    // Sanity checks
    if (!path.ref) {
      throw new Error('Expecting ref in path: ' + JSON.stringify(path));
    }
    // Determine the absolute name of the first artifact on the path (before any associations or element traversals)
    let firstArtifactName = path.ref[0].id || path.ref[0];

    let result = quoteSqlId(absoluteCdsName(firstArtifactName));
    // store argument syntax hint in environment
    // $syntax is set only by A2J and only at the first path step after FROM clause rewriting
    const syntax = path.ref[0].$syntax;
    // Even the first step might have parameters and/or a filter
    if (path.ref[0].args) {
      result += `(${renderArgs(path.ref[0].args, '=>', env, syntax)})`;
    }
    else if (['udf'].includes(syntax)) {
      // if syntax is user defined function, render empty argument list
      // CV without parameters is called as simple view
      result += '()';
    }
    if (path.ref[0].where) {
      result += `[${path.ref[0].cardinality ? (path.ref[0].cardinality.max + ': ') : ''}${renderExpr(path.ref[0].where, env)}]`;
    }
    // Add any path steps (possibly with parameters and filters) that may follow after that
    if (path.ref.length > 1) {
      result += `${sep}${renderExpr({ref: path.ref.slice(1)}, env)}`;
    }
    return result;
  }

  // Render function arguments or view parameters (positional if array, named if object/dict),
  // using 'sep' as separator for positional parameters
  function renderArgs(args, sep, env, syntax) {
    // Positional arguments
    if (args instanceof Array) {
      return args.map(arg => renderExpr(arg, env)).join(', ');
    }
    // Named arguments (object/dict)
    else if (typeof args === 'object') {
      return Object.keys(args).map(key => `${decorateParameter(key, syntax)} ${sep} ${renderExpr(args[key], env)}`).join(', ');
    }
    else {
      throw new Error('Unknown args: ' + JSON.stringify(args));
    }

    function decorateParameter(arg, syntax) {
      if(syntax === 'calcview') {
        return `PLACEHOLDER."$$${arg}$$"`
      }
      else {
        return quoteSqlId(arg);
      }
    }
  }

  // Render a single view column 'col', as it occurs in a select list or projection list.
  // Return the resulting source string (one line per column item, no CR).
  function renderViewColumn(col, env) {
    // Ignore if forHana says so
    // FIXME: Have we already filtered out associations here?
    if (col._ignore) {
      return '';
    }
    let result = '';
    let leaf = col.as || col.ref && col.ref[col.ref.length-1] || col.func;
    if(leaf && env._artifact.elements[leaf] && env._artifact.elements[leaf].virtual) {
      // render a virtual column 'null as <alias>'
      result += env.indent + 'NULL AS ' + quoteSqlId(col.as || leaf);
    } else if (col.cast && !(options && options.toSql && options.toSql.dialect === 'sqlite')) {
      result = env.indent + 'CAST(' + renderExpr(col, env, true) + ' AS ';
      result += renderBuiltinType(col.cast.type) + renderTypeParameters(col.cast);
      result += ') ' + quoteSqlId(leaf);
    } else {
      result = env.indent + renderExpr(col, env, true);
      if (col.as) {
        result += ' AS ' + quoteSqlId(col.as);
      }
    }
    return result;
  }

  // Render a view
  function renderView(artifactName, art, env) {
    env._artifact = art;
    let viewName = quoteSqlId(absoluteCdsName(artifactName));
    definitionsDuplicateChecker.addArtifact(viewName, art && art.$location, artifactName)
    let result = 'VIEW ' + viewName;
    result += renderParameterDefinitions(artifactName, art.params);
    result += ' AS ' + renderQuery(artifactName, art.query, env);
    let childEnv = increaseIndent(env);
    let associations = Object.keys(art.elements).filter(name => !!art.elements[name].target)
                                                .map(name => renderAssociationElement(name, art.elements[name], childEnv))
                                                .filter(s => s !== '')
                                                .join(',\n');
    if (associations !== '' && options.toSql.dialect === 'hana') {
      result += env.indent + '\nWITH ASSOCIATIONS (\n' + associations + '\n';
      result += env.indent + ')';
    }
    return result;
  }

  // Render the parameter definition of a view if any. Return the parameters in parentheses, or an empty string
  function renderParameterDefinitions(artifactName, params) {
    let result = Object.keys(params || {}).map(name => 'IN ' + quoteSqlId(name) + ' ' + renderTypeReference(artifactName, name, params[name]))
                                          .join(', ');
    if (result !== '') {
      result = '(' + result + ')';
    }
    return result;
  }

  // Render a query 'query', i.e. a select statement with where-condition etc. Use 'artifactName' only for error messages.
  function renderQuery(artifactName, query, env) {
    let result = '';
    // Set operator, like UNION, INTERSECT, ...
    if (query.SET) {
      result += query.SET.args
        .map(arg => {
          // Wrap each query in the SET in parentheses that
          // - is a SET itself (to preserve precedence between the different SET operations),
          // - has an ORDER BY/LIMIT (because UNION etc. can't stand directly behind an ORDER BY)
          let queryString = renderQuery(artifactName, arg, env);
          return (arg.SET || arg.SELECT && (arg.SELECT.orderBy || arg.SELECT.limit)) ? `(${queryString})` : queryString;
        })
        .join(`\n${env.indent}${query.SET.op && query.SET.op.toUpperCase()}${query.SET.all ? ' ALL ' : ' '}`);
      // Set operation may also have an ORDER BY and LIMIT/OFFSET (in contrast to the ones belonging to
      // each SELECT)
      // If the whole SET has an ORDER BY/LIMIT, wrap the part before that in parentheses
      // (otherwise some SQL implementations (e.g. sqlite) would interpret the ORDER BY/LIMIT as belonging
      // to the last SET argument, not to the whole SET)
      if (query.SET.orderBy || query.SET.limit) {
        result = `(${result})`;
        if (query.SET.orderBy) {
          result += `\n${env.indent}ORDER BY ${query.SET.orderBy.map(entry => renderOrderByEntry(entry, env)).join(', ')}`;
        }
        if (query.SET.limit) {
          result += `\n${env.indent}${renderLimit(query.SET.limit, env)}`;
        }
      }
      return result;
    }
    // Otherwise must have a SELECT
    else if (!query.SELECT) {
      throw new Error('Unexpected query operation ' + JSON.stringify(query));
    }
    let select = query.SELECT;
    let childEnv = increaseIndent(env);
    result += 'SELECT' + (select.distinct ? ' DISTINCT' : '');
    // FIXME: We probably also need to consider `excluding` here ?
    result += '\n' +
              (select.columns||['*']).filter(s => !s._ignore)
                                     .filter(col => !(select.mixin || {})[firstPathStepId(col.ref)]) // No mixin columns
                                     .map(col => renderViewColumn(col, childEnv))
                                     .filter(s => s !== '')
                                     .join(',\n') + '\n';
    result += `${env.indent}FROM ${renderViewSource(artifactName, select.from, env)}`;
    if (select.where) {
      result += `\n${env.indent}WHERE ${renderExpr(select.where, env)}`;
    }
    if (select.groupBy) {
      result += `\n${env.indent}GROUP BY ${select.groupBy.map(expr => renderExpr(expr, env)).join(', ')}`;
    }
    if (select.having) {
      result += `\n${env.indent}HAVING ${renderExpr(select.having, env)}`;
    }
    if (select.orderBy) {
      result += `\n${env.indent}ORDER BY ${select.orderBy.map(entry => renderOrderByEntry(entry, env)).join(', ')}`;
    }
    if (select.limit) {
      result += `\n${env.indent}${renderLimit(select.limit, env)}`;
    }
    return result;
  }

  // Returns the id of the first path step in 'ref' if any, otherwise undefined
  function firstPathStepId(ref) {
    return ref && ref[0] && (ref[0].id || ref[0]);
  }

  // Render a query's LIMIT clause, which may have also have OFFSET.
  function renderLimit(limit, env) {
    let result = '';
    if (limit.rows !== undefined) {
      result += `LIMIT ${renderExpr(limit.rows, env)}`;
    }
    if (limit.offset !== undefined) {
      result += `${result !== '' ? '\n' + env.indent : ''}OFFSET ${renderExpr(limit.offset, env)}`;
    }
    return result;
  }

  // Render one entry of a query's ORDER BY clause (which always has a 'value' expression, and may
  // have a 'sort' property for ASC/DESC and a 'nulls' for FIRST/LAST
  function renderOrderByEntry(entry, env) {
    let result = renderExpr(entry, env);
    if (entry.sort) {
      result += ` ${entry.sort.toUpperCase()}`;
    }
    if (entry.nulls) {
      result += ` NULLS ${entry.nulls.toUpperCase()}`;
    }
    return result;
  }

  // Render a type.
  // Return the resulting source string.
  function renderType(artifactName, art, env) {
    // Only HANA table types are SQL-relevant
    if (!art.dbType) {
      return '';
    }
    // In Sqlite dialect do not generate table type and throw an info
    if (options.toSql.dialect === 'sqlite') {
      signal(info`"${artifactName}": HANA table types are not supported in SQLite`, art.location);
      return '';
    }
    let typeName = quoteSqlId(absoluteCdsName(artifactName));
    definitionsDuplicateChecker.addArtifact(typeName, art && art.$location, artifactName)
    let result = 'TYPE ' + quoteSqlId(absoluteCdsName(artifactName)) + ' AS TABLE (\n';
    let childEnv = increaseIndent(env);
    if (art.elements) {
      // Structured type
      let elements = Object.keys(art.elements).map(name => renderElement(artifactName, art, name, art.elements[name], definitionsDuplicateChecker, null, childEnv))
                                         .filter(s => s !== '')
                                         .join(',\n') + '\n';
      if (elements !== '') {
        result += elements;
        result += env.indent + ')';
      } else {
        signal(error`"${artifactName}": HANA table type must have at least one element that is non-virtual`, art.location);
      }
    } else {
      // Non-structured HANA table type
      signal(error`"${artifactName}": HANA table types must have structured types for conversion to SQL`, art.location);
      return '';
    }
    return result;
  }

  // Render a reference to the type used by 'elm' (with name 'elementName' in 'artifactName', both used only for error messages).
  function renderTypeReference(artifactName, elementName, elm) {
    let result = '';

    // Anonymous structured type: Not supported with SQL (but shouldn't happen anyway after forHana flattened them)
    if (!elm.type) {
      if (!elm.elements) {
        throw new Error('Missing type of: ' + elementName);
      }
      signal(error`"${artifactName}.${elementName}": Anonymous structured types are not supported for conversion to SQL`, elm.location);
      return result;
    }

    // Association type
    if (elm.target) {
      // We can't do associations yet
      signal(error`"${artifactName}.${elementName}": Association and composition types are not yet supported for conversion to SQL`, elm.location);
      return result;
    }

    // If we get here, it must be a primitive (i.e. builtin) type
    if (isBuiltinType(elm.type)) {
      // cds.Integer => render as INTEGER (no quotes)
      result += renderBuiltinType(elm.type);
    } else {
      throw new Error('Unexpected non-primitive type of: ' + artifactName + '.' + elementName);
    }
    result += renderTypeParameters(elm);
    return result;
  }

  // Render the name of a builtin CDS type
  function renderBuiltinType(typeName) {
    const forHanaRenamesToEarly = {
      'cds.UTCDateTime' : 'cds.DateTime',
      'cds.UTCTimestamp' : 'cds.Timestamp',
      'cds.LocalDate' : 'cds.Date',
      'cds.LocalTime' : 'cds.Time',
    };
    const tName = forHanaRenamesToEarly[typeName] || typeName;
    const types = cdsToSqlTypes[options.toSql.dialect];
    return types && types[tName] || cdsToSqlTypes.standard[tName] || 'CHAR';
  }

  // Render the nullability of an element or parameter (can be unset, true, or false)
  function renderNullability(obj, treatKeyAsNotNull = false) {
    if (obj.notNull === undefined && !(obj.key && treatKeyAsNotNull)) {
      // Attribute not set at all
      return '';
    }
    return obj.notNull || obj.key ? ' NOT NULL' : ' NULL';
  }

  // Render (primitive) type parameters of element 'elm', i.e.
  // length, precision and scale (even if incomplete), plus any other unknown ones.
  function renderTypeParameters(elm) {
    let params = [];
    // Length, precision and scale (even if incomplete)
    if (elm.length !== undefined) {
      params.push(elm.length);
    }
    if (elm.precision !== undefined) {
      params.push(elm.precision);
    }
    if (elm.scale !== undefined) {
      params.push(elm.scale);
    }
    if (elm.srid !== undefined) {
      // Geometry types translate into CHAR on Sqlite (give them the default length of 5000)
      if (options.toSql.dialect === 'sqlite')
        params.push(5000);
      else
        params.push(elm.srid);
    }
    // Additional type parameters
    // FIXME: Not yet clear how that looks in new CSN
    for (let arg of elm.typeArguments || []) {
      params.push(arg);
    }
    return params.length === 0 ? '' : '(' + params.join(', ') + ')';
  }

  // FIXME: Reuse this together with `toCdl`.

  // Render an expression (including paths and values) or condition 'x'.
  // (no trailing LF, don't indent if inline)
  function renderExpr(x, env, inline=true) {
    // Compound expression
    if (x instanceof Array) {
      // Simply concatenate array parts with spaces (with a tiny bit of beautification)
      // FIXME: Take this for `toCdl`, too
      let tokens = x.map(item => renderExpr(item, env, inline));
      let result = '';
      for (let i = 0; i < tokens.length; i++) {
        result += tokens[i];
        // No space after last token, after opening parentheses, before closing parentheses, before comma
        if (i != tokens.length - 1 && tokens[i] !== '(' && ![')', ','].includes(tokens[i + 1])) {
          result += ' ';
        }
      }
      return result;
      // return x.map(item => renderExpr(item, env, inline)).join(' ');
    }
    // Various special cases represented as objects
    else if (typeof x === 'object' && x !== null) {
      // Literal value, possibly with explicit 'literal' property
      if (x.val !== undefined) {
        switch (x.literal || typeof x.val) {
          case 'number':
          case 'boolean':
          case 'null':
            // 17.42, NULL, TRUE
            return String(x.val).toUpperCase();
          case 'x':
            // x'f000'
            return `${x.literal}'${x.val}'`;
          case 'date':
          case 'time':
          case 'timestamp':
            if (options.toSql.dialect === 'sqlite') {
              // date('2017-11-02')
              return `${x.literal}('${x.val}')`;
            } else {
              // date'2017-11-02'
              return `${x.literal}'${x.val}'`;
            }
          case 'string':
            // 'foo', with proper escaping
            return `'${x.val.replace(/'/g, "''")}'`;
          case 'object':
            if (x.val === null) {
              return 'NULL';
            }
            // otherwise fall through to
          default:
            throw new Error('Unknown literal or type: ' + JSON.stringify(x));
        }
      }
      // Enum symbol
      else if (x['#']) {
        // #foo
        // FIXME: We can't do enums yet because they are not resolved (and we don't bother finding their value by hand)
        signal(error`Enum values are not yet supported for conversion to SQL`, x.location);
        return '';
      }
      // Reference: Array of path steps, possibly preceded by ':'
      else if (x.ref) {
        if (options.forHana && !x.param && !x.global) {
          if(x.ref[0] === '$user') {
          // FIXME: this is all not enough: we might need an explicit select item alias
            if (x.ref[1] === 'id') {
              if (options.toSql.user && typeof options.toSql.user === 'string' || options.toSql.user instanceof String) {
                return `'${options.toSql.user}'`;
              }
              else if ((options.toSql.user && options.toSql.user.id) && (typeof options.toSql.user.id === 'string' || options.toSql.user.id instanceof String)) {
                return `'${options.toSql.user.id}'`;
              } else {
                if(options.forHana.dialect === 'sqlite'){
                  signal(warning`The "$user" variable is not supported by SQLite. Use the "toSql.user" option to set a value for "$user.id"`);
                  return `'$user.id'`;
                } else {
                  return "SESSION_CONTEXT('APPLICATIONUSER')";
                }
              }
            }
            else if (x.ref[1] === 'locale') {
              return options.forHana.dialect === 'sqlite'
                ? options.toSql.user && options.toSql.user.locale
                  ? `'${options.toSql.user && options.toSql.user.locale}'` : `'en'`
                : "SESSION_CONTEXT('LOCALE')";
            }
          }
          else if(x.ref[0] === '$at') {
            // return current_time for all $at
            if(options.forHana.dialect === 'sqlite') {
              return 'current_timestamp';
            }
            else if(options.forHana.dialect === 'hana') {
              if(x.ref[1] === 'from') {
                return "SESSION_CONTEXT('VALID-FROM')";
              }
              else if(x.ref[1] === 'to') {
                return "SESSION_CONTEXT('VALID-TO')";
              }
            }
          }
        }
        // FIXME: We currently cannot distinguish whether '$parameters' was quoted or not - we
        // assume that it was not if the path has length 2 (
        if (firstPathStepId(x.ref) === '$parameters' && x.ref.length == 2) {
          // Parameters must be uppercased and unquoted in SQL
          return `:${x.ref[1].toUpperCase()}`;
        }
        if (x.param) {
          return `:${x.ref[0].toUpperCase()}`;
        }
        return x.ref.map(renderPathStep)
                    .filter(s => s !== '')
                    .join('.');
      }
      // Function call, possibly with args (use '=>' for named args)
      else if (x.func) {
        // test for non-regular HANA identifier that needs to be quoted
        // identifier                  {letter}({letter_or_digit}|[#$])*
        // letter                      [A-Za-z_]
        // letter_or_digit             [A-Za-z_0-9]

        const regex = RegExp(/^[a-zA-Z][\w#$]*$/, 'g');
        const isRegularId = regex.test(x.func);
        const funcName = isRegularId ? x.func : quoteSqlId(x.func);
        return renderFunc( funcName, x, options.toSql.dialect, a => renderArgs(a, '=>', env),
          !isRegularId ? false : true );
      }
      // Nested expression
      else if (x.xpr) {
        return renderExpr(x.xpr, env);
      }
      // Sub-select
      else if (x.SELECT) {
        // renderQuery for SELECT does not bring its own parentheses (because it is also used in renderView)
        return `(${renderQuery('<subselect>', x, increaseIndent(env))})`;
      }
      else if (x.SET) {
        // renderQuery for SET always brings its own parentheses (because it is also used in renderViewSource)
        return `${renderQuery('<union>', x, increaseIndent(env))}`;
      }
      else {
        throw new Error('Unknown expression: ' + JSON.stringify(x));
      }
    }
    // Not a literal value but part of an operator, function etc - just leave as it is
    // FIXME: For the sake of simplicity, we should get away from all this uppercasing in toSql
    else {
      return String(x).toUpperCase();
    }

    // Render a single path step 's' at path position 'idx', which can have filters or parameters or be a function
    function renderPathStep(s, idx) {
      // Simple id or absolute name
      if (typeof(s) === 'string') {
        // TODO: When is this actually executed and not handled already in renderExpr?
        const magicForHana = {
          '$now': 'CURRENT_TIMESTAMP',
          '$user.id': "SESSION_CONTEXT('APPLICATIONUSER')",
          '$user.locale': "SESSION_CONTEXT('LOCALE')",
        }
        // Some magic for first path steps
        if (idx === 0) {
          // HANA-specific translation of '$now' and '$user'
          // FIXME: this is all not enough: we might need an explicit select item alias
          if (magicForHana[s]) {
            return magicForHana[s];
          }
          // Ignore initial $projection and initial $self
          if (s === '$projection' || s === '$self') {
            return '';
          }
        }
        return quoteSqlId(s);
      }
      // ID with filters or parameters
      else if (typeof s === 'object') {
        // Sanity check
        if (!s.func && !s.id) {
          throw new Error('Unknown path step object: ' + JSON.stringify(s));
        }
        // Not really a path step but an object-like function call
        if (s.func) {
          return `${s.func}(${renderArgs(s.args, '=>', env)})`;
        }
        // Path step, possibly with view parameters and/or filters
        let result = `${quoteSqlId(s.id)}`;
        if (s.args) {
          // View parameters
          result += `(${renderArgs(s.args, '=>', env)})`;
        }
        if (s.where) {
          // Filter, possibly with cardinality
          // FIXME: Does SQL understand filter cardinalities?
          result += `[${s.cardinality ? (s.cardinality.max + ': ') : ''}${renderExpr(s.where, env)}]`;
        }
        return result;
      }
      else {
        throw new Error('Unknown path step: ' + JSON.stringify(s));
      }
    }
  }

  // Returns a copy of 'env' with increased indentation
  function increaseIndent(env) {
    return Object.assign({}, env, { indent: env.indent + '  ' });
  }

  // Return 'name' in the form of an absolute CDS name - for the 'hdbcds' naming convention,
  // this means converting '.' to '::' on the border between namespace and top-level artifact.
  // For all other naming conventions, this is a no-op.
  function absoluteCdsName(name) {
    if (options.toSql.names !== 'hdbcds') {
      return name;
    }
    let topLevelName = getTopLevelArtifactNameOf(name, csn);
    let namespaceName = getParentNameOf(topLevelName);
    if (namespaceName) {
      return `${namespaceName}::${name.substring(namespaceName.length + 1)}`;
    }
    return name;
  }

  // Return 'name' with appropriate "-quotes.
  // Additionally perform the following conversions on 'name'
  // If 'options.toSql.names' is 'plain'
  //   - replace '.' or '::' by '_'
  // else if 'options.toSql.names' is 'quoted'
  //   - replace '::' by '.'
  // Complain about names that collide with known SQL keywords or functions
  function quoteSqlId(name) {
    if (options.toSql.dialect === 'sqlite' && keywords.sqlite.includes(name.toUpperCase())) {
      // Sanity check
      if (options.toSql.names !== 'plain') {
        throw new Error(`Not expecting ${options.toSql.names} names for 'sqlite' dialect`);
      }
      signal(warning`The identifier "${name}" is a SQLite keyword`);
    }
    if (options.toSql.names === 'plain') {
      if (options.toSql.dialect === 'hana') {
        if (keywords.hana.includes(name.toUpperCase())) {
          signal(warning`The identifier "${name}" is a HANA keyword`);
        }
      }
      name = name.replace(/(\.|::)/g, '_');
      return name;
    }
    else if (options.toSql.names === 'quoted') {
      name = name.replace(/::/g, '.');
    }
    return `"${name.replace(/"/g, '""')}"`;
  }
}

module.exports = {
  toSqlDdl,
};
