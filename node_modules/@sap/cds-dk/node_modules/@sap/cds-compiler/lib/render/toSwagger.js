const schemaObjects = require('./swaggerSchemaObjects');
const { forEachDefinition } = require('../base/model');
const preprocessModel = require('../transform/preprocessModelForSwagger');
const { compactSorted } = require('../json/compactor');
const { compactModel } = require('../json/to-csn');
let swaggerJson = null;

function csnToSwagger(model, options) {
  preprocessModel(model);

  let result = {};

  // Return CSN result if requested
  if (options.toSwagger.csn) {
    result.csn = options.newCsn === false ? compactSorted(model) : compactModel(model);
    result._augmentedCsn = model;
  }
  result.services = Object.create(null);

  // Produce actual Swagger result only if requested
  if (options.toSwagger.json) {
    forEachDefinition(model, obj => {
      if (obj.kind === 'service' && !obj.abstract) {
        swaggerJson = schemaObjects.openAPIObject();
        swaggerJson.info.title = obj.name.absolute;

        Object.keys(obj.artifacts).forEach(artName => {
          let art = obj.artifacts[artName];

          // if actions are available for the definition => create the operations in the swagger model
          if (art.actions)
            Object.keys(art.actions).forEach(actName => Object.assign(swaggerJson.paths, createPath(art.actions[actName])));

          // unbound function or action
          if (art.kind === 'function' || art.kind === 'action') {
            Object.assign(swaggerJson.paths, createPath(art));
            return; // there is no need to create a schemas in "components" for an unbound action/function
          }

          // create schema for the object
          swaggerJson.components.schemas[art.name.id] = createSchemaObjectForArt(art);

          // add the default schema for an error
          Object.assign(swaggerJson.components.schemas, schemaObjects.defaultErrorObj());
        });

        result.services[obj.name.absolute] = swaggerJson;
      }
    });
  }
  return result;
}

// create an entry for the 'paths' property from an action or a function
function createPath(action) {
  let swaggerAnnos = collectSwaggerAnnotationsForObject(action);
  if (swaggerAnnos.length === 0)
    return undefined;

  // if the action is declared in the cds model to returns an array of specific entity, then
  // the response in the swagger model has a content with schema pointing to the corresponding array declaration in the data model
  // and in the headers of the response a 'x-next' entry is inluded (the pointer to the next page)
  let arrayedResponse = action.returns && action.returns.items;

  let path = getPathString(action);

  let operations = Object.create(null);
  let actMethods = swaggerAnnos.filter(a =>
    ['Swagger.GET', 'Swagger.get', 'Swagger.Get',
      'Swagger.POST', 'Swagger.post', 'Swagger.Post',
      'Swagger.PUT', 'Swagger.put', 'Swagger,Put',
      'Swagger.DELETE', 'Swagger.delete', 'Swagger.Delete',
      // 'Swagger.OPTIONS', 'Swagger.options', 'Swagget.Options',
      'Swagger.HEAD', 'Swagger.head', 'Swagger.Head',
      'Swagger.PATCH', 'Swagger.patch', 'Swagger.Patch'
      // 'Swagger.TRACE', 'Swagger.trace', 'Swagget.Trace'
    ].includes(a.name.path.map(p => p.id).join('.')));
  actMethods.forEach(m => {
    let method = m.name.path[1].id;
    operations[method.toLowerCase()] =
      generateOperationByMethod(method.toUpperCase(), m, action, arrayedResponse);
  });

  // if the path of the operation is not specified by the user( then the name of the action is taken, as mentioned above)
  // and there are parameters with location 'path', then those parameters names are appended to the path
  // if the user wants some specific order or more complicated path => should specify it with the @Swagger.path annotation
  // and have to take care of correct parameters names
  if (!action['@Swagger.path'] && action.params)
    Object.keys(action.params).forEach(pName => {
      if (action.params[pName]['@Swagger.parameter'] && action.params[pName]['@Swagger.parameter'].val === 'path')
        path += `/{${pName}}`;
    })
  return { [path]: operations };

  // the desired path where the operations serves can be spcified via the annotation @Swagger.path, if not we are taking the name
  function getPathString(action) {
    if (action['@Swagger.path'] && action['@Swagger.path'].val)
      return action['@Swagger.path'].val;
    return action.name.action ?
    `/${action.name.absolute}${'/' + action.name.action}`
    : `/${action.name.absolute.replace(/.([^.]*)$/,'/$1')}`;
  }
}

// generate the operation schema for a specific http method specified by the @Swagger.<method>, e.g. @Swagger.GET
function generateOperationByMethod(method, methodDef, action, isArrayedResponse) {
  let operation = schemaObjects[`operationObj${method}`]();

  // As with the @Swagger annotation the possible response code(s) can be define with 3 different values, e.g:
  // @Swagger.GET : 200
  // @Swagger.POST
  // @Swagger.DELETE : [202, 204, 200]
  // or compacted
  // @Swagger : { GET : 200, POST, DELETE : [202, 204, 200] }
  // the following lines of codes goes throught the 3 different variants
  // and at the end in the array we have the response code(s) for the operation

  // If the http verb is PATCH - "A successful response is indicated with a 204 response code, because the response does not carry a message body."
  // src: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH
  let resCodes = methodDef.val ? methodDef.val : method === 'PATCH' ? 204 : 200;
  resCodes = Array.isArray(resCodes) ? resCodes : [resCodes];
  resCodes = resCodes.map(c => c.val || c);

  resCodes.forEach(code => {
    if (!operation.responses[code])
      operation.responses[code] = schemaObjects.responseContenDef();

    if (isArrayedResponse)
      operation.responses[code].headers = schemaObjects.nextPageHeaderObj();

    if (action.params) {
      // if there is parameter annotated with @Swagger.parameter: 'requestBody', must not need to be included in the params block
      let notReqBodyParams = Object.keys(action.params).filter(p => !(action.params[p]['@Swagger.parameter'] && action.params[p]['@Swagger.parameter'].val === 'requestBody'));
      if (notReqBodyParams.length > 0)
        operation.parameters = notReqBodyParams.map(p => generateParameterObject(p, action.params[p]));
    }

    if (method !== 'HEAD')
      operation.responses[code] = getResponseByCode(operation.responses[code], code, action.returns || {});
  })

  if (action.params && ['POST', 'PUT', 'PATCH'].includes(method)) {
    // find the parameter annotated with 'requestBody', the '.find' finds the first occurence which is fine as only one parameter can be annotated with 'requestBody'
    let reqBodyParam = Object.keys(action.params).find(p => action.params[p]['@Swagger.parameter'] && action.params[p]['@Swagger.parameter'].val === 'requestBody');
    if (reqBodyParam)
      operation.requestBody = generateRequestBody(action.params, action.params[reqBodyParam]);
  }

  // add the tag of the operation
  // if it is a bound action the tag will be the entity name
  // if unbound - the service name
  let nameParts = action.name.absolute.split('.');
  operation.tags.push(action.name.action ? nameParts.pop() : nameParts[nameParts.length - 2]);

  return operation;
}

// generates an object which represents actions' parameter in a swagger form
function generateParameterObject(name, param) {
  let result = Object.create(null);
  // TODO: implement correct naming as per the documentation
  result.name = param.name.id;

  // the parameter object must have 'in' property. The property's value is the location of the parameter.
  // Possible values are "query", "header", "path" or "cookie".(src: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#parameterObject)
  // In CDS @Swagger.parameter annotation is used to specify the location, the default one is query
  result.in = param['@Swagger.parameter'] && param['@Swagger.parameter'].val || 'query';
  result.description = '';

  // "Determines whether this parameter is mandatory. If the parameter location is "path", this property is REQUIRED and its value MUST be true.
  // Otherwise, the property MAY be included and its default value is false."
  // https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#parameterObject
  result.required = param['@Swagger.parameter'] && param['@Swagger.parameter'].val === 'path' ? true : false;
  // TODO: can also be a reference, also check the case when the param is not a built-in
  result.schema = createSchemaObjectForArt(param);
  return result;
}

function generateRequestBody(name, param) {
  let result = {
    description: '',
    required: true,
    content: {
      'application/json': {}
    }
  }
  result.content['application/json'].schema = createSchemaObjectForArt(param);
  return result;
}

// "The Schema Object allows the definition of input and output data types.
// These types can be objects, but also primitives and arrays.
// ... Alternatively, any time a Schema Object can be used, a Reference Object can be used in its place."
function createSchemaObjectForArt(art) {
  let result = Object.create(null);

  if (art.enum) {
    result.enum = getEnumObj(art.enum);
  }

  // array
  if (art.items) {
    return Object.assign(result, { type: 'array', items: createSchemaObjectForArt(art.items) });
  }

  if (art.type) {
    let type = art;
    if (type.type && type.type._artifact)
      type = type.type._artifact;
    if (type.name.absolute.startsWith('cds.') && !type.name.absolute.startsWith('cds.foundation.')) {
      // representing the length specified for strings or binary
      if (art.length)
        result.maxLength = art.length.val;
      // representing the precision and the scale in decimals
      if (art.precision && art.scale) {
        // TODO: deal with rounding in javascript
        result.multipleOf = parseFloat(`0.${'0'.repeat(art.scale.val - 1)}1`);
        result.maximum = parseFloat(`${'9'.repeat(art.precision.val - art.scale.val)}.${'9'.repeat(art.scale.val)}`);
        result.minimum = parseFloat(`-${'9'.repeat(art.precision.val - art.scale.val)}.${'9'.repeat(art.scale.val)}`);
      }
      // associations
      if (type.name.absolute === 'cds.Association' || art.type._artifact.name.absolute === 'cds.Composition' && art.target) {
        let resultSchema = schemaObjects.referenceObject('#/components/schemas', art._swaggerTarget || art.target._artifact.name.id);
        if (art.cardinality && (art.cardinality.targetMax.val === '*' || art.cardinality.targetMax.val > 1))
          return Object.assign(result, { type: 'array', items: resultSchema });
        else
          return Object.assign(result, resultSchema);
      }
      return Object.assign(result, convertBuiltInType(type));
    }
    else { // reference
      if (art._swaggerExpandType)
        return Object.assign(result, createSchemaObjectForArt(art.type._artifact));
      if (art._swaggerType)
        return Object.assign(result, schemaObjects.referenceObject('#/components/schemas', `${art._swaggerType}`));
      else {
        let name = art.type._artifact.name;
        return Object.assign(result, schemaObjects.referenceObject('#/components/schemas', `${name.absolute.slice(name.absolute.lastIndexOf('.') + 1)}${name.element ? '/properties/' + name.element.replace(/\./g, '/properties/') : ''}`));
      }
    }
  }

  // if the artifact is some kind expression then return a schema which can contains unspecified properties
  if (art.value && !art.value.path) {
    return Object.assign(result, { type: 'object', additionalProperties: true });
  }

  // translate cds "elements" to "properties" of the data type in a schema object
  if (art.elements) {
    // in the swagger data types by default, all object properties are optional
    // required properties can be specified in a 'required' list
    // the list is an object-level attribute
    // src: https://swagger.io/docs/specification/data-models/data-types/
    // as 'required' the elements with 'not null' attribute are taken from the cds model
    if (Object.keys(art.elements).some(e => art.elements[e].notNull))
      result.required = Object.keys(art.elements).filter(e => art.elements[e].notNull);

    result.properties = Object.create(null);
    // property definition is a schema object
    Object.keys(art.elements).forEach(e =>
      result.properties[e] = createSchemaObjectForArt(art.elements[e]));
    return result;
  }

  return result;
}

// In Swagger, the enum is a property which is represented as it is described in the JSON schema spec, or
// "The enum keyword is used to restrict a value to a fixed set of values.
// It must be an array with at least one element, where each element is unique."
// src: https://spacetelescope.github.io/understanding-json-schema/reference/generic.html#enumerated-values
// Conventionally  the elements of the enum array should be valid against the enclosed schema, but
// in CDS representation the enum values are objects with the form of { <id of the enum element> : <value> }
function getEnumObj(cdsEnum) {
  return Object.keys(cdsEnum).map(id => {
    return cdsEnum[id].value ? cdsEnum[id].value.val : id;
  });
}

// Convert cds build-in type to the corresponding swagger type
// Types defined by the OpenAPI spec: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#dataTypes
// If there is one-to-one correspondence, then the type is translated as in the spec, otherwise the 'format'
// property is set to the specific CDS type.("..the format property is an open string-valued property, and can have any value.")
function convertBuiltInType(type) {
  // if it is not a built-in
  if (!(type.name.absolute && type.name.absolute.startsWith('cds.') && !type.name.absolute.startsWith('cds.foundation.')))
    return undefined;

  let result = Object.create(null);
  result.type = type.name.absolute.slice(4).toLowerCase(); // crop the starting 'cds.'
  switch (result.type) {
    case 'binary':
      result.type = 'string';
      result.format = 'binary';
      break;
    case 'boolean':
      break;
    case 'date':
      result.type = 'string';
      result.format = 'date';
      break;
    case 'datetime':
      result.type = 'string';
      result.format = 'date-time';
      break;
    case 'decimal':
      result.type = 'number';
      result.format = 'decimal';
      break;
    case 'decimalfloat':
      result.type = 'number';
      result.format = 'float';
      break;
    case 'double':
      result.type = 'number';
      result.format = 'double';
      break;
    case 'integer':
      result.format = 'int32';
      break;
    case 'integer64':
      result.type = 'integer'
      result.format = 'int64';
      break;
    case 'largebinary':
      result.type = 'binary';
      result.format = 'largeBinary';
      break;
    case 'largestring':
      result.type = 'string';
      result.format = 'largeString';
      break;
    case 'string':
      break;
    case 'time':
      result.type = 'string';
      result.format = 'time';
      break;
    case 'timestamp':
      result.type = 'string';
      result.format = 'timestamp';
      break;
    case 'uuid':
      result.type = 'string';
      result.format = 'uuid';
      break;
  }
  return result;
}

function collectSwaggerAnnotationsForObject(obj) {
  return Object.keys(obj).map(prop => {
    if (prop.startsWith('@Swagger.'))
      return obj[prop];
    return undefined;
  }).filter(n => !!n);
}

function getResponseByCode(res, code, actResult) {
  switch (code) {
    case '2XX':
    case 200:
      res.content['application/json'].schema = createSchemaObjectForArt(actResult);
      break;
    case 201:
      res.description = 'Created.'
      res.content['application/json'].schema = createSchemaObjectForArt(actResult);
      break;
    case 202:
      res.description = 'The request has been accepted for processing,' +
        ' but the processing has not been completed.';
      delete res.content;
      break;
    case 204:
      res.description = 'No content in the response.';
      delete res.content;
      break;
    case 205:
      res.description = 'Content reset';
      delete res.content;
      break;
    case 206:
      res.description = 'Partial content';
      res.content['application/json'].schema = { type: 'object', additionalProperties: true };
      break;
    case 207:
      res.description = 'Multi-status';
      delete res.content['application/json'];
      res.content['application/xml'] = Object.create(null);
      res.content['application/xml'].schema = { type: 'object', additionalProperties: true };
      break;
    case 208:
      res.description = 'Already Reported';
      delete res.content;
      break;
    case 226:
      res.description = 'IM used';
      delete res.content;
      break;
    case '1XX':
      res.description = 'Informational';
      delete res.content;
      break;
    case '3XX':
      res.description = 'Redirection';
      delete res.content;
      break;
    case '4XX':
      res.description = 'Client Error';
      delete res.content;
      break;
    case '5XX':
      res.description = 'Server Error';
      delete res.content;
      break;
  }
  return res;
}

module.exports = csnToSwagger;
