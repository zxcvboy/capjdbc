'use strict';
const { isEdmPropertyRendered, isBuiltinType } = require('../../model/csnUtils');
const edmUtils = require('../edmUtils.js');
const preprocessAnnotations = require('./preprocessAnnotations.js');
const oDataDictionary = require('../../gen/Dictionary.json');
const alerts = require('../../base/alerts');


/* Vocabulary overview as of January 2020:

   OASIS: https://github.com/oasis-tcs/odata-vocabularies/tree/master/vocabularies
   Aggregation (published)
   Authorization (published)
   Capabilities (published)
   Core (published)
   Measures (published)
   Repeatability (published)
   Temporal (not published, not yet finalized)
   Validation (published)

   SAP: https://github.com/SAP/odata-vocabularies/tree/master/vocabularies
   Analytics (published)
   CodeList (published)
   Common (pubished)
   Communication (published)
   Graph (published, experimental)
   Hierarchy (not published, still experimental)
   HTML5 (published, experimental)
   ODM (published, experimental)
   PersonalData (published)
   Session (published)
   UI (published)
*/

const vocabularyDefinitions = {
  'Aggregation': {
    'ref': { Uri: 'https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.xml' },
    'inc': { Alias: 'Aggregation', Namespace: 'Org.OData.Aggregation.V1' },
    'int': { filename: 'Aggregation.xml' }
  },
  'Analytics': {
    'ref': { Uri: 'https://sap.github.io/odata-vocabularies/vocabularies/Analytics.xml' },
    'inc': { Alias: 'Analytics', Namespace: 'com.sap.vocabularies.Analytics.v1' },
    'int': { filename: 'Analytics.xml' }
  },
  'Authorization': {
    'ref': { Uri: 'https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml' },
    'inc': { Alias: 'Authorization', Namespace: 'Org.OData.Authorization.V1' },
    'int': { filename: 'Authorization.xml' }
  },
  'Capabilities': {
    'ref': { Uri: 'https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml' },
    'inc': { Alias: 'Capabilities', Namespace: 'Org.OData.Capabilities.V1' },
    'int': { filename: 'Capabilities.xml' }
  },
  'CodeList': {
    'ref': { Uri: 'https://sap.github.io/odata-vocabularies/vocabularies/CodeList.xml' },
    'inc': { Alias: 'CodeList', Namespace: 'com.sap.vocabularies.CodeList.v1' },
    'int': { filename: 'CodeList.xml' }
  },
  'Common': {
    'ref': { Uri: 'https://sap.github.io/odata-vocabularies/vocabularies/Common.xml' },
    'inc': { Alias: 'Common', Namespace: 'com.sap.vocabularies.Common.v1' },
    'int': { filename: 'Common.xml' }
  },
  'Communication': {
    'ref': { Uri: 'https://sap.github.io/odata-vocabularies/vocabularies/Communication.xml' },
    'inc': { Alias: 'Communication', Namespace: 'com.sap.vocabularies.Communication.v1' },
    'int': { filename: 'Communication.xml' }
  },
  'Core': {
    'ref': { Uri: 'https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml' },
    'inc': { Alias: 'Core', Namespace: 'Org.OData.Core.V1' },
    'int': { filename: 'Core.xml' }
  },
  'Graph': {
    'ref': { Uri: 'https://sap.github.io/odata-vocabularies/vocabularies/Graph.xml' },
    'inc': { Alias: 'Graph', Namespace: 'com.sap.vocabularies.Graph.v1' },
    'int': { filename: 'Graph.xml' }
  },
  'HTML5': {
    'ref': { Uri: 'https://sap.github.io/odata-vocabularies/vocabularies/HTML5.xml' },
    'inc': { Alias: 'HTML5', Namespace: 'com.sap.vocabularies.HTML5.v1' },
    'int': { filename: 'HTML5.xml' }
  },
  'Measures': {
    'ref': { Uri: 'https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Measures.V1.xml' },
    'inc': { Alias: 'Measures', Namespace: 'Org.OData.Measures.V1' },
    'int': { filename: 'Measures.xml' }
  },
  'ODM': {
    'ref': { Uri: 'https://sap.github.io/odata-vocabularies/vocabularies/ODM.xml' },
    'inc': { Alias: 'ODM', Namespace: 'com.sap.vocabularies.ODM.v1' },
    'int': { filename: 'ODM.xml' }
  },
  'PersonalData': {
    'ref': { Uri: 'https://sap.github.io/odata-vocabularies/vocabularies/PersonalData.xml' },
    'inc': { Alias: 'PersonalData', Namespace: 'com.sap.vocabularies.PersonalData.v1' },
    'int': { filename: 'PersonalData.xml' }
  },
  'Repeatability': {
    'ref': { Uri: 'https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Repeatability.V1.xml' },
    'inc': { Alias: 'Repeatability', Namespace: 'Org.OData.Repeatability.V1' },
    'int': { filename: 'Repeatability.xml' }
  },
  'Session': {
    'ref': { Uri: 'https://sap.github.io/odata-vocabularies/vocabularies/Session.xml' },
    'inc': { Alias: 'Session', Namespace: 'com.sap.vocabularies.Session.v1' },
    'int': { filename: 'Session.xml' }
  },
  'UI': {
    'ref': { Uri: 'https://sap.github.io/odata-vocabularies/vocabularies/UI.xml' },
    'inc': { Alias: 'UI', Namespace: 'com.sap.vocabularies.UI.v1' },
    'int': { filename: 'UI.xml' }
  },
  'Validation': {
    'ref': { Uri: 'https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Validation.V1.xml' },
    'inc': { Alias: 'Validation', Namespace: 'Org.OData.Validation.V1' },
    'int': { filename: 'Validation.xml' }
  },
};

const knownVocabularies = Object.keys(vocabularyDefinitions);


/**************************************************************************************************
 * csn2annotationEdm
 *
 * options:
 *   v - array with two boolean entries, first is for v2, second is for v4
 *   dictReplacement: for test purposes, replaces the standard oDataDictionary
 */
function csn2annotationEdm(csn, serviceName, options=undefined) {

  if(!options)
    throw 'Please debug me: csn2annotationsEdm must be invoked with options';

  const { signal } = alerts(csn);

  const Edm = require('../edm.js')(options);

  // annotation preprocessing
  preprocessAnnotations.preprocessAnnotations(csn, serviceName, options);

  // we take note of which vocabularies are actually used in a service in order to avoid
  // producing useless references; reset everything to "unused"
  knownVocabularies.forEach(n => {
    vocabularyDefinitions[n].used = false;
  });

  // provide functions for dictionary lookup
  //   use closure to avoid making "dict" and "experimental" global variables
  let { getDictTerm, getDictType } = function(){
    let dict = options.dictReplacement || oDataDictionary; // tests can set different dictionary via options
    let experimental = {}; // take note of all experimental annos that have been used
    let deprecated = {}; // take note of all deprecated annos that have been used

    return {
      // called to look-up a term in the dictionary
      //   in addition: - note usage of the respective vocabulary
      //                - issue a warning if the term is flagged as "experimental"
      getDictTerm: function(termName, context) {
        const dictTerm = dict.terms[termName]
        // register vocabulary usage if possible
        const vocName = termName.slice(0, termName.indexOf('.'));
        if(vocabularyDefinitions[vocName])
          vocabularyDefinitions[vocName].used = true;

        if (dictTerm) {
          // issue warning for usage of experimental Terms, but only once per Term
          if (dictTerm['$experimental'] && !experimental[termName]) {
            message(signal.warning, context, 'Term "' + termName + '" is experimental and can be changed or removed at any time, do not use productively!');
            experimental[termName] = true;
          }
          if (dictTerm['$deprecated'] && !deprecated[termName]) {
            message(signal.info, context, 'Term "' + termName + '" is deprecated. ' + dictTerm['$deprecationText']);
            deprecated[termName] = true;
          }
        }
        return dictTerm;
      },
      // called to look-up a type in the dictionary
      //   in addition, note usage of the respective vocabulary
      getDictType: function (typeName) {
        let dictType = dict.types[typeName];
        if (dictType) {
          // register usage of vocabulary
          vocabularyDefinitions[typeName.slice(0, typeName.indexOf('.'))].used = true;
        }
        return dictType;
      }
    }
  }();

  let v = options.v;

  // global variable where we store all the generated annotations
  let g_annosArray = [];

  // Crawl over the csn and trigger the annotation translation for all kinds
  //   of annotated things.
  // Note: only works for single service
  // Note: we assume that all objects ly flat in the service, i.e. objName always
  //       looks like <service name, can contain dots>.<id>
  for (let objName in csn.definitions) {
    if(objName == serviceName || objName.startsWith(serviceName + '.')) {
      let object = csn.definitions[objName];
      if (object.kind === 'action' || object.kind === 'function') {
        handleAction(objName, object, null);
      }
      else { // service, entity, anything else?
        // handle the annotations directly tied to the object
        handleAnnotations(objName, object);
        // handle the annotations of the object's elements
        handleElements(objName, object);
        // handle the annotations of the object's actions
        handleBoundActions(objName, object);
      }
    }
  }

  // filter out empty <Annotations...> elements
  g_annosArray = g_annosArray.filter(x => x._children.length > 0 || x.kind !== 'Annotations');

  // generate the edmx "frame" around the annotations
  let schema = new Edm.Schema(v, serviceName, serviceName, undefined, g_annosArray, false);
  let service = new Edm.DataServices(v, schema);
  /** @type {object} */
  let edm = new Edm.Edm(v, service);

  // add references for the used vocabularies
  knownVocabularies.forEach(n => {
    if(vocabularyDefinitions[n].used) {
      let r = new Edm.Reference(v, vocabularyDefinitions[n].ref);
      r.append(new Edm.Include(v, vocabularyDefinitions[n].inc))
      edm._defaultRefs.push(r);
    }
  })

  return edm;

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

  // helper to determine the OData version
  // TODO: improve option handling
  function isV2() {
    return v && v[0];
  }

  // this function is called in the translation code to issue an info/warning/error message
  // messages are reported via the alerts attribute of csn
  // context contains "semantic location"
  function message(severity, context, message) {
    let fullMessage = 'in annotation translation: ' + message;
    if (context) {
      let loc = 'target: ' + context.target + ', annotation: ' + context.term;
      if (context.stack.length > 0) {
        loc += context.stack.join('');
      }
      fullMessage += ', ' + loc;
    }
    signal(severity`${fullMessage}`);
  }

/*
  Mapping annotated thing in cds/csn => annotated thing in edmx:

  carrier: the annotated thing in cds, can be: service, entity, structured type, element of entity or structured type,
                                               action/function, parameter of action/function
  target: the annotated thing in OData

  In the edmx, all annotations for a OData thing are put into an element
    <Annotations Target="..."> where Target is the full name of the target
  There is one exception (Schema), see below

  carrier = service
    the target is the EntityContainer, unless the annotation has an "AppliesTo" where only Schema is given, but not EntityContainer
    then the <Annotation ...> is directly put into <Schema ...> without an enclosing <Annotations ...>

  carrier = entity (incl. view/projection)
    the target is the corresponding EntityType, unless the annotation has an "AppliesTo" where only EntitySet is given, but not EntityType
    then the target is the corresponding EntitySet

  carrier = structured type
    the target is the corresponding ComplexType

  carrier = element of entity or structured type
    the target is the corresponding Property of the EntityType/ComplexType: Target = <entity/type>/<element>

  carrier = action/function
    v2, unbound:          Target = <service>.EntityContainer/<action/function>
    v2, bound:            Target = <service>.EntityContainer/<entity>_<action/function>
    v4, unbound action:   Target = <service>.<action>()
    v4, bound action:     Target = <service>.<action>(<service>.<entity>)
    v4, unbound function: Target = <service>.<function>(<1st param type>, <2nd param type>, ...)
    v4, bound function:   Target = <service>.<function>(<service>.<entity>, <1st param type>, <2nd param type>, ...)

  carrier = parameter of action/function
    like above, but append "/<parameter" to the Target
*/




  // handle the annotations of the elements of an object
  // in: objname : name of the object
  //     object : the object itself
  function handleElements(objname, object) {
    if (!object.elements) return;
    for (let elemName in object.elements) {
      let element = object.elements[elemName];
      // determine the name of the target in the resulting edm
      //   for non-assoc element, this simply is "<objectName>/<elementName>"
      let edmTargetName = objname + '/' + elemName;
      handleAnnotations(edmTargetName, element);

      // handle sub elements
      if (element.elements) {
        handleNestedElements(objname, elemName, element.elements);
      }
    }
  }

  // handling annotations at nested elements is not yet supported
  // => issue a warning, but only if there actually are annotations
  function handleNestedElements(objname, baseElemName, elementsObj) {
    for (let elemName in elementsObj) {
      let element = elementsObj[elemName];

      if (Object.keys(element).filter( x => x.substr(0,1) === '@' ).filter(filterKnownVocabularies).length > 0) {
        message(signal.warning, null, 'annotations at nested elements are not yet supported, object ' + objname + ', element ' + baseElemName + '.' + elemName);
      }

      if (element.elements) {
        handleNestedElements(objname, baseElemName + '.' + elemName, element.elements);
      }
    }
  }


  // Annotations for actions and functions (and their parameters)
  // v2, unbound:          Target = <service>.EntityContainer/<action/function>
  // v2, bound:            Target = <service>.EntityContainer/<entity>_<action/function>
  // v4, unbound action:   Target = <service>.<action>()
  // v4, bound action:     Target = <service>.<action>(<service>.<entity>)
  // v4, unbound function: Target = <service>.<function>(<1st param type>, <2nd param type>, ...)
  // v4, bound function:   Target = <service>.<function>(<service>.<entity>, <1st param type>, <2nd param type>, ...)

  // handle the annotations of cObject's (an entity) bound actions/functions and their parameters
  // in: cObjectname : qualified name of the object that holds the actions
  //     cObject     : the object itself
  function handleBoundActions(cObjectname, cObject) {
    // get service name: remove last part of the object name
    // only works if all objects ly flat in the service
    let nameParts = cObjectname.split('.')
    let entityName = nameParts.pop();
    let serviceName = nameParts.join('.');

    for (let n in cObject.actions) {
      let action = cObject.actions[n];
      let actionName = serviceName + '.' + (isV2() ? entityName + '_' : '') + n;
      handleAction(actionName, action, cObjectname);
    }
  }

  // handle the annotations of an action and its parameters
  //   called by handleBoundActions and directly for unbound actions/functions
  // in: cActionName       : qualified name of the action
  //     cAction           : the action object
  //     entityNameIfBound : qualified name of entity if bound action/function
  function handleAction(cActionName, cAction, entityNameIfBound) {
    let actionName = cActionName;
    if (isV2()) { // insert before last "."
      actionName = actionName.replace(/\.(?=[^.]*$)/, '.EntityContainer/')
    }
    else { // add parameter type list
      actionName += relParList(cAction, entityNameIfBound);
    }

    handleAnnotations(actionName, cAction);
    for (let n in cAction.params) { // handle parameters
      let edmTargetName = actionName + '/' + n;
      handleAnnotations(edmTargetName, cAction.params[n]);
    }
  }

  function relParList(action, bindingParam) {
    // we rely on the order of params in the csn being the correct one
    let params = [];
    if (bindingParam) {
      params.push(action['@cds.odata.bindingparameter.collection'] ? 'Collection(' + bindingParam + ')' : bindingParam);
    }
    if (action.kind === 'function') {
      let mapType = (p) => (isBuiltinType(p.type)) ?
        edmUtils.mapCdsToEdmType(p, signal, false /*is only called for v4*/) : p.type;
      for (let n in action.params) {
        let p = action.params[n];
        let isArrayType = !p.type && p.items && p.items.type;
        params.push(isArrayType ? 'Collection(' + mapType(p.items) + ')' : mapType(p));
      }
    }
    return '(' + params.join(',') + ')';
  }




  // handle all the annotations for a given cds thing, here called carrier
  //   edmTargetName : string, name of the target in edm
  //   carrier: object, the annotated cds thing, contains all the annotations
  //                    as properties with names starting with @
  function handleAnnotations(edmTargetName, carrier) {
    // collect the names of the carrier's annotation properties
    // keep only those annotations that - start with a known vocabulary name
    //                                  - have a value other than null

    // if the carier is an element that is not rendered or
    // if the carrier is a derived type of a primitive type which is not rendered in V2
    // do nothing
    if(!isEdmPropertyRendered(carrier, options) ||
      (carrier.kind === 'type' && !edmUtils.isStructuredType(carrier) && options.isV2())) {
      return;
    }
    let annoNames = Object.keys(carrier).filter( x => x.substr(0,1) === '@' );
    let nullWhitelist = [ '@Core.OperationAvailable' ];
    let knownAnnos = annoNames.filter(filterKnownVocabularies).filter(x => carrier[x] !== null || nullWhitelist.includes(x));
    if (knownAnnos.length === 0) return;

    // in csn, all annotations are flattened
    // => values can be - primitive values (string, number)
    //                  - pseudo-records with "#" or "="
    //                  - arrays
    // in OData, there are "structured" annotations -> we first need to regroup the cds annotations
    //   by building a "prefix tree" for the annotations attached to the carrier
    //   see example at definition of function mergePathStepsIntoPrefixTree
    let prefixTree = {};
    for (let a of knownAnnos) {
      // remove leading @ and split at "."
      //   stop splitting at ".@" (used for nested annotations)
      let sa = a.split('.@');
      let steps = sa[0].slice(1).split('.');
      if (sa[1]) {
        steps.push('@' + sa[1]);
      }
      mergePathStepsIntoPrefixTree(prefixTree, steps, 0, carrier);
    }

    // construct a function that is used to add an <Annotation ...> to the
    //   respective <Annotations ...> element
    // this function is specific to the actual carrier, following the mapping rules given above
    let addAnnotation = function() {
      // usually, for a given carrier there is one target
      //   stdName: name of this target
      //   newAnnosStd: the corresponding <Annotations ...> tag
      // for some carriers (service, entity), there can be an alternative target (usually the EntitySet)
      //    alternativeEdmTargetName: name of alternative target
      //    newAnnosAlt: the corresponding <Annotations ...> tag
      // which one to choose depends on the "AppliesTo" info of the single annotations, so we have
      //   to defer this decision; this is why we here construct a function that can make the decision
      //   later when looking at single annotations

      let testToAlternativeEdmTarget = null; // if true, assign to alternative Edm Target
      /** @type {(val?: any) => boolean} */
      let testToStandardEdmTarget = ()=>true; // if true, assign to standard Edm Target
      let stdName = edmTargetName;
      let alternativeEdmTargetName = null;
      let hasAlternativeCarrier = false; // is the alternative annotation target available in the EDM?

      if (carrier.kind === 'entity' || carrier.kind === 'view') {
        // if annotated object is an entity, annotation goes to the EntityType,
        //   except if AppliesTo contains Singleton/EntitySet but not EntityType, then annotation goes to EntitySet
        if(carrier['@odata.singleton.nullable'])
          testToAlternativeEdmTarget = (x => x.includes('Singleton') && !x.includes('EntityType'));
        else
          testToAlternativeEdmTarget = (x => x.includes('EntitySet') && !x.includes('EntityType'));
        // if carrier has an alternate 'entitySetName' use this instead of EdmTargetName
        // (see edmPreprocessor.initializeParameterizedEntityOrView(), where parameterized artifacts
        // are split into *Parameter and *Type entities and their respective EntitySets are eventually
        // renamed.
        // (which is the definition key in the CSN and usually the name of the EntityType)
        // find last . in name and insert "EntityContainer/"
        alternativeEdmTargetName = (carrier.entitySetName || edmTargetName).replace(/\.(?=[^.]*$)/, '.EntityContainer/');
        hasAlternativeCarrier = carrier.hasEntitySet;
      }
      else if (carrier.kind === 'service') {
        // if annotated object is a service, annotation goes to EntityContainer,
        //   except if AppliesTo contains Schema but not EntityContainer, then annotation goes to Schema
        testToAlternativeEdmTarget = (x => x.includes('Schema') && !x.includes('EntityContainer'));
        // standard is to allow both Schema and Container
        testToStandardEdmTarget = ( x => x ? (x.includes('Schema') || x.includes('EntityContainer')) : true );
        stdName = edmTargetName + '.EntityContainer';
        alternativeEdmTargetName = edmTargetName;
        hasAlternativeCarrier = true; // EntityContainer is always available
      }
      //element => decide if navprop or normal property
      else if(!carrier.kind) {
        // if appliesTo is undefined, return true
        if(carrier.target) {
          testToStandardEdmTarget = (x=> x ? x.includes('NavigationProperty') : true);
        }
        else {
          // this might be more precise if handleAnnotation would know more about the carrier
          testToStandardEdmTarget = (x => x ? ['Parameter', 'Property'].some(y => x.includes(y)): true);
        }
      }


      /* all AppliesTo entries:
        "Action",
        "ActionImport",
        "Annotation",
        "Collection",
        "ComplexType",
        "EntityContainer",
        "EntitySet",
        "EntityType",
        "Function",
        "FunctionImport",
        "Include",
        "NavigationProperty",
        "Parameter",
        "Property",
        "PropertyValue",
        "Record",
        "Reference",
        "ReturnType",
        "Schema",
        "Singleton",
        "Term",
        "TypeDefinition"
      */

      // result objects that holds all the annotation objects to be created
      let newAnnosStd = new Edm.Annotations(v, stdName); // used in closure
      g_annosArray.push(newAnnosStd);
      let newAnnosAlternative = null; // create only on demand

      return function(annotation, appliesTo) {
        if (testToAlternativeEdmTarget && appliesTo && testToAlternativeEdmTarget(appliesTo)) {
          if (carrier.kind === 'service') {
            if (isV2()) {
              // there is no enclosing <Annotations ...>, so for v2 the namespace needs to be mentioned here
              annotation.setXml( { xmlns: 'http://docs.oasis-open.org/odata/ns/edm' } );
            }
            g_annosArray.push(annotation); // for target Schema: no <Annotations> element
          }
          // Add <Annotations> to existing carrier only
          else if(hasAlternativeCarrier) {
            if (!newAnnosAlternative) { // only create upon insertion of first anno
              newAnnosAlternative = new Edm.Annotations(v, alternativeEdmTargetName);
              g_annosArray.push(newAnnosAlternative);
            }
            newAnnosAlternative.append(annotation);
          }
        }
        else if(testToStandardEdmTarget(appliesTo)) {
          newAnnosStd.append(annotation);
        }
      }
    }();

    // now create annotation objects for all the annotations of carrier
    //   and put them into the elements property of the result object
    handleAnno2(addAnnotation, edmTargetName /*used for messages*/, prefixTree);
  }


  // tree: object where to put the next level of names
  // path: the parts of the annotation name
  // index: index into that array pointing to the next name to be processed
  //   0  : vocabulary
  //   1  : term
  //   2+ : record properties
  //
  // example:
  //   @v.t1
  //   @v.t2.p1
  //   @v.t2.p2
  //   @v.t3#x.q1
  //   @v.t3#x.q2
  //   @v.t3#y.q1
  //   @v.t3#y.q2
  //
  //   { v : { t1 : ...,
  //           t2 : { p1 : ...,
  //                  p2 : ...   },
  //           t3#x : { q1 : ...,
  //                    q2 : ... }
  //           t3#y : { q1 : ...,
  //                    q2 : ... } } }
  function mergePathStepsIntoPrefixTree(tree, pathSteps, index, carrier) {
    // TODO check nesting level > 3
    let name = pathSteps[index];
    if (index+1 < pathSteps.length ) {
      if (!tree[name]) {
        tree[name] = {};
      }
      mergePathStepsIntoPrefixTree(tree[name], pathSteps, index+1, carrier);
    }
    else {
      tree[name] = carrier['@' + pathSteps.join('.')];
    }
  }

  // handle all the annotations for a given carrier
  // addAnnotationFunc: a function that adds the <Annotation ...> tags created here into the
  //                    correct parent tag (see handleAnnotations())
  // edmTargetName: name of the edmx target, only used for messages
  // prefixTree: the annotations
  function handleAnno2(addAnnotationFunc, edmTargetName, prefixTree) {
    // first level names of prefix tree are the vocabulary names
    // second level names are the term names
    // create an annotation tag <Annotation ...> for each term
    for (let voc of Object.keys(prefixTree)) {
      for (let term of Object.keys(prefixTree[voc])) {
        let fullTermName = voc + '.' + term;

        // context is "semantic" location info used for messages
        let context = { target: edmTargetName,  term: fullTermName, stack: [] };
        // anno is the full <Annotation Term=...>
        let anno = handleTerm(fullTermName, prefixTree[voc][term], context);

        // addAnnotationFunc needs AppliesTo info from dictionary to decide where to put the anno
        fullTermName = fullTermName.replace(/#(\w+)$/g, ''); // remove qualifier
        let dictTerm = getDictTerm(fullTermName, context); // message for unknown term was already issued in handleTerm
        addAnnotationFunc(anno, dictTerm && dictTerm.AppliesTo);
      }
    }
  }


  // annoValue : the annotation value from the csn
  //             if the csn contains flattened out elements of a structured annotation,
  //             they are regrouped here
  // context :   for messages
  // return :    object that represents the annotation in the result edmx
  function handleTerm(termName, annoValue, context) {
    /**
     * create the <Annotation ...> tag
     * @type {object}
     * */
    let newAnno = new Edm.Annotation(v, termName);

    // termName may contain a qualifier: @UI.FieldGroup#shippingStatus
    // -> remove qualifier from termName and set Qualifier attribute in newAnno
    let p = termName.split('#');
    let termNameWithoutQualifiers = p[0];
    if (p.length>1) {
      newAnno.Term = termNameWithoutQualifiers;
      newAnno.Qualifier = p[1];
    }
    if (p.length>2) {
      message(signal.warning, context, 'multiple qualifiers (' + p[1] + ',' + p[2] +  (p.length>3?',...':'') + ')')
    }

    // get the type of the term from the dictionary
    let termTypeName = null;
    let dictTerm = getDictTerm(termNameWithoutQualifiers, context);
    if (dictTerm) {
      termTypeName = dictTerm.Type;
    }
    else {
      message(signal.info, context, 'unknown term ' + termNameWithoutQualifiers);
    }

    // handle the annotation value and put the result into the <Annotation ...> tag just created above
    handleValue(annoValue, newAnno, termNameWithoutQualifiers, termTypeName, context);
    return newAnno;
  }


  // handle an annotation value
  //   cAnnoValue: the annotation value (c : csn)
  //   oTarget: the result object (o: odata)
  //   oTermName: current term
  //   dTypeName: expected type of cAnnoValue according to dictionary, may be null (d: dictionary)
  function handleValue(cAnnoValue, oTarget, oTermName, dTypeName, context) {
    // this function basically only figures out what kind of annotation value we have
    //   (can be: array, expression, enum, pseudo-record, record, simple value),
    //   then calls a more specific function to deal with it and puts
    //   the result into the oTarget object

    if (Array.isArray(cAnnoValue))
    {
      if (isEnumType(dTypeName))
      {
        // if we find an array although we expect an enum, this may be a "flag enum"
        checkMultiEnumValue(cAnnoValue, dTypeName, context);
        oTarget.setJSON({ 'EnumMember': generateMultiEnumValue(cAnnoValue, dTypeName, false), 'EnumMember@odata.type' : '#'+dTypeName });
        oTarget.setXml( { 'EnumMember': generateMultiEnumValue(cAnnoValue, dTypeName, true) });
      }
      else
      {
        oTarget.append(generateCollection(cAnnoValue, oTermName, dTypeName, context));
      }
    }
    else if (cAnnoValue && typeof cAnnoValue === 'object') {
      if (Object.keys(cAnnoValue).length === 0) {
        message(signal.warning, context, 'empty record');
      }
      else if ('=' in cAnnoValue) {
        // expression
        let res = handleExpression(cAnnoValue['='], dTypeName, context);
        oTarget.setXml( { [res.name] : res.value });
        oTarget.setJSON( { [res.name] : res.value });
      }
      else if (cAnnoValue['#'] !== undefined) {
        // enum
        if (dTypeName) {
          checkEnumValue(cAnnoValue['#'], dTypeName, context);
          oTarget.setJSON({ 'EnumMember': cAnnoValue['#'], 'EnumMember@odata.type' : '#'+dTypeName,  });
          oTarget.setXml( { 'EnumMember': dTypeName + '/' + cAnnoValue['#'] });
        }
        else {
          // do something seemingly reasonable even if there is no dictionary info
          oTarget.setJSON({ 'EnumMember': cAnnoValue['#'], 'EnumMember@odata.type' : '#'+oTermName + 'Type/' });
          oTarget.setXml( { 'EnumMember': oTermName + 'Type/' + cAnnoValue['#'] });
        }
      }
      else if (cAnnoValue['$value'] !== undefined) {
        // "pseudo-structure" used for annotating scalar annotations
        handleValue(cAnnoValue['$value'], oTarget, oTermName, dTypeName, context);

        let k = Object.keys(cAnnoValue).filter( x => x.charAt(0) === '@');
        if (!k || k.length === 0) {
          message(signal.warning, context, 'pseudo-struct without nested annotation');
        }
        for (let nestedAnnoName of k) {
          let nestedAnno = handleTerm(nestedAnnoName.slice(1), cAnnoValue[nestedAnnoName], context);
          oTarget.append(nestedAnno);
        }
      }
      else if (cAnnoValue['$edmJson']) {
        // "pseudo-structure" used for embedding a piece of JSON that represents "OData CSDL, JSON Representation"
        oTarget.append(handleEdmJson(cAnnoValue['$edmJson'], context));
      }
      else if ( Object.keys(cAnnoValue).filter( x => x.substr(0,1) !== '@' ).length === 0) {
        // object consists only of properties starting with "@"
        message(signal.warning, context, 'nested annotations without corresponding base annotation');
      }
      else {
        // regular record
        oTarget.append(generateRecord(cAnnoValue, oTermName, dTypeName, context));
      }
    }
    else {
      let res = handleSimpleValue(cAnnoValue, dTypeName, context);
      if(oTermName === 'Core.OperationAvailable' && dTypeName === 'Edm.Boolean' && cAnnoValue === null) {
        oTarget.append(new Edm.ValueThing(v, 'Null'));
        oTarget._ignoreChildren = true;
      }
      else {
        oTarget.setXml( { [res.name] : res.value });
      }
      oTarget.setJSON( { [res.jsonName] : res.value });
    }
  }


  // found an enum value ("#"), check whether this fits
  //  the expected type "dTypeName"
  function checkEnumValue(enumValue, dTypeName, context) {
    let expectedType = getDictType(dTypeName);
    if (!expectedType && !isPrimitiveType(dTypeName)) {
      message(signal.warning, context, "internal error: dictionary inconsistency: type '" + dTypeName + "' not found");
    }
    else if (isComplexType(dTypeName)) {
      message(signal.warning, context, 'found enum value, but expected complex type ' + dTypeName);
    }
    else if (isPrimitiveType(dTypeName) || expectedType['$kind'] !== 'EnumType') {
      message(signal.warning, context, 'found enum value, but expected non-enum type ' + dTypeName);
    }
    else if (!expectedType['Members'].includes(enumValue)) {
      message(signal.warning, context, 'enumeration type ' + dTypeName + ' has no value ' + enumValue);
    }
    return;
  }

  // cAnnoValue: array
  // dTypeName: expected type, already identified as enum type
  //   array is expected to contain enum values
  function checkMultiEnumValue(cAnnoValue, dTypeName, context) {
    // we know that dTypeName is not null
    let type = getDictType(dTypeName);
    if (!type || type['IsFlags'] !== 'true') {
      message(signal.warning, context, "enum type '" + dTypeName + "' doesn't allow multiple values");
    }

    let index = 0;
    for (let e of cAnnoValue) {
      context.stack.push('[' + index++ + ']');
      if (e['#']) {
        checkEnumValue(e['#'], dTypeName, context);
      }
      else {
        // TODO improve message: but found ...
        message(signal.warning, context, 'expected an enum value');
      }
      context.stack.pop();
    }
  }

  function generateMultiEnumValue(cAnnoValue, dTypeName, forXml)
  {
    // remove all invalid entries (warnining message has already been issued)
    // replace short enum name by the full name
    // concatenate all the enums to a string, separated by spaces
    return cAnnoValue.filter( x => x['#'] != undefined ).map( x => (forXml ? dTypeName + '/' : '') + x['#'] ).join(forXml ? ' ' : ',');
  }


  // found an expression value ("=") "expr"
  //   expected type is dTypeName
  // note: expr can also be provided if an enum/complex type/collection is expected
  function handleExpression(expr, dTypeName, context) {
    let typeName = 'Path';
    if( ['Edm.AnnotationPath', 'Edm.ModelElementPath', 'Edm.NavigationPropertyPath', 'Edm.PropertyPath', 'Edm.Path' ].includes(dTypeName) )
      typeName = dTypeName.split('.')[1];

    let val = expr;
    if (!expr) {
      message(signal.warning, context, 'empty expression value');
    }
    else {
      // replace all occurrences of '.' by '/' up to first '@'
      val = expr.split('@').map((o,i) => (i==0 ? o.replace(/\./g, '/') : o)).join('@');
    }

    return {
      name : typeName,
      value : val
    }
  }


  // found a simple value "val"
  //  expected type is dTypeName
  //  mappping rule for values:
  //    if expected type is ... the expression to be generated is ...
  //      floating point type except Edm.Decimal -> Float
  //      Edm.Decimal -> Decimal
  //      integer tpye -> Int
  function handleSimpleValue(val, dTypeName, context) {
    // caller already made sure that val is neither object nor array
    dTypeName = resolveType(dTypeName);

    let typeName = 'String';

    if (typeof val === 'string') {
      if (dTypeName === 'Edm.Boolean') {
        typeName = 'Bool';
        if (!['true','false'].includes(val)) {
          message(signal.warning, context, 'found String, but expected type ' + dTypeName);
        }
      }
      else if (dTypeName === 'Edm.Decimal') {
        typeName = 'Decimal';
        if (isNaN(Number(val)) || isNaN(parseFloat(val))) {
          message(signal.warning, context, 'found non-numeric string, but expected type ' + dTypeName);
        }
      }
      else if (dTypeName === 'Edm.Double' || dTypeName === 'Edm.Single') {
        typeName = 'Float';
        if (isNaN(Number(val)) || isNaN(parseFloat(val))) {
          message(signal.warning, context, 'found non-numeric string, but expected type ' + dTypeName);
        }
      }
      else if (isComplexType(dTypeName)) {
        message(signal.warning, context, 'found String, but expected complex type ' + dTypeName);
      }
      else if (isEnumType(dTypeName)) {
        message(signal.warning, context, 'found String, but expected enum type ' + dTypeName);
        typeName = 'EnumMember';
      }
      else if (dTypeName && dTypeName.startsWith('Edm.') && dTypeName !== 'Edm.PrimitiveType') {
        // this covers also all paths
        typeName = dTypeName.substring(4);
      }
      else {
        if(dTypeName == undefined || dTypeName === 'Edm.PrimitiveType')
          dTypeName = 'Edm.String';
        // TODO
        //message(signal.warning, context, "type is not yet handled: found String, expected type: " + dTypeName);
      }
    }
    else if (typeof val === 'boolean') {
      if(dTypeName == undefined || dTypeName === 'Edm.Boolean' || dTypeName === 'Edm.PrimitiveType') {
        typeName = 'Bool';
        dTypeName = 'Edm.Boolean';
      }
      if (dTypeName === 'Edm.Boolean') {
        val = val ? 'true' : 'false';
      }
      else if (dTypeName === 'Edm.String') {
        typeName = 'String';
      }
      else {
        message(signal.warning, context, 'found Boolean, but expected type ' + dTypeName);
      }
    }
    else if (typeof val === 'number') {
      if (isComplexType(dTypeName)) {
        message(signal.warning, context, 'found number, but expected complex type ' + dTypeName);
      }
      else if (dTypeName === 'Edm.String') {
        typeName = 'String';
      }
      else if (dTypeName === 'Edm.PropertyPath') {
        message(signal.warning, context, 'found number, but expected type ' + dTypeName);
      }
      else if (dTypeName === 'Edm.Boolean') {
        message(signal.warning, context, 'found number, but expected type ' + dTypeName);
      }
      else if (dTypeName === 'Edm.Decimal') {
        typeName = 'Decimal';
      }
      else if (dTypeName === 'Edm.Double') {
        typeName = 'Float';
      }
      else {
        //typeName = Number.isInteger(val) ? 'Int' : 'Float';
        if(Number.isInteger(val)) {
          typeName = 'Int';
          if(dTypeName == undefined || dTypeName === 'Edm.PrimitiveType')
            dTypeName = 'Edm.Int64';
        }
        else {
          typeName = 'Float';
          if(dTypeName == undefined || dTypeName === 'Edm.PrimitiveType')
            dTypeName = 'Edm.Double';
        }
      }
    }
    else if(val === null && dTypeName == null && typeName === 'String') {
      dTypeName = 'Edm.String';
    } else {
      message(signal.warning, context, "expected simple value, but found value '" + val + "' with type '" + typeof val + "'");
    }

    if( ['Edm.AnnotationPath', 'Edm.ModelElementPath', 'Edm.NavigationPropertyPath', 'Edm.PropertyPath', 'Edm.Path' ].includes(dTypeName) )
      dTypeName = dTypeName.split('.')[1];

    return {
      name : typeName,
      jsonName: dTypeName,
      value : val
    };
  }


  // obj: object representing the record
  // dTypeName : name of the expected record type according to vocabulary, may be null
  //
  // can be called for a record directly below a term, or at a deeper level
  function generateRecord(obj, termName, dTypeName, context) {
    /** @type {object} */
    let newRecord = new Edm.Record(v);

    // first determine what is the actual type to be used for the record
    if (dTypeName && !isComplexType(dTypeName)) {
      if (!getDictType(dTypeName) && !isPrimitiveType(dTypeName) && !isCollection(dTypeName))
        message(signal.warning, context, "internal error: dictionary inconsistency: type '" + dTypeName + "' not found");
      else
        message(signal.warning, context, "found complex type, but expected type '" + dTypeName + "'");
      return newRecord;
    }

    let actualTypeName = null;
    if (obj['$Type']) { // type is explicitly specified
      actualTypeName = obj['$Type'];
      if (!getDictType(actualTypeName)) {
        // this type doesn't exist
        message(signal.warning, context, "explicitly specified type '" + actualTypeName + "' not found in vocabulary");
      }
      else if (dTypeName && !isDerivedFrom(actualTypeName, dTypeName)) {
        // this type doesn't fit the expected one
        message(signal.warning, context, "explicitly specified type '" + actualTypeName
                            + "' is not derived from expected type '" + dTypeName + "'");
        actualTypeName = dTypeName;
      }
      else if (isAbstractType(actualTypeName)) {
        // this type is abstract
        message(signal.warning, context, "explicitly specified type '" + actualTypeName + "' is abstract, specify a concrete type");
        actualTypeName = dTypeName;
      }
      else {
        // ok
      }
      newRecord.Type = actualTypeName;
    }
    else if (dTypeName) { // there is an expected type name according to dictionary
      // convenience for common situation:
      //   if DataFieldAbstract is expected and no explicit type is provided, automatically choose DataField
      if (dTypeName === 'UI.DataFieldAbstract') {
        actualTypeName = 'UI.DataField';
      }
      else {
        actualTypeName = dTypeName;
      }

      if (isAbstractType(actualTypeName)) {
        message(signal.warning, context, "type '" + dTypeName + "' is abstract, use '$Type' to specify a concrete type");
      }

      newRecord.Type = actualTypeName;
    }
    else {
      // no expected type set -> do not set newRecord.Type
    }

    // now the type is clear, so look ath the value
    let dictProperties = getAllProperties(actualTypeName);

    // loop over elements
    for (let i in obj) {
      context.stack.push('.' + i);

      if (i === '$Type') {
        // ignore, this is an "artificial" property used to indicate the type
      }
      else if (i.charAt(0) === '@') {
        // not a regular property, but a nested annotation
        let newAnno = handleTerm(i.substring(1, i.length), obj[i], context);
        newRecord.append(newAnno);
      }
      else {
        // regular property
        let dictPropertyTypeName = null;
        if (dictProperties) {
          dictPropertyTypeName = dictProperties[i];
          if (!dictPropertyTypeName){
            message(signal.warning, context, "record type '" + actualTypeName + "' doesn't have a property '" + i + "'");
          }
        }

        let newPropertyValue = new Edm.PropertyValue(v, i);
        // property value can be anything, so delegate handling to handleValue
        handleValue(obj[i], newPropertyValue, termName, dictPropertyTypeName, context);
        newRecord.append(newPropertyValue);
      }

      context.stack.pop();
    }

    return newRecord;
  }


  // annoValue is an array
  // dTypeName : Collection(...) according to dictionary
  function generateCollection(annoValue, termName, dTypeName, context) {
    let newCollection = new Edm.Collection(v);

    let innerTypeName = null;
    if (dTypeName) {
      var match = dTypeName.match(/^Collection\((.+)\)/);
      if (match) {
        innerTypeName = match[1];
      }
      else {
        message(signal.warning, context, 'found collection value, but expected non-collection type ' + dTypeName);
      }
    }

    let index = 0;
    for (let value of annoValue) {
      context.stack.push('[' + index++ + ']');

      // for dealing with the single array entries we unfortunately cannot call handleValue(),
      //   as the values inside an array are represented differently from the values
      //   in a record or term
      if (Array.isArray(value)) {
        message(signal.warning, context, 'nested collections are not supported');
      }
      else if (value && typeof value === 'object') {
        if (value['=']) {
          let res = handleExpression(value['='], innerTypeName, context);
          let newPropertyPath = new Edm.ValueThing(v, res.name, res.value );
          newPropertyPath.setJSON( { [res.name] : res.value } );
          newCollection.append(newPropertyPath);
        }
        else if (value['#']) {
          message(signal.warning, context, 'enum inside collection is not yet supported');
        }
        else {
          let rec = generateRecord(value, termName, innerTypeName, context);
          newCollection.append(rec);
        }
      }
      else {
        let res = handleSimpleValue(value, innerTypeName, context);
        let newThing = (value === null) ?new Edm.ValueThing(v, 'Null') : new Edm.ValueThing(v, res.name, value );
        newThing.setJSON( { [res.jsonName] : res.value });
        newCollection.append(newThing);
      }

      context.stack.pop();
    }

    return newCollection;
  }


  // Not everything that can occur in OData annotations can be expressed with
  // corresponding constructs in cds annotations. For these special cases
  // we have a kind of "inline assembler" mode, i.e. you can in cds provide
  // as annotation value a json snippet that looks like the final edm-json.
  // See example in test/odataAnnotations/smallTests/edmJson_noReverse_ok
  function handleEdmJson(obj, context)
  {
    let specialProperties = [ '$Apply', '$LabeledElement' ];
    let subset = edmUtils.intersect(specialProperties, Object.keys(obj));

    if(subset.length > 1) { // doesn't work for three or more...
      message(signal.warning, context, 'edmJson code contains more than one special property: ' + subset);
      return null;
    }
    if(subset.length === 0) {
      // only one property (that is not a special property)
      if (Object.keys(obj) != undefined && Object.keys(obj).length==1) {
        let k = Object.keys(obj)[0];
        return new Edm.ValueThing(v, k.slice(1), obj[k] );
      }
      message(signal.warning, context, 'edmJson code contains no special property out of: ' + specialProperties);
      return null;
    }

    // name of special property determines element kind
    let newElem = new Edm.Thing(v, subset[0].slice(1));
    let mainAttribute = null;

    for (let p in obj) {
      // copy all '$' attributes that are not $Apply or $LabeledElement to Thing
      if(specialProperties.every(v =>
        { return p != v }))
      {
        if (p.charAt(0) === '$') {
          // simple attribute
          newElem[p.slice(1)] = obj[p];
        }
        else {
          message(signal.warning, context, 'unexpected element without $: ' + p);
        }
      }
      else { // we are either $Apply or $LabeledElement
        // handle value of special property
        let val = obj[p];
        if (Array.isArray(val)) {
          for (let a of val) {
            if (a && typeof a === 'object' && !Array.isArray(a)) {
              newElem.append(handleEdmJson(a, context));
            }
            else if (Array.isArray(a)) {
              message(signal.warning, context, 'verbatim code contains nested array');
            }
            else {
              if (typeof a === 'string') {
                a = a.replace(/&/g, '&amp;')
              }
              newElem.append(new Edm.ValueThing(v, getTypeName(a),  a));
            }
          }
        }
        else if (val && typeof val === 'object') {
          if (Object.keys(val) != undefined && Object.keys(val).length==1) {
            let k = Object.keys(val)[0];
            mainAttribute = { name: k.slice(1), val: val[k] };
          }
          else {
            let el = handleEdmJson(val, context);
            if (el) {
              newElem.append(el);
            }
          }
        }
        else {
          mainAttribute = { name: getTypeName(val), val: val };
        }
      }
    }

    // special property has a simple value:
    //   value is added as attribute to the element; we add it
    //   only after the other attributes in order to reproduce order
    //   (which is semantically insignificant, but it's nicer this way)
    if (mainAttribute) {
      newElem[mainAttribute.name] = mainAttribute.val;
    }

    return newElem;

    function getTypeName(val) {
      let typeName = 'String';
      if (typeof val === 'boolean') {
        typeName = 'Bool';
      }
      else if (typeof val === 'number') {
        typeName = Number.isInteger(val) ? 'Int' : 'Decimal';
      }
      return typeName;
    }
  }

  //-------------------------------------------------------------------------------------------------
  //-------------------------------------------------------------------------------------------------
  //-------------------------------------------------------------------------------------------------

  // filter function, assumed to be used for array of string
  //   accepts those strings that start with a known vocabulary name
  function filterKnownVocabularies(name) {
    var match = name.match(/^(@)(\w+)/);
    if (match == null) return false;
    return knownVocabularies.includes(match[2]);  // second match group
  }

  // resolve "derived types"
  // -> if dTypeName is a TypeDefinition, replace by
  //    underlying type
  function resolveType(dTypeName) {
    let type = getDictType(dTypeName);
    if (type && type.UnderlyingType && type['$kind'] === 'TypeDefinition') {
      return type.UnderlyingType;
    }
    return dTypeName;
  }

  function isPrimitiveType(typeName) {
    return typeName.split('.')[0] === 'Edm';
  }

  function isCollection(typeName) {
    return typeName.match(/^Collection\((.+)\)/) !== null;
  }

  function isEnumType(dTypeName) {
    let type = getDictType(dTypeName);
    return type && type['$kind'] === 'EnumType';
  }

  function isComplexType(dTypeName) {
    let type = getDictType(dTypeName);
    return dTypeName === 'Edm.ComplexType' || type && type['$kind'] === 'ComplexType';
  }

  function isAbstractType(dTypeName) {
    let type = getDictType(dTypeName);
    return type && type['Abstract'] === 'true';
  }

  // return true if derived has baseCandidate as direct or indirect base type
  function isDerivedFrom(derived, baseCandidate) {
    while (derived) {
      if (derived == baseCandidate) return true;
      derived = getDictType(derived).BaseType;
    }
    return false;
  }

  // return dictionary of all properties of typeName, including those of base types
  function getAllProperties(typeName) {
    if (!typeName || !getDictType(typeName)) return null;
    return getDictType(typeName).Properties;
  }

}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

module.exports = { knownVocabularies, vocabularyDefinitions, csn2annotationEdm };
