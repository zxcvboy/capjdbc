// CSN frontend - transform CSN into XSN


// TODO: re-check extensions handling - set kind early!, ...
// TODO: restrict 'actions' etc better in annotate statements - also/only consider parent property!
// TODO: extend E { extend elem { extend sub } }

'use strict';

/**
 * Overview of properties in schema specifications (values in 'schema' dictionary):
 *
 * @typedef {object} SchemaSpec
 * @property {TransformerFunction}   [type] Transformation and test function (i.e. type). The first
 *                                          four arguments are the same for all functions. Further
 *                                          ones may be accepted as well.
 * @property {string}               [class] A schemaClass. Possible values are keys of the variable
 *                                          "schemaClasses". Essentially all properties of the class
 *                                          are copied.
 * @property {Function}           [arrayOf] Alternative to "type". The property should be an array.
 *                                          Value is passed to arrayOf()
 * @property {Function}      [dictionaryOf] Alternative to "type". The property should be an object
 *                                          in dictionary form (i.e. Object.<string, type>).
 *                                          Value is passed to arrayOf()
 * @property {Object.<string, SchemaSpec>} [schema] If some sub-properties have a different
 *                                                  semantic in this property than the default then
 *                                                  switch the currently used spec to this value.
 * @property {string}                [prop] Name of the property. compileSchema() sets it to the
 *                                          dictionary key by default.
 * @property {string}               [msgId] Use this message id instead of the default one.
 *                                          Allows more precise and detailed error messages.
 * @property {string|string[]|false} [requires] If the value is a string, then the given sub-
 *                                              property is required. If 'undefined', then at
 *                                              least one property is required. If false the no
 *                                              sub-properties are required.
 * @property {boolean}           [noPrefix] Only used for '#' at the moment. Signals that the entry
 *                                          should not be used for keys like '#key'. getSchema(...)
 *                                          normally checks if schema[prop] exists and if not,
 *                                          checks for schema[prop.charAt(0)]. This is intended for
 *                                          annotations and similar (which start with special
 *                                          characters).
 * @property {boolean}             [ignore] Don't issue warnings.
 * @property {string[]}          [optional] Optional sub-properties that may be used. Warnings are
 *                                          issued if unknown properties are set.
 * @property {string}         [defaultKind] Default kind for sub-elements, e.g. objects in
 *                                          "elements".
 * @property {string[]|Function}   [inKind] Specifies in what definition type this property may
 *                                          be used, e.g. "virtual" may only be used for elements.
 *                                          If it is a function then it takes two arguments "kind"
 *                                          and "parentSpec" should return a boolean
 * @property {string[]}        [validKinds] What "kind" values are possible in a definition. The
 *                                          root "definitions" properties allows more kinds than
 *                                          e.g. definitions inside "elements".
 * @property {string|string[]}   [onlyWith] Defines that the property *must* be used with these
 *                                          properties.
 * @property {number}           [minLength] Minimum number of elements that an array must have.
 * @property {boolean}            [inValue] Puts the value into an XSN property "value",
 *                                          e.g. { value: ... }
 * @property {string}            [xorGroup] Corresponding xor group. It references a value of
 *                                          $xorGroups. If set then only one property of of the
 *                                          xorGroup may be set, e.g. if target is set, elements
 *                                          may not.
 * @property {string}               [xsnOp] Defines the operator to be used for XSN. Used for SET
 *                                          and SELECT. See queryTerm().
 * @property {string|false}      [vZeroFor] Marks the property as a CSN 0.1.0 property. It is
 *                                          replaced by this CSN 1.0 property (value of vZeroFor).
 *                                          "false" indicates that the property may be a v0.1 one
 *                                          which is handled specially, e.g. with "type:vZeroValue"
 * @property {string}         [vZeroIgnore] Marks the property as a CSN 0.1.0 property. The
 *                                          property is ignored and a warning may be issues about
 *                                          it.
 */

/**
 * @typedef {Function} TransformerFunction
 * @param {object} obj
 * @param {object} xsn
 * @param {object} csn
 * @param {object} prop
 * @param {...any} any Further arguments.
 * @returns {any} XSN property (e.g. string, object, ...)
 */

const { normalizeLocation } = require('../base/location');
const { getMessageFunction } = require('../base/messages');
const { addToDict } = require('../base/dictionaries');

let inExtensions = null;

// Sync with definition in to-csn.js:
const typeProperties = [
  // do not include CSN v0.1.0 properties here:
  'target', 'elements', 'enum', 'items',
  'type', 'length', 'precision', 'scale', 'srid', 'localized', 'notNull',
  'keys', 'on',                 // only with 'target'
];
const exprProperties = [
  // do not include CSN v0.1.0 properties here:
  'ref', 'xpr', 'val', '#', 'func', 'SELECT', 'SET', // Core Compiler checks SELECT/SET
  'param', 'global', 'literal', 'args',             // only with 'ref'/'ref'/'val'/'func'
];

// Groups of properties which cannot be used together:
const xorGroups = {
  // include CSN v0.1.0 properties here:
  ':type': [ 'target', 'elements', 'enum', 'items' ],
  ':expr': [
    'ref', 'xpr', 'val', '#', 'func', 'SELECT', 'SET',
    '=', 'path', 'value', 'op', // '='/'path' is CSN v0.1.0 here
  ],
  ':ext': [ 'annotate', 'extend' ],
  ':assoc': [ 'on', 'keys', 'foreignKeys', 'onCond' ], // 'foreignKeys'/'onCond' is CSN v0.1.0
  ':join': [ 'join', 'as' ],
  scope: [ 'param', 'global' ],
  quantifier: [ 'some', 'any', 'distinct', 'all' ],
  // quantifiers 'some' and 'any are 'xpr' token strings in CSN v1.0
};

const schemaClasses = {
  condition: {
    arrayOf: exprOrString,
    type: condition,
    msgId: 'syntax-csn-expected-term',
    optional: exprProperties,
  },
  expression: {
    type: expr,
    optional: exprProperties,
  },
  natnumOrStar: {
    type: natnumOrStar,
    msgId: 'syntax-csn-expected-cardinality',
  },
};

// TODO: also have stricter tests for strings in in xpr/args, join, op, sort, nulls ?

const schema = compileSchema( {
  requires: {
    type: renameTo( 'dependencies', arrayOf( stringVal, val => (val.literal === 'string') ) ),
  },
  // definitions: ------------------------------------------------------------
  definitions: {
    dictionaryOf: definition,
    defaultKind: 'type',
    validKinds: [
      'entity', 'type', 'action', 'function', 'context', 'service', 'event', 'annotation',
    ],
    // requires: { entity: ['elements', 'query', 'includes'] } - not, make it work w/o elements
  },
  extensions: {
    arrayOf: definition,
    defaultKind: 'annotate',
    validKinds: [],             // use annotate/extend instead of kind
    requires: [ 'extend', 'annotate' ],
  },
  enum: {
    dictionaryOf: definition,
    defaultKind: 'enum',
    validKinds: [ 'enum' ],
    inKind: [ 'element', 'type', 'param', 'annotation', 'annotate' ],
  },
  elements: {
    dictionaryOf: definition,
    defaultKind: 'element',
    validKinds: [ 'element' ],
    inKind: [ 'element', 'type', 'entity', 'param', 'annotation', 'annotate', 'extend' ],
  },
  payload: {
    dictionaryOf: definition,
    type: renameTo( 'elements', dictionary ),
    defaultKind: 'element',
    validKinds: [],
    inKind: [ 'event' ],
  },
  actions: {
    dictionaryOf: definition,
    defaultKind: 'action',
    validKinds: [ 'action', 'function' ],
    inKind: [ 'entity', 'annotate', 'extend' ],
  },
  params: {
    dictionaryOf: definition,
    defaultKind: 'param',
    validKinds: [ 'param' ],
    inKind: [ 'entity', 'action', 'function', 'annotate' ], // TODO: 'extend'?
  },
  mixin: {
    dictionaryOf: definition,
    defaultKind: 'element',
    validKinds: [],             // XSN TODO: kind 'mixin' by parser
  },
  columns: {
    arrayOf: selectItem,
    msgId: 'syntax-csn-expected-column',
    defaultKind: '$column',
    validKinds: [], // pseudo kind '$column'
    requires: [ 'ref', 'xpr', 'val', '#', 'func', 'SELECT', 'SET' ], // requires one of...
    inKind: [ 'extend' ], // only valid in extend and SELECT
  },
  keys: {
    arrayOf: definition,
    type: keys,
    defaultKind: 'key',
    validKinds: [],
    requires: 'ref',
    onlyWith: 'target',
    inKind: [ 'element', 'type' ],
  },
  foreignKeys: {                 // CSN v0.1.0 property -> use 'keys'
    vZeroFor: 'keys',
    inKind: [],
    dictionaryOf: definition,
    defaultKind: 'key',
    validKinds: [],
  },
  // kind and name: ----------------------------------------------------------
  kind: {
    type: validKind,
    inKind: (( kind, parentSpec ) => !inExtensions && parentSpec.validKinds.length),
  },
  annotate: {
    type: kindAndName,
    inKind: (kind => kind === 'annotate'), // using array would test 'entity' for extensions[]
  },
  extend: {
    type: kindAndName,
    inKind: [ 'extend' ],
  },
  as: {
    // remark: 'as' does not count as "proper" property in standard check that
    // an object has >0 props (hard-coded)
    type: explicitName,
    inKind: [ '$column', 'key' ],
  },
  // type properties (except: elements, enum, keys, on): ---------------------
  type: {
    type: artifactRef,
    msgId: 'syntax-csn-expected-reference',
    optional: [ 'ref', 'global' ],
    inKind: [ 'element', 'type', 'param', 'mixin', 'annotation' ],
  },
  targetAspect: {
    type: artifactRef,
    optional: [ 'elements' ], // 'elements' for ad-hoc aspect compositions
    inKind: [ 'element', 'type' ],
  },
  target: {
    type: artifactRef,
    optional: [ 'elements' ], // 'elements' for ad-hoc COMPOSITION OF (gensrc style CSN)
    inKind: [ 'element', 'type', 'mixin' ],
  },
  cardinality: {
    type: object,
    optional: [ 'src', 'min', 'max' ],
    inKind: [ 'element', 'type', 'mixin' ],
    onlyWith: [ 'target', 'targetAspect', 'id' ], // also in 'ref[]'
  },
  items: {
    type: object,
    optional: typeProperties, // TODO: think of items: {}, then requires: false
    inKind: [ 'element', 'type', 'param', 'annotation' ],
  },
  localized: {
    type: boolOrNull,
    inKind: [ 'element', 'type', 'param', 'annotation' ],
  },
  length: {
    type: natnum,
    inKind: [ 'element', 'type', 'param', 'annotation' ],
    // we do not require a 'type', too - could be useful alone in a 'cast'
  },
  precision: {
    type: natnum,
    inKind: [ 'element', 'type', 'param', 'annotation' ],
  },
  scale: {
    type: natnum,
    inKind: [ 'element', 'type', 'param', 'annotation' ],
  },
  srid: {
    type: natnum,
    inKind: [ 'element', 'type', 'param', 'annotation' ],
  },
  src: {                        // in 'cardinality'
    class: 'natnumOrStar',
    type: renameTo( 'sourceMax', natnumOrStar ),
  },
  min: {                        // in 'cardinality'
    type: renameTo( 'targetMin', natnum ),
  },
  max: {                        // in 'cardinality'
    class: 'natnumOrStar',
    type: renameTo( 'targetMax', natnumOrStar ),
  },
  sourceMax: {
    class: 'natnumOrStar',
    vZeroFor: 'src',
  },
  targetMin: {
    vZeroFor: 'min',
    type: natnum,
  },
  targetMax: {
    class: 'natnumOrStar',
    vZeroFor: 'max',
  },
  // expression properties (except: SELECT, SET): ----------------------------
  ref: {
    arrayOf: refItem,
    type: renameTo( 'path', arrayOf( refItem ) ),
    msgId: 'syntax-csn-expected-reference',
    minLength: 1,
    requires: 'id',
    optional: [ 'id', 'args', 'cardinality', 'where' ],
    inKind: [ '$column', 'key' ],
  },
  id: {                         // in 'ref' item
    type: string,
  },
  param: {
    type: asScope,              // is bool, stored as string in XSN property 'scope'
    onlyWith: 'ref',
    inKind: [ '$column' ],
  },
  global: {
    type: asScope,              // is bool, stored as string in XSN property 'scope'
    onlyWith: 'ref',
    inKind: [ '$column' ],
  },
  func: {
    type: func,
    inKind: [ '$column' ],
  },
  args: {
    class: 'condition',
    type: args,
    schema: {                   // named arguments cannot directly have a string
      '-named': {               // '-named' and '-' must not exist top-level
        prop: 'args', dictionaryOf: expr, optional: exprProperties,
      },
    },
    onlyWith: [ 'func', 'id', 'op' ],
    inKind: [ '$column' ],
  },
  xpr: {
    class: 'condition',
    type: xpr,
    inKind: [ '$column' ],
  },
  val: {
    type: value,
    inKind: [ '$column', 'enum', 'element' ],
  },
  literal: {
    type: literal,
    onlyWith: 'val',
    inKind: [ '$column', 'enum' ],
  },
  '#': {
    noPrefix: true,             // schema spec for '#', not for '#whatever'
    type: symbol,
    inKind: [ '$column' ],
  },
  path: {                     // in CSN v0.1.0 'foreignKeys'
    vZeroFor: 'ref',
    inKind: [],
    inValue: true,
    type: vZeroRef,
  },
  '=': {                        // v0.1.0 { "=": "A.B" } for v1.0 { "ref": ["A", "B"] }
    vZeroFor: 'ref',
    inKind: [],                 // still used in annotation assignments...
    type: vZeroRef,             // ...see property '@' / function annotation()
  },
  // primary query properties: -----------------------------------------------
  query: {
    type: object,
    optional: [ 'SELECT', 'SET' ],
    inKind: [ 'entity' ],
  },
  SELECT: {
    type: queryTerm,
    xsnOp: 'query',             // TODO: 'SELECT'
    requires: 'from',
    optional: [
      'from', 'mixin', 'all', 'distinct', 'columns', 'excluding',
      'where', 'groupBy', 'having', 'orderBy', 'limit',
    ],
    inKind: [ '$column' ],
  },
  SET: {
    type: queryTerm,
    xsnOp: 'subquery',          // might be overwritten by 'op'
    requires: 'args',
    optional: [ 'op', 'all', 'distinct', 'args', 'orderBy', 'limit' ],
    schema: {
      args: {
        arrayOf: object,
        type: queryArgs,
        minLength: 1,
        optional: [ 'SELECT', 'SET' ],
      },
    },
    inKind: [ '$column' ],
  },
  op: {                                   // used for UNION etc in CSN v1.0
    vZeroFor: 'xpr',
    vZeroIgnore: 'call', // is also used in CSN v0.1.0 for "normal" expressions
    type: setOp,
    onlyWith: 'args',
  },
  join: {
    type: join,                 // string like 'cross' - TODO: test for valid ones?
  },
  from: {
    type: from,                // XSN TODO: no array anymore, then type: object
    optional: [ 'ref', 'global', 'join', 'args', 'on', 'SELECT', 'SET', 'as' ],
    schema: {
      args: {
        arrayOf: object,
        minLength: 2,
        optional: [ 'ref', 'global', 'join', 'args', 'on', 'SELECT', 'SET', 'as' ],
        onlyWith: 'join',
        schema: {},             // 'args' in 'args' in 'from' is same as 'args' in 'from'
      },
      on: {                     // remove if XSN TODO onCond -> on has been done
        class: 'condition',     // no renaming to onCond in XSN
        onlyWith: [ 'join' ],
      },
    },
  },
  some: { type: asQuantifier }, // probably just CSN v0.1.0
  any: { type: asQuantifier },  // probably just CSN v0.1.0
  distinct: { type: asQuantifier },
  all: { type: asQuantifier },           // XSN TODO: use quantifier also for UNION etc
  // further query properties: -----------------------------------------------
  excluding: {
    arrayOf: string,
    type: excluding,            // XSN TODO: exclude->excluding
  },
  on: {
    class: 'condition',
    type: onCondition,         // XSN TODO: 'onCond'->'on', then remove schema 'on' in 'from'
    onlyWith: [ 'target', 'join' ],
    inKind: [ 'element', 'mixin' ],
  },
  onCond: {
    vZeroFor: 'on',
    inKind: [],
    type: expr,
    optional: exprProperties,
  },
  where: {
    class: 'condition',
  },
  groupBy: {
    arrayOf: expr, optional: exprProperties,
  },
  having: {
    class: 'condition',
  },
  orderBy: {            // TODO XSN: make `sort` and `nulls` sibling properties
    arrayOf: orderBy, optional: [ 'sort', 'nulls', ...exprProperties ],
  },
  sort: {
    type: stringVal,
  },
  nulls: {
    type: stringVal,            // TODO: test for valid ones?
  },
  limit: {                      // XSN TODO: structure like CSN, then type: object
    type: embed, requires: 'rows', optional: [ 'rows', 'offset' ],
  },
  rows: {
    class: 'expression',
    type: renameTo( 'limit', expr ),
  },
  offset: {
    class: 'expression',
  },
  // miscellaneous properties in definitions: --------------------------------
  doc: {
    type: stringVal,
    inKind: () => true,         // allowed in all definitions (including columns and extensions)
  },
  '@': {                        // for all properties starting with '@'
    prop: '@<anno>',            // which property name do messages use for annotation assignments?
    type: annotation,
    inKind: () => true,         // allowed in all definitions (including columns and extensions)
  },
  abstract: {
    type: boolOrNull,
    inKind: [ 'entity', 'service' ],
  },
  // dbType: boolOrNull,                // TODO: currently with --hana-flavor only
  key: {
    type: boolOrNull,
    inKind: [ 'element', '$column' ],
  },
  masked: {
    type: boolOrNull,
    inKind: [ 'element' ],
  },
  notNull: {
    type: boolOrNull,
    inKind: [ 'element', 'param' ], // TODO: $column  - or if so: in 'cast'?
  },
  // unique: boolOrNull,                // TECHNICAL CONFIGURATION only
  virtual: {
    type: boolOrNull,
    inKind: [ 'element' ],
  },
  cast: {
    type: embed,
    optional: typeProperties,
    inKind: [ '$column' ],
  },
  default: {
    class: 'expression',
    inKind: [ 'element' ],
  },
  includes: {
    arrayOf: stringRef,
    inKind: [ 'entity', 'type', 'extend' ],
  },
  returns: {
    type: object,
    optional: [ ...typeProperties ],
    inKind: [ 'action', 'function' ],
  },
  technicalConfig: {            // TODO: spec, re-check
    type: extra,
    inKind: [ 'entity' ],
  },
  $syntax: {
    type: string,
    ignore: true,
    inKind: [ 'entity', 'type' ],
  },
  origin: {                     // old-style CSN
    type: vZeroDelete, ignore: true,
  },
  source: {                     // CSN v0.1.0 query not supported
    type: ignore,
  },
  value: {
    vZeroFor: false,                // CSN v0.1.0 property, but handled specially
    type: vZeroValue,
    optional: exprProperties,
    inKind: [ '$column', 'enum' ],
  },
  // ignored: ----------------------------------------------------------------
  $location: {                  // special
    ignore: true, type: ignore,
  },
  $generatedFieldName: {
    ignore: true, type: ignore, // TODO: do we need to do something?
  },
  namespace: {                  // unspecified top-level property by Umbrella
    type: ignore,
  },
  meta: {                       // meta information
    type: ignore,               // TODO: should we test s/th here?
  },
  version: {                    // deprecated top-level property
    type: ignore,
  },
  messages: {                   // deprecated top-level property
    type: ignore,
  },
  options: {                    // deprecated top-level property
    type: ignore,
  },
  indexNo: {                    // CSN v0.1.0, but ignored without message
    ignore: true, type: ignore,
  },
  $: { type: ignore, ignore: true }, // including $env
  _: { type: ignore, ignore: true },
} );

const topLevelSpec = {
  msgProp: '',                  // falsy '' for top-level
  type: object,
  optional: [
    'requires', 'definitions', 'extensions',
    'namespace', 'version', 'messages', 'meta', 'options', '@', '$location',
  ],
  requires: false,              // empty object OK
  schema,
};

const validLiteralsExtra = Object.assign( Object.create(null), {
  // TODO: should we use quotedLiteralPatterns from genericAntlrParser?
  number: 'string',
  x: 'string',
  time: 'string',
  date: 'string',
  timestamp: 'string',
} );

// Module variables, schema compilation, and functors ------------------------

/** @type {(id, location, home, params?: object, severity?: any, texts?: any ) => any} */
let message = () => undefined;

let csnVersionZero = false;
let csnFilename = '';
let virtualLine = 1;
/** @type {XSN.Location[]} */
let dollarLocations = [];

/**
 * @param {Object.<string, SchemaSpec>} specs
 * @param {object} [proto]
 * @returns {Object.<string, SchemaSpec>}
 */
function compileSchema( specs, proto = null) {
  // no prototype to protect against evil-CSN properties 'toString' etc.
  const r = Object.assign( Object.create( proto ), specs );
  for (const p of Object.keys( specs )) {
    const s = r[p];
    if (s.class) {
      const scs = schemaClasses[s.class];
      for (const c of Object.keys( scs )) {
        if (s[c] == null)
          s[c] = scs[c];
      }
    }
    if (s.prop == null)
      s.prop = p;
    if (s.msgProp == null)
      s.msgProp = (s.arrayOf || s.dictionaryOf) ? `${ s.prop }[]` : s.prop;
    if (s.schema)
      s.schema = compileSchema( s.schema, r );
    if (!s.type) {
      if (s.arrayOf)
        s.type = arrayOf( s.arrayOf );
      else if (s.dictionaryOf)
        s.type = dictionary;
      else
        throw new Error( `Missing type specification for property "${ p }` );
    }
  }
  if (proto)
    return r;
  for (const group in xorGroups) {
    for (const prop of xorGroups[group]) {
      if (r[prop].xorGroup === undefined)
        r[prop].xorGroup = group;
    }
  }
  for (const prop of exprProperties) {
    if (r[prop].inValue === undefined)
      r[prop].inValue = true;
  }
  return r;
}

function renameTo( xsnProp, fn ) {
  return function renamed( val, spec, xsn, csn ) {
    const r = fn( val, spec, xsn, csn );
    if (r !== undefined)
      xsn[xsnProp] = r;
  };
}

function arrayOf( fn, filter = undefined ) {
  return function arrayMap( val, spec, xsn, csn ) {
    if (!isArray( val, spec ))
      return undefined;
    const r = val.map( (v) => {
      ++virtualLine;
      return fn( v, spec, xsn, csn ) || { location: location() };
    } );
    const minLength = spec.minLength || 0;
    if (minLength > val.length) {
      message( 'syntax-csn-expected-length', location(true), null,
               { prop: spec.prop, n: minLength, '#': minLength === 1 ? 'one' : 'std' },
               'Error', {
                 std: 'Expected array in $(PROP) to have at least $(N) items',
                 one: 'Expected array in $(PROP) to have at least one item',
               } );
    }
    if (val.length)
      ++virtualLine;          // [] in one JSON line
    if (filter)
      return r.filter(filter);
    return r;
  };
}

// Generic functions, objects (std signature) --------------------------------

function ignore( obj ) {
  if (obj && typeof obj === 'object') {
    const array = (Array.isArray( obj )) ? obj : Object.values( obj );
    if (!array.length)
      return;                   // {}, [] in one JSON line
    virtualLine += 1 + array.length;
    array.forEach( ignore );
  }
}

function embed( obj, spec, xsn, csn ) {
  if (spec.prop === 'cast')     // XSN TODO: make sure that $inferred is enough
    xsn[csn.cast.target ? 'redirected' : '_typeIsExplicit'] = true;
  Object.assign( xsn, object( obj, spec ) ); // TODO: $location?
}

function extra( node, spec, xsn ) {
  if (!xsn.$extra)
    xsn.$extra = Object.create(null);
  xsn.$extra[spec.prop] = node;
}

function object( obj, spec ) {
  if (!isObject( obj, spec ))
    return undefined;
  pushLocation( obj );
  const r = { location: location() };
  const xor = {};
  const csnProps = Object.keys( obj );
  if (csnProps.length) {
    ++virtualLine;
    const expected = (p => spec.optional.includes(p));
    for (const p of csnProps) {
      const s = getSpec( spec, obj, p, xor, expected );
      const val = s.type( obj[p], s, r, obj, p );
      if (val !== undefined)
        r[p] = val;
      ++virtualLine;
    }
  }
  const { requires } = spec;
  if (requires === undefined || requires === true) {
    // console.log(csnProps,JSON.stringify(spec))
    if (!csnProps.length || csnProps.length === 1 && csnProps[0] === 'as') {
      message( 'syntax-csn-required-subproperty', location(true), null,
               { prop: spec.msgProp, '#': csnProps.length ? 'as' : 'std' },
               'Error', {
                 std: 'Object in $(PROP) must have at least one property',
                 as: 'Object in $(PROP) must have at least one property other than \'as\'',
               } );
    }
  }
  else if (requires) {
    // console.log(csnProps,JSON.stringify(spec))
    onlyWith( spec, requires, obj, null, xor, () => true );
  }
  popLocation( obj );
  return r;
}

function vZeroDelete( o, spec ) { // for old-CSN property 'origin'
  if (!csnVersionZero) {
    message( 'syntax-csn-zero-delete', location(true), null, { prop: spec.msgProp },
             'Warning', 'Delete/inline CSN v0.1.0 property $(PROP)' );
  }
  string( o, spec );
}

// Definitions, dictionaries and arrays of definitions (std signature) -------

function definition( def, spec, xsn, csn, name ) {
  if (!isObject( def, spec )) {
    return {
      kind: (inExtensions ? 'annotate' : spec.defaultKind),
      name: {
        id: '', path: [], absolute: name, location: location(),
      },
      location: location(),
    };
  }
  pushLocation( def );
  const savedInExtensions = inExtensions;
  const kind = calculateKind( def, spec ); // might set inExtensions
  const r = (kind === '$column') ? { location: location() } : { location: location(), kind };
  const xor = {};
  const { prop } = spec;
  const kind0 = (spec.validKinds.length || spec.prop === 'extensions') && kind;
  const csnProps = Object.keys( def );

  if (csnProps.length) {
    const valueName = (prop === 'keys' || prop === 'foreignKeys' ? 'targetElement' : 'value');
    // the next is basically object() + the inValue handling
    ++virtualLine;
    for (const p of csnProps) {
      const s = getSpec( spec, def, p, xor, expected, kind0 );
      const v = !s.inValue && r || r[valueName] || (r[valueName] = { location: location() });
      const val = s.type( def[p], s, v, def, p );
      if (val !== undefined)
        v[p] = val;
      ++virtualLine;
    }
  }
  if (!r.name && name) {
    r.name = { id: name, location: r.location };
    if (prop === 'columns' || prop === 'keys' || prop === 'foreignKeys')
      r.name.$inferred = 'as';
    // TODO the following 'if' (if necessary) should be part of the core compiler
    if (prop === 'definitions') {
      // xsn.name.path = name.split('.').map( id => ({ id, location: location() }) );
      r.name = {
        absolute: name,
        id: name.substring( name.lastIndexOf('.') + 1 ),
        path: [ { id: name, location: r.location } ],
        location: r.location,
      };
    }
  }
  if (spec.requires)
    onlyWith( spec, spec.requires, def, null, xor, () => true );

  inExtensions = savedInExtensions;
  popLocation( def );
  return r;

  function expected( p, s ) {
    if (!Array.isArray(s.inKind))
      return s.inKind && s.inKind( kind, spec );
    return s.inKind.includes( kind ) &&
      // for an 'annotate', both 'annotate' and the "host" kind must be expected
      (!inExtensions || s.inKind.includes( inExtensions ));
  }
}

function dictionary( dict, spec, xsn, csn ) {
  if (!dict || typeof dict !== 'object' || Array.isArray( dict )) {
    message( 'syntax-csn-expected-object', location(true), null,
             { prop: spec.prop }, 'Error' ); // spec.prop, not spec.msgProp!
    return ignore( dict );
  }
  if (csn.SELECT)               // do not augment hidden 'elements' for 'SELECT'
    return undefined;
  const r = Object.create(null);
  const allNames = Object.keys( dict );
  if (!allNames.length)
    return r;                   // {} in one JSON line
  ++virtualLine;
  for (const name of allNames) {
    if (!name) {
      message( 'syntax-csn-empty-name', location(true), null,
               { prop: spec.prop }, 'Warning', // TODO: Error
               'Property names in dictionary $(PROP) must not be empty' );
    }
    r[name] = definition( dict[name], spec, r, dict, name );
    ++virtualLine;
  }
  return r;
}

function keys( array, spec, xsn ) {
  if (!isArray( array, spec ))
    return;
  const r = Object.create(null);
  ++virtualLine;
  for (const def of array) {
    const id = def.as || implicitName( def.ref );
    const name = (typeof id === 'string') ? id : '';
    // definer will complain about repeated names
    addToDict( r, name, definition( def, spec, r, array, name ) );
    ++virtualLine;
  }
  xsn.foreignKeys = r;
}

function selectItem( def, spec, xsn, csn ) {
  if (def === '*')
    return { val: '*', location: location() };

  return definition( def, spec, xsn, csn, null ); // definer sets name
}

// Kind, names and references (std signature) --------------------------------

function kindAndName( id, spec, xsn ) {
  const { prop } = spec;
  xsn.kind = prop;              // TODO: set this in definition
  if (!string( id, spec ))
    return;
  xsn.name = { path: [ { id, location: location() } ], location: location() };
}

function explicitName( id, spec, xsn ) {
  if (string( id, spec ))
    xsn.name = { id, location: location() };
}

function validKind( val, spec, xsn ) {
  if (val === xsn.kind)         // has been set in definition - the same = ok!
    return undefined;           // already set in definition
  if (val === 'view' && xsn.kind === 'entity') {
    message( 'syntax-csn-zero-value', location(true), null, { prop: spec.msgProp },
             'Warning', 'Replace CSN v0.1.0 value in $(PROP) by something specified' );
  }
  else {
    message( 'syntax-csn-expected-valid', location(true), null, { prop: spec.msgProp },
             'Error', 'Expected valid string for property $(PROP)' );
  }
  return ignore( val );
}

function artifactRef( ref, spec ) {
  if (!ref || typeof ref !== 'string')
    return object( ref, spec );
  if (spec.prop !== 'type' || !csnVersionZero)
    return stringRef( ref, spec );
  // now the CSN v0.1.0 type of: 'Artifact..e1.e2'
  const idx = ref.indexOf('..');
  if (idx < 0)
    return stringRef( ref, spec );
  const r = refSplit( ref.substring( idx + 2 ), spec.msgProp );
  r.path.unshift( { id: ref.substring( 0, idx ), location: location() } );
  return r;
}

function stringRef( ref, spec ) {
  return string( ref, spec ) &&
    { path: [ { id: ref, location: location() } ], location: location() };
}

function refItem( item, spec ) {
  if (typeof item === 'string' && item)
    return { id: item, location: location() };
  return object( item, spec );
}

function asScope( scope, spec, xsn ) {
  if (scope)
    xsn.scope = spec.prop;
  boolOrNull( scope, spec );
}

function vZeroRef( name, spec, xsn ) {
  if (!string( name, spec ))
    return;
  const path = name.split('.');
  if (!path.every( id => id)) {
    message( 'syntax-csn-expected-name', location(true), null, { prop: spec.msgProp },
             'Warning', 'Expected correct name for property $(PROP)' );
  }
  xsn.path = path.map( id => ({ id, location: location() }) );
}

// Specific values and annotations (std signature) ---------------------------

function boolOrNull( val, spec ) {
  if ([ true, false, null ].includes( val ))
    return { val, location: location() };
  message( 'syntax-csn-expected-boolean', location(true), null, { prop: spec.msgProp },
           'Warning', 'Expected boolean or null for property $(PROP)' );
  ignore( val );
  return { val: !!val, location: location() };
}

function string( val, spec ) {
  if (typeof val === 'string' && val)
    //  XSN TODO: do not require literal
    return val;
  message( 'syntax-csn-expected-string', location(true), null, { prop: spec.msgProp },
           'Error', 'Expected non-empty string for property $(PROP)' );
  return ignore( val );
}

function stringVal( val, spec ) {
  if (typeof val === 'string' && val)
    //  XSN TODO: do not require literal
    return { val, literal: 'string', location: location() };
  message( 'syntax-csn-expected-string', location(true), null, { prop: spec.msgProp },
           'Error', 'Expected non-empty string for property $(PROP)' );
  return ignore( val );
}

function natnum( val, spec ) {
  if (typeof val === 'number' && val >= 0)
    //  XSN TODO: do not require literal
    return { val, literal: 'number', location: location() };
  message( spec.msgId || 'syntax-csn-expected-natnum', location(true), null,
           { prop: spec.msgProp }, 'Error' );
  return ignore( val );
}

// Use with spec.msgId !
function natnumOrStar( val, spec ) {
  return (val === '*')
    ? { val, literal: 'string', location: location() }
    : natnum( val, spec );
}

function symbol( id, spec, xsn ) { // for CSN property '#'
  if (!string( id, spec ))
    return;
  xsn.literal = 'enum';         // CSN cannot have both '#' and 'literal'
  xsn.symbol = { id, location: location() };
}

function annoValue( val, spec ) {
  if (val == null)              // TODO: reject undefined
    return { val, literal: 'null', location: location() };
  const lit = typeof val;
  if (lit !== 'object')
    return { val, literal: lit, location: location() };
  if (Array.isArray( val )) {
    return {
      location: location(),
      val: arrayOf( annoValue )( val, spec ),
      literal: 'array',
    };
  }
  if (typeof val['#'] === 'string') {
    if (Object.keys( val ).length === 1) {
      virtualLine += 2;
      return {
        symbol: { id: val['#'], location: location() },
        literal: 'enum',
        location: location(),
      };
    }
  }
  else if (typeof val['='] === 'string') {
    if (Object.keys( val ).length === 1) {
      virtualLine += 2;
      return refSplit( val['='], '=' );
    }
  }
  const struct = Object.create(null);
  ++virtualLine;
  for (const name of Object.keys( val )) {
    struct[name] = annotation( val[name], schema['@'], null, val, name );
    ++virtualLine;
  }
  return { struct, literal: 'struct', location: location() };
}

function annotation( val, spec, xsn, csn, name ) {
  const variantIndex = name.indexOf('#') + 1 || name.length;
  const n = refSplit( name.substring( (xsn ? 1 : 0), variantIndex ), spec.msgProp );
  if (!n)
    return undefined;
  if (variantIndex < name.length)
    n.variant = { id: name.substring( variantIndex ), location: location() };
  const r = annoValue( val, spec );
  r.name = n;
  return r;
}

// Expressions, conditions (std signature) -----------------------------------

function value( val, spec, xsn ) { // for CSN property 'val'
  if (!xsn.literal)             // might be overwritten
    xsn.literal = (val === null) ? 'null' : typeof val;
  if ((val == null) ? val === null : typeof val !== 'object')
    return val;
  message( 'syntax-csn-expected-scalar', location(true), null, { prop: spec.msgProp },
           'Error', 'Only scalar values are supported for property $(PROP)' );
  return ignore( val );
}

function literal( val, spec, xsn, csn ) {
  // TODO: general: requires other property (here: 'val')
  const type = (csn.val == null) ? 'null' : typeof csn.val;
  if (val === type)            // also for 'object' which is an error for 'val'
    return val;
  if (typeof val === 'string' && validLiteralsExtra[val] === type)
    return (val === 'x' ? 'raw' : val); // XSN TODO: 'raw'->'x'
  message( 'syntax-csn-expected-valid', location(true), null, { prop: spec.msgProp },
           'Error', 'Expected valid string for property $(PROP)' );
  return ignore( val );
}

function func( val, spec, xsn ) {
  if (!string( val, spec ))
    return undefined;
  xsn.op = { val: 'call', location: location() };
  return { path: [ { id: val, location: location() } ], location: location() };
}

function xpr( exprs, spec, xsn ) {
  xsn.op = { val: 'xpr', location: location() };
  xsn.args = arrayOf( exprOrString )( exprs, spec, xsn );
}

function args( exprs, spec, xsn ) {
  if (Array.isArray( exprs )) {
    return arrayOf( exprOrString )( exprs, spec );
  }
  else if (!exprs || typeof exprs !== 'object') {
    message( 'syntax-csn-expected-args', location(true), null,
             { prop: spec.prop }, 'Error', // spec.prop, not spec.msgProp!
             'Expected array or object for property $(PROP)' );
    return ignore( exprs );
  }
  const r = Object.create(null);
  ++virtualLine;
  const s = spec.schema['-named'];
  for (const id of Object.keys( exprs )) {
    const a = expr( exprs[id], s );
    if (a) {
      a.name = { id, location: a.location };
      r[id] = a;
    }
    ++virtualLine;
  }
  xsn.namedArgs = r;            // XSN TODO: 'namedArgs'->'args'
  return undefined;
}

function expr( e, spec ) {
  if (Array.isArray( e ) && e.length === 1) {
    replaceZeroValue( spec );
    ++virtualLine;
    const r = expr( e[0], spec );
    ++virtualLine;
    return [ r || { location: location() } ];
  }
  else if (e === null || [ 'string', 'number', 'boolean' ].includes( typeof e )) {
    //  && spec.optional.includes( 'val' )) ?
    replaceZeroValue( spec );
    return annoValue( e, spec );
  }
  return object( e, spec );
}

function exprOrString( e, spec ) {
  return (typeof e === 'string' && !csnVersionZero) ? e : expr( e, spec );
}

function condition( cond, spec ) {
  const loc = location();
  return {
    op: { val: 'xpr', location: loc },
    args: arrayOf( exprOrString )( cond, spec ),
    location: loc,
  };
}

function onCondition( cond, spec, xsn ) {
  xsn.onCond = condition( cond, spec );
  return undefined;
}

function vZeroValue( obj, spec, xsn ) {
  if (xsn.value) {
    // TODO: also "sign" xsn.value created by inValue to complain about both 'value' and 'ref' etc
    message( 'syntax-csn-unexpected-property', location(true), null, { prop: spec.msgProp },
             'Warning', 'Unexpected CSN property $(PROP)' );
    return undefined;
  }
  if (!csnVersionZero) {
    message( 'syntax-csn-zero-delete', location(true), null, { prop: spec.msgProp },
             'Warning', 'Delete/inline CSN v0.1.0 property $(PROP)' );
  }
  return expr( obj, spec );
}

// Queries (std signature) ---------------------------------------------------

function queryTerm( term, spec, xsn ) { // for CSN properties 'SELECT' and 'SET'
  if (!isObject( term, spec ))
    return;
  pushLocation( term );
  if (!xsn.op)
    xsn.op = { val: spec.xsnOp, location: location() };
  Object.assign( xsn, object( term, spec ) );
  popLocation( term );
}

function from( val, spec ) {
  return [ object( val, spec ) ];     // XSN TODO: no array
}

function asQuantifier( quantifier, spec, xsn ) {
  if (quantifier)
    xsn.quantifier = { val: spec.prop, location: location() };
  boolOrNull( quantifier, spec );
}

function excluding( array, spec, xsn ) {
  if (!isArray( array, spec ))
    return;
  const r = Object.create(null);
  ++virtualLine;
  for (const ex of array) {
    const id = string( ex, spec ) || '';
    addToDict( r, id, { name: { id, location: location() }, location: location() },
               // eslint-disable-next-line no-loop-func
               ( name, loc ) => {
                 message( 'duplicate-excluding', loc, null, { name },
                          'Error', 'Duplicate EXCLUDING for source element $(NAME)' );
               } );
    ++virtualLine;
  }
  xsn.exclude = r;              // XSN TODO: exclude -> excluding
}

function setOp( val, spec, xsn, csn ) { // UNION, ...
  // similar to string(), but without literal, and with csn.all hack
  return string( val, spec ) &&
    { val: (csn.all && val === 'union' ? 'unionAll' : val), location: location() };
}

function join( val, spec, xsn ) {
  if (!string( val, spec ))
    return undefined;
  xsn.op = { val: 'join', location: location() };
  return val;
}

function queryArgs( val, spec, xsn, csn ) {
  if (Array.isArray( val ) && val.length > 1 && !csn.op) {
    message( 'syntax-csn-expected-property', location(true), null,
             { prop: 'args', otherprop: 'op' }, 'Warning',
             'CSN property $(PROP) expects property $(OTHERPROP) to be specified' );
    xsn.op = { val: 'union', location: location() };
  }
  return arrayOf( object )( val, spec );
}

function orderBy( node, spec ) {
  const val = expr( node, spec ); // TODO: allow number for select item number?
  if (!val)
    return undefined;
  const r = { value: val, location: val.location };
  if (val.sort) {
    r.sort = val.sort;
    delete val.sort;            // XSN TODO
  }
  if (val.nulls) {
    r.nulls = val.nulls;
    delete val.nulls;
  }
  return r;
}

// Helper functions for objects and definitions ------------------------------

function getSpec( parentSpec, csn, prop, xor, expected, kind ) {
  const p0 = schema[prop] ? prop : prop.charAt(0);
  const s = (parentSpec.schema || schema)[p0];
  if (!s || s.noPrefix && prop !== p0 ) {
    message( 'syntax-csn-unknown-property', location(true), null, { prop },
             'Warning', 'Unknown CSN property $(PROP)' );
  }
  else if (!expected( p0, s )) {
    if (s.ignore)
      return { type: ignore };
    if (s.vZeroIgnore && s.vZeroIgnore === csn[prop]) { // for "op": "call"
      message( 'syntax-csn-zero-delete', location(true), null, { prop },
               'Warning', 'Delete/inline CSN v0.1.0 property $(PROP)' );
      return { type: ignore };
    }
    const zero = s.vZeroFor;
    if (zero) {                 // (potential) CSN v0.1.0 property
      const group = s.xorGroup;
      if (zero && expected( zero, schema[zero] ) && !(group && xor[group])) {
        replaceZeroProp( prop, zero );
        if (group)
          xor[group] = prop;
        onlyWith( s, s.onlyWith, csn, prop, xor, expected );
        return s;
      }
    }
    // eslint-disable-next-line no-nested-ternary
    const variant = kind && s.inKind
      ? ([ 'extend', 'annotate' ].includes(kind) ? kind : 'def')
      : (parentSpec.msgProp ? 'std' : 'top');
    message( 'syntax-csn-unexpected-property', location(true), null,
             {
               prop, otherprop: parentSpec.msgProp, kind, '#': variant,
             },
             [ 'Error' ], {
               std: 'CSN property $(PROP) is not expected in $(OTHERPROP)',
               top: 'CSN property $(PROP) is not expected top-level',
               def: 'CSN property $(PROP) is not expected by a definition of kind $(KIND)',
               extend: 'CSN property $(PROP) is not expected by an extend in $(OTHERPROP))',
               annotate: 'CSN property $(PROP) is not expected by an annotate in $(OTHERPROP)',
             } );
    // TODO: or still augment it? (but then also handle xorGroup)
  }
  else if (checkAndSetXorGroup( s.xorGroup, prop, xor )) {
    onlyWith( s, s.onlyWith, csn, prop, xor, expected );
    return s;
  }
  // else ignore
  return { type: ignore };
}

function calculateKind( def, spec ) {
  if (inExtensions) {
    inExtensions = spec.defaultKind;
    return 'annotate';
  }
  if (spec.prop === 'extensions') {
    inExtensions = (def.extend) ? '' : 'entity';
    return (def.extend) ? 'extend' : 'annotate';
  }
  const kind = (def.kind === 'view') ? 'entity' : def.kind; // 'view' is CSN v0.1.0
  if (kind === 'extend' && inExtensions === '') // valid extend -> keep inExtensions
    return 'extend';
  inExtensions = null;
  return (spec.validKinds.includes( kind )) ? kind : spec.defaultKind;
}

function onlyWith( spec, need, csn, prop, xor, expected ) {
  if (!need)
    return spec;
  if (typeof need === 'string') {
    if (need in csn)            // TODO: enumerable ?
      return spec;
  }
  else if (need.some( n => n in csn )) {
    return spec;
  }
  else {
    const allowed = need.filter( p => expected( p, spec ));
    // There should be at least one elem, otherwise the spec is wrong;
    // first try to find element which is not excluded
    need = allowed.find( p => !xor[schema[p].xorGroup] ) || allowed[0];
  }
  if (prop) {
    message( 'syntax-csn-dependent-property', location(true), null,
             { prop, otherprop: need }, 'Error',
             'CSN property $(PROP) can only be used in combination with $(OTHERPROP)');
    xor['no:req'] = prop;
  }
  else if (!xor['no:req']) {
    message( 'syntax-csn-required-property', location(true), null,
             { prop: need, otherprop: spec.msgProp, '#': spec.prop },
             'Error', {  // TODO $(PARENT), TODO: do not use prop===0 hack
               std: 'Object in $(OTHERPROP) must have the property $(PROP)',
               columns: 'Object in $(OTHERPROP) must have an expression property like $(PROP)',
               // eslint-disable-next-line max-len
               extensions: 'Object in $(OTHERPROP) must have the property \'annotate\' or \'extend\'',
             } );
  }
  return spec;
}

function checkAndSetXorGroup( group, prop, xor ) {
  if (!group)
    return true;
  if (!xor[group]) {
    xor[group] = prop;
    return true;
  }
  message( 'syntax-csn-excluded-property', location(true), null,
           { prop, otherprop: xor[group] }, 'Error',
           'CSN property $(PROP) can only be used alternatively to $(OTHERPROP)');
  return false;
}

function implicitName( ref ) {
  // careful, the input CSN might be wrong!
  const item = ref && ref[ref.length - 1];
  return (typeof item === 'object') ? item && item.id : item;
}

function replaceZeroProp( otherprop, prop ) {
  if (csnVersionZero)
    return;
  message( 'syntax-csn-zero-prop', location(true), null, { prop, otherprop },
           'Warning', 'Replace CSN v0.1.0 property $(OTHERPROP) by $(PROP)' );
}

// Other helper functions, locations -----------------------------------------

function isArray( array, spec ) {
  if (Array.isArray( array ))
    return array;
  message( 'syntax-csn-expected-array', location(true), null, { prop: spec.prop },
           'Error', 'Expected array for property $(PROP)' );
  return ignore( array );
}

function isObject( obj, spec ) {
  if (obj && typeof obj === 'object' && !Array.isArray( obj ))
    return obj;
  message( spec.msgId || 'syntax-csn-expected-object', location(true), null,
           { prop: spec.msgProp }, 'Error' );
  return ignore( obj );
}

function refSplit( name, prop ) {
  const path = name.split('.');
  if (!path.every( id => id)) {
    message( 'syntax-csn-expected-name', location(true), null, { prop },
             'Warning', 'Expected correct name for property $(PROP)' );
  }
  return { path: path.map( id => ({ id, location: location() }) ), location: location() };
}

function replaceZeroValue( spec ) {
  if (!csnVersionZero && spec.vZeroFor == null) { // but 0 does not match!
    message( 'syntax-csn-zero-value', location(true), null, { prop: spec.msgProp },
             'Warning', 'Replace CSN v0.1.0 value in $(PROP) by something specified' );
  }
}

function location( enforceJsonPos ) {
  return !enforceJsonPos && dollarLocations.length &&
         dollarLocations[dollarLocations.length - 1] || {
    filename: csnFilename,
    start: { line: virtualLine, column: 0 },
    end: { line: virtualLine, column: 0 }, // TODO: $location in XSN
    $weak: true,
  };
}

function pushLocation( obj ) {
  // TODO: virtualLine is not really correct if $location is enumerable (is usually not)
  const loc = obj.$location;
  if (loc === undefined)
    return;
  if (loc && typeof loc === 'object' && !Array.isArray( loc )) {
    dollarLocations.push( loc.line ? normalizeLocation( loc ) : null );
    return;
  }
  else if (!loc || typeof loc !== 'string') {
    if (loc)
      dollarLocations.push( null ); // must match with popLocation()
    message( 'syntax-csn-expected-object', location(true), null, { prop: '$location' },
             'Error', 'Expected object for property $(PROP)' );
  }
  // hidden feature: string $location
  const m = /:([0-9]+)(:([0-9]+)(-[0-9---]+)?)?$/.exec( loc ); // extra - at end for .refloc
  if (!m) {
    dollarLocations.push( null );
  }
  else {
    const line = Number( m[1] );
    const column = m[3] && Number( m[3] ) || 0;
    dollarLocations.push( {
      filename: loc.substring( 0, m.index ),
      start: { line, column },
      end: { line, column },
      $weak: true,
    } );
  }
}

function popLocation( obj ) {
  if (obj.$location)
    dollarLocations.pop();
}

// API -----------------------------------------------------------------------

/**
 * Transform the CSN to XSN (augmented CSN)
 *
 * @param {CSN.Model} csn
 * @param {string} filename
 * @param {CSN.Options} [options]
 * @returns {object} Augmented CSN (a.k.a XSN)
 */
function augment( csn, filename, options ) {
  csnVersionZero = csn.version && csn.version.csn === '0.1.0';
  csnFilename = filename;
  virtualLine = 1;
  dollarLocations = [];
  inExtensions = null;
  const xsn = { $frontend: 'json' };
  message = getMessageFunction( xsn, options );
  if (csnVersionZero) {
    message( 'syntax-csn-zero-version', location(true), null, {},
             'Warning', 'Parsing CSN version 0.1.0' );
  }
  const r = object( csn, topLevelSpec );
  delete r.location;            // TODO XSN: use location instead extra filename XSN prop
  return Object.assign( xsn, r );
}

function parse( source, filename = 'csn.json', options = {} ) {
  try {
    return augment( JSON.parse(source), filename, options );
  }
  catch ( e ) {
    if (!(e instanceof SyntaxError))
      throw e;
    const xsn = {};
    // eslint-disable-next-line no-shadow
    const message = getMessageFunction( xsn, options );
    const msg = e.message;
    const p = /in JSON at position ([0-9]+)/.exec( msg );
    let line = 1;
    let column = 0;
    if (p) {
      const end = Number( p[1] );
      let eol = 0;
      const nl = /\n/g;
      while (nl.test( source )) {
        if (nl.lastIndex >= end)
          break;
        eol = nl.lastIndex;
        ++line;
      }
      column = end - eol + 1;
    }
    /** @type {XSN.Location} */
    const loc = {
      filename, start: { line, column }, end: { line, column }, $weak: true,
    };
    message( 'syntax-csn-illegal-json', loc, null, { msg },
             'Error', 'Illegal JSON: $(MSG)' );
    return xsn;
  }
}

module.exports = { augment, parse };
