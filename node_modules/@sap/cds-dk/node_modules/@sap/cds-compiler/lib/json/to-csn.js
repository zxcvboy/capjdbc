// Transform augmented CSN into compact "official" CSN

'use strict';

const { queryOps } = require('../base/model');
const { locationString } = require('../base/messages');

const compilerVersion = require('../../package.json').version;
const creator = `CDS Compiler v${ compilerVersion }`;
const csnVersion = '1.0';

/** @type {boolean|string} */
let gensrcFlavor = true;       // good enough here...
let strictMode = false;        // whether to dump with unknown properties (in standard)

// IMPORTANT: the order of these properties determine the order of properties
// in the resulting CSN !!!  Also check const `csnPropertyNames`.
const transformers = {
  // early and modifiers (without null / not null) -------------------------------------
  kind,
  id: n => n,                   // in path item
  doc: value,
  '@': value,
  abstract: value,
  dbType: value,                // TODO: currently with --hana-flavor only
  virtual: value,
  key: value,
  unique: value,
  masked: value,
  params: insertOrderDict,
  // early expression / query properties -------------------------------------
  op: o => ((o.val !== 'query') ? o.val : undefined),
  from: fromOld,                // before elements! XSN TODO just one (cross if necessary)
  // join done in from()
  // func   // in expression()
  quantifier: ( q, csn ) => {
    csn[q.val] = true;
  },
  all: ignore,                  // XSN TODO use quantifier
  // type properties (without 'elements') ------------------------------------
  localized: value,
  type: artifactRef,
  length: value,
  precision: value,
  scale: value,
  srid: value,
  cardinality: standard,            // also for pathItem: after 'id', before 'where'
  targetAspect,
  target,
  foreignKeys: renameTo( 'keys', dictAsArray ), // XSN: rename?
  enum: insertOrderDict,
  items: standard,
  includes: arrayOf( artifactRef ), // also entities
  // late expressions / query properties -------------------------------------
  mixin: insertOrderDict,       // only in queries with special handling
  columns,
  exclude: renameTo( 'excluding', Object.keys ), // XSN TODO: exclude->excluding
  groupBy: arrayOf( expression ),
  where: condition,             // also pathItem after 'cardinality' before 'args'
  having: condition,
  args,                        // also pathItem after 'where', before 'on'/'orderBy'
  orderBy: arrayOf( orderBy ), // TODO XSN: make `sort` and `nulls` sibling properties
  limit,                       // TODO XSN: include offset
  offset: ignore,              // TODO XSN: move into `limit` - see limit
  namedArgs: renameTo( 'args', args ), // XSN TODO - use args
  on: cond => (typeof cond === 'string' ? undefined : condition( cond )), // also for join
  onCond: renameTo( 'on', c => ((gensrcFlavor && c.$inferred) ? undefined : condition(c)) ),
  // XSN TODO: onCond -> on
  // definitions, extensions, members ----------------------------------------
  returns: standard,            // storing the return type of actions
  notNull: value,
  default: expression,
  // targetElement: ignore,     // special display of foreign key, renameTo: select
  value: enumValue,             // do not list for select items as elements
  query,
  elements,
  sequenceOptions: ignore,     // TODO: currently not in the JSON by HANA
  actions: nonEmptyDict,
  technicalConfig,             // TODO: spec, re-check
  // special: top-level, cardinality -----------------------------------------
  definitions: sortedDict,
  extensions,                   // is array
  messages,              // consider compactQuery / compactExpr
  options: ignore,
  sourceMax: renameTo( 'src', value ), // TODO XSN: rename?
  targetMin: renameTo( 'min', value ),
  targetMax: renameTo( 'max', value ),
  // late protected ----------------------------------------------------------
  name: ignore,             // as is provided extra (for select items, in FROM)
  generatedFieldName: renameTo( '$generatedFieldName', n => n ), // TODO: XSN name
  $syntax: s => s,
  _containerEntity: n => n,     // FIXME: prop starting with _ is link and non-enumerable
  _ignore: a => a,              // FIXME: remove (still required by toHana)
  _ignoreMasked: b => b,        // FIXME: prop starting with _ is link and non-enumerable
  _isToContainer: b => b,       // FIXME: prop starting with _ is link and non-enumerable
  location,                     // -> $location
  $extra: (e, csn) => {
    Object.assign( csn, e );
  },
  // IGNORED -----------------------------------------------------------------
  artifacts: ignore,             // well-introduced, hence not $artifacts
  annotationAssignments: ignore, // FIXME: make it $annotations
  blocks: ignore,                // FIXME: make it $blocks
  builtin: ignore,               // XSN: $builtin, check: "cds" namespace exposed by transformers?
  queries: ignore,               // FIXME: make it $queries (flat)
  typeArguments: ignore,         // FIXME: make it $typeArgs
  calculated: ignore,            // TODO remove ($inferred: 'as')
  implicitForeignKeys: ignore,   // XSN TODO: $inferred on each fk instead
  indexNo: ignore,             // TODO XSN: remove
  origin: ignore,              // TODO remove (introduce non-enum _origin link)
  projection: ignore,          // TODO remove
  redirected: ignore,          // TODO remove: no need for this
  source: ignore,              // TODO remove
  viaAll: ignore,              // TODO remove, later in elem: $inferred: '*'
  $: ignore,
  // '_' not here, as non-enumerable properties are not transformed anyway
  _typeIsExplicit: ignore,
  expectedKind: ignore, // TODO: may be set in extensions but is unused
};

// Dictionary mapping XSN property names to corresponding CSN property names
// which should appear at that place in order.
const csnPropertyNames = {
  kind: [ 'annotate', 'extend' ],
  op: [ 'join', 'func', 'xpr' ],    // TODO: 'func','xpr' into 'quantifier'?  TODO: 'global'(scope)?
  quantifier: [
    'some', 'any', 'distinct',  // 'all' explicitly listed
    'ref', '_links', '_art', '_scope',
    'param', 'val', 'literal', 'SELECT', 'SET',
  ],
  type: [ '_type' ],
  target: [ '_target' ],
  includes: [ '_includes' ],
  foreignKeys: [ 'keys' ],
  exclude: [ 'excluding' ],
  limit: [ 'rows' ],  // 'offset',
  elements: [ 'payload', '$elements' ],
  sourceMax: [ 'src' ],
  targetMin: [ 'min' ],
  targetMax: [ 'max' ],
  name: [ 'as', 'cast' ],
  generatedFieldName: [ '$generatedFieldName' ],
  location: [ '$location' ],
};

const propertyOrder = (function orderPositions() {
  const r = {};
  let i = 0;
  for (const n in transformers) {
    r[n] = ++i;
    for (const c of csnPropertyNames[n] || [])
      r[c] = ++i;
  }
  return r;
}());

// sync with definition in from-csn.js:
const typeProperties = [
  'target', 'elements', 'enum', 'items',
  'type', 'length', 'precision', 'scale', 'srid', 'localized',
  'foreignKeys', 'onCond',      // for explicit ON/keys with REDIRECTED
];

const operators = {
  // standard is: binary infix (and corresponding n-ary), unary prefix
  isNot: [ 'is', 'not' ],       // TODO XSN: 'is not'
  isNull: postfix( [ 'is', 'null' ] ),
  isNotNull: postfix( [ 'is', 'not', 'null' ] ),
  notIn: [ 'not', 'in' ],
  between: ternary( [ 'between' ], [ 'and' ] ),
  notBetween: ternary( [ 'not', 'between' ], [ 'and' ] ),
  like: ternary( [ 'like' ], [ 'escape' ] ),
  notLike: ternary( [ 'not', 'like' ], [ 'escape' ] ),
  when: exprs => [ 'when', ...exprs[0], 'then', ...exprs[1] ],
  case: exprs => [ 'case' ].concat( ...exprs, [ 'end' ] ),
  // xpr: (exprs) => [].concat( ...exprs ), see below - handled extra
};

const csnDictionaries = [
  'args', 'params', 'enum', 'mixin', 'elements', 'actions', 'payload', 'definitions',
];
const csnDirectValues = [ 'val', 'messages' ]; // + all starting with '@'

// Sort property names of CSN according to sequence which is also used by the compactModel function
// Only intended to be used for tests, as no non-enumerable properties are kept.
// Only returns enumerable properties, except for certain hidden properties if requested:
// $location, $env, elements.
function sortCsn( csn, keepHidden = false ) {
  if (csn instanceof Array)
    return csn.map( v => (!v || typeof v !== 'object' ? v : sortCsn(v, keepHidden) ) );
  const r = {};
  for (const n of Object.keys(csn).sort( compareProperties ) ) {
    const val = csn[n];
    if (!val || typeof val !== 'object' || n.charAt(0) === '@' || csnDirectValues.includes(n))
      r[n] = val;

    else if (csnDictionaries.includes(n))
      r[n] = csnDictionary( val, n === 'definitions', keepHidden );

    else
      r[n] = sortCsn(val, keepHidden);
  }
  if (keepHidden && typeof csn === 'object') {
    if (csn.$location)
      setHidden(r, '$location', csn.$location);
    if (csn.$env)
      setHidden(r, '$env', csn.$env);
    if (csn.$path) // used in generic reference flattener
      setHidden(r, '$path', csn.$path);
    if (csn.$paths) // used in generic reference flattener
      setHidden(r, '$paths', csn.$paths);
    if (csn.elements && !r.elements) // non-enumerable 'elements'
      setHidden(r, 'elements', csnDictionary( csn.elements, false, keepHidden ) );
  }
  return r;
}

function csnDictionary( csn, sort, keepHidden = false ) {
  if (!csn || csn instanceof Array) // null or strange CSN
    return csn;
  const r = Object.create(null);
  for (const n of (sort) ? Object.keys(csn).sort() : Object.keys(csn))
    r[n] = sortCsn( csn[n], keepHidden );

  return r;
}

/**
 * Compact the given XSN model and transform it into CSN.
 *
 * @param {XSN.Model} model
 * @param {CSN.Options} options
 * @returns {CSN.Model}
 */
function compactModel( model, options = model.options || {} ) {
  gensrcFlavor = options.parseCdl || options.toCsn && options.toCsn.flavor === 'gensrc';
  strictMode = options.testMode;
  const csn = {};
  if (options.parseCdl) {
    const using = usings( model.sources || {} );
    if (using.length)
      csn.requires = using;
  }
  set( 'definitions', csn, model );
  const exts = extensions( model.extensions || [], csn, model );
  if (exts.length)
    csn.extensions = exts;
  set( 'messages', csn, model );
  const [ src ] = Object.keys( model.sources );
  const file = src && model.sources[src].filename;
  if (file)
    setHidden( csn, '$location', { file } ); // no line
  if (!options.testMode) {
    csn.meta = Object.assign( {}, model.meta, { creator } );
    csn.$version = csnVersion;
  }
  // Use $extra properties of first source as resulting $extra properties
  for (const f in model.sources) {
    set( '$extra', csn, model.sources[f] );
    break;
  }
  return csn;
}

function renameTo( csnProp, func ) {
  return function renamed( val, csn, node, prop ) {
    const sub = func( val, csn, node, prop );
    if (sub !== undefined)
      csn[csnProp] = sub;
  };
}

function arrayOf( func ) {
  return ( val, ...nodes ) => val.map( v => func( v, ...nodes ) );
}

/**
 * Create a CSN `requires` array of dependencies.
 *
 * @param {object} sources Dictionary of source files to their AST/XSN.
 */
function usings( sources ) {
  const sourceNames = Object.keys(sources);
  if (sourceNames.length === 0)
    return [];

  // Take the first file as parseCdl should only receive one file.
  const source = sources[sourceNames[0]];
  const requires = [];
  if (source && source.dependencies)
    source.dependencies.map(dep => dep && requires.push(dep.val));

  // Make unique and sort
  return Array.from(new Set(requires)).sort();
}

/**
 * @param {XSN.Extension[]} node
 * @param {object} csn
 * @param {object} model
 */
function extensions( node, csn, model ) {
  const exts = node.map( standard ).sort(
    (a, b) => (a.annotate || a.extend).localeCompare( b.annotate || b.extend )
  );
  if (!gensrcFlavor)
    return exts;
  for (const name of Object.keys( model.definitions ).sort()) {
    const art = model.definitions[name];
    // in definitions (without redef) with potential inferred elements:
    if (!(art instanceof Array) && art.elements &&
        (art.query || art.includes || art.$inferred)) {
      const annos = art.$inferred && annotations( art, true );
      const elems = inferred( art.elements, art.$inferred );
      /** @type {object} */
      const annotate = Object.assign( { annotate: name }, annos );
      if (Object.keys( elems ).length)
        annotate.elements = elems;
      if (Object.keys( annotate ).length > 1)
        exts.push( annotate );
    }
  }
  return exts;
}

function inferred( elems, inferredParent ) {
  const ext = Object.create(null);
  for (const name in elems) {
    const elem = elems[name];
    if (elem instanceof Array || !inferredParent && !elem.$inferred)
      continue;
    const csn = annotations( elem, true );
    if (Object.keys(csn).length)
      ext[name] = csn;
  }
  return ext;
}

function standard( node ) {
  if (node.$inferred && gensrcFlavor)
    return undefined;
  if (node instanceof Array)
    return node.map( standard );
  const csn = {};
  // To avoid another object copy, we sort according to the prop names in the
  // XSN input node, not the CSN result node.  Not really an issue...
  const keys = Object.keys( node ).sort( compareProperties );
  for (const prop of keys) {
    const transformer = transformers[prop] || transformers[prop.charAt(0)] || unexpected;
    const sub = transformer( node[prop], csn, node, prop );
    if (sub !== undefined)
      csn[prop] = sub;
  }
  return csn;
}

function unexpected( val, csn, node, prop ) {
  if (strictMode) {
    const loc = val && val.location || node.location;
    throw new Error( `Unexpected property ${ prop } in ${ locationString(loc) }`);
  }
  // otherwise, just ignore the unexpected property
}

function set( prop, csn, node ) {
  const val = node[prop];
  if (val === undefined)
    return;
  const sub = transformers[prop]( node[prop], csn, node, prop );
  if (sub !== undefined)
    csn[prop] = sub;
}

function targetAspect( val, csn, node ) {
  if (!gensrcFlavor || node.target && !node.target.$inferred)
    return (val.elements) ? standard( val ) : artifactRef( val, true );
  // For compatibilty, put aspect in 'target' with parse.cdl and csn flavor 'gensrc'
  csn.target = (val.elements) ? standard( val ) : artifactRef( val, true );
  return undefined;
}

function target( val ) {
  if (!gensrcFlavor && val._artifact)
    // target._artifact is different to _artifact from path with explicit target
    // to model entity with @cds.autoexpose (TODO: remove, unncessary complication)
    return val._artifact.name.absolute;
  else if (!val.elements)
    return artifactRef( val, true );
  return standard( val );
}

function elements( dict, csn, node ) {
  if (csn.from || gensrcFlavor && (node.query || node.type))
    // no 'elements' with SELECT or inferred elements with gensrc;
    // hidden 'elements' will be set in query()
    return undefined;
  if (node.kind !== 'event')
    return insertOrderDict( dict );
  csn.payload = insertOrderDict( dict );
  return undefined;
}

// for gensrcFlavor: return annotations from definition (annotated==false)
// or annotations (annotated==true)
function annotations( node, annotated ) {
  const csn = {};
  const transformer = transformers['@'];
  const keys = Object.keys( node ).filter( a => a.charAt(0) === '@' ).sort();
  for (const prop of keys) {
    const val = node[prop];
    if ((val.priority && val.priority !== 'define') === annotated) {
      // transformer (= value) takes care to exclude $inferred annotation assignments
      const sub = transformer( val );
      // As value() just has one value, so we do not provide ( val, csn, node, prop )
      // which would be more robust, but makes some JS checks unhappy
      if (sub !== undefined)
        csn[prop] = sub;
    }
  }
  return csn;
}

function ignore() {}

function messages( val, csn ) {
  if (val && val.length )
    setHidden( csn, 'messages', val );
}

function location( loc, csn, xsn ) {
  if (xsn.kind && xsn.kind.charAt(0) !== '$' && xsn.kind !== 'query' &&
      (!xsn.$inferred || !xsn._main)) {
    // Also include $location for elements in queries (if not via '*')
    const l = xsn.name && xsn.name.location || loc;
    // csn.$location
    const val = { file: l.filename, line: l.start.line, col: l.start.column };
    setHidden( csn, '$location', val );
  }
}

// Add location to SELECT
function addLocation( loc, csn ) {
  if (loc)
    location( loc, csn, { kind: 'entity' } );
  return csn;
}

function insertOrderDict( dict ) {
  const keys = Object.keys( dict );
  return dictionary( dict, keys );
}

function sortedDict( dict ) {
  const keys = Object.keys( dict );
  keys.sort();
  return dictionary( dict, keys );
}

function nonEmptyDict( dict ) {
  const keys = Object.keys( dict );
  return (keys.length)
    ? dictionary( dict, keys )
    : undefined;
}

function dictionary( dict, keys ) {
  const csn = Object.create(null);
  for (const name of keys) {
    const def = definition( dict[name] );
    if (def !== undefined)
      csn[name] = def;
  }
  return csn;
}

function dictAsArray( dict ) {
  const csn = [];
  for (const n in dict) {
    const d = definition( dict[n] );
    if (d !== undefined)
      csn.push( d );
  }
  return (csn.length) ? csn : undefined;
}

function definition( art ) {
  if (!art || typeof art !== 'object')
    return undefined;           // TODO: complain with strict
  // Do not include namespace definitions or inferred construct (in gensrc):
  if (art.kind === 'namespace' || art.$inferred && gensrcFlavor)
    return undefined;
  if (art.kind === 'key') {      // foreignkey
    const key = addExplicitAs( { ref: art.targetElement.path.map( pathItem ) },
                               art.name, neqPath( art.targetElement ) );
    addLocation( art.targetElement.location, key );
    set( 'generatedFieldName', key, art );
    return extra( key, art );
  }
  return standard( art );
}

function kind( k, csn, node ) {
  if (!node._main && [ 'annotate', 'extend' ].includes( k )) {
    // We just use `name.absolute` because it is very likely a "constructed"
    // extensions.  The CSN parser must produce name.path like for other refs.
    csn[k] = node.name.absolute || artifactRef( node.name, true );
    return undefined;
  }
  if (k === 'view')          // XSN TODO: kind: 'entity'
    return 'entity';
  if ([ 'element', 'key', 'param', 'enum', 'annotate', 'query', '$tableAlias' ].includes(k))
    return undefined;
  return k;
}

function artifactRef( node, terse ) {
  // When called as transformer function, a CSN node is provided as argument
  // for `terse`, i.e. it is usually truthy, except for FROM
  if (node.$inferred && gensrcFlavor)
    return undefined;
  // Works also on XSN directly coming from parser and with XSN from CDL->CSN transformation
  const { path } = node;
  if (!path)
    return undefined;           // TODO: complain with strict

  const link = path[0]._artifact; // XSN TODO: store double definitions differently
  const root = (link instanceof Array) ? link[0] : link;
  if (!root) {                  // XSN directly coming from the parser
    if (strictMode && node.scope === 'typeOf')
      throw new Error( `Unexpected TYPE OF in ${ locationString(node.location) }`);
    return renderArtifactPath( path, terse, node.scope );
  }
  const { absolute } = root.name;
  if (node.scope !== 'typeOf' && typeof node.scope !== 'number') {
    // CSN input or generated in compiler (XSN TODO: remove scope:'global')
    if (absolute === path[0].id) // normal case (no localization view)
      return renderArtifactPath( path, terse ); // scope:param is not valid (and would be lost)
    const head = Object.assign( {}, path[0], { id: absolute } );
    return renderArtifactPath( [ head, ...path.slice(1) ], terse );
  }
  if (node.scope === 'typeOf') { // TYPE OF without ':' in path
    // Root _artifact which is either element or main artifact for paths starting with $self.
    // To make the CDL->CSN transformation simpler, the _artifact for first item could be
    // a fake element with just a correct absolute name and  _parent/_main links.
    if (!root._main || root.kind === 'query') { // $self/$projection
      // in query, only correct for leading query ->
      // TODO: forbid TYPE OF elem / TYPE OF $self.elem in queries
      return renderArtifactPath( [ { id: absolute }, ...path.slice(1) ], terse );
    }
    const parent = root._parent;
    const structs = parent.name.element ? parent.name.element.split('.') : [];
    return { ref: [ absolute, ...structs, ...path.map( pathItem ) ] };
  }
  let { scope } = node;
  if (!scope) {                 // no ':' in CDL path - try to be nice and guess it via links
    const { length } = path;
    for (; scope < length; ++scope) {
      const art = path[scope]._artifact;
      if (!art) {
        scope = 0;              // unsuccessful, not all path items have links
        break;
      }
      if (art._main)
        break;                  // successful, found first element
    }
  }
  const head = Object.assign( {}, path[0], { id: absolute } );
  return renderArtifactPath( [ head, ...path.slice(1) ], terse, scope );
}

function renderArtifactPath( path, terse, scope ) {
  if (scope === 0) {
    // try to find ':' position syntactically for FROM
    scope = !terse && path.findIndex( i => i.where || i.namedArgs || i.cardinality) + 1 ||
            path.length;
  }
  if (typeof scope === 'number' && scope > 1) {
    const item = path[scope - 1];
    const name = item._artifact && item._artifact.name;
    // In localization views, the _artifact link of `item` is important
    const id = name && name.absolute ||
               path.slice( 0, scope ).map( i => i.id ).join('.');
    path = [ Object.assign( {}, item, { id } ), ...path.slice( scope ) ];
  }
  const ref = path.map( pathItem );
  return (!terse || ref.length !== 1 || typeof ref[0] !== 'string')
    ? { ref }
    : ref[0];
}

function pathItem( item ) {
  if (!item.args &&
      !item.namedArgs &&
      !item.where &&
      !item.cardinality &&
      !item.$extra &&
      !item.$syntax)
    return item.id;
  return standard( item );
}

function args( node ) {
  if (node instanceof Array)
    return node.map( expression );
  const dict = Object.create(null);
  for (const param in node)
    dict[param] = expression( node[param] );
  return dict;
}

// "Short" value form, e.g. for annotation assignments
function value( node ) {
  if (!node)
    return true;                // `@aBool` short for `@aBool: true`
  if (node.$inferred && gensrcFlavor)
    return undefined;
  if (node.path)
    return extra( { '=': node.path.map( id => id.id ).join('.') }, node );
  if (node.literal === 'enum')
    return extra( { '#': node.symbol.id }, node );
  if (node.literal === 'array')
    return node.val.map( value );
  if (node.literal !== 'struct')
    // no val (undefined) as true only for annotation values (and struct elem values)
    return node.name && !('val' in node) || node.val;
  const r = Object.create( null );
  for (const prop in node.struct)
    r[prop] = value( node.struct[prop] );
  return r;
}

function enumValue( v, csn, node ) {
  // Enums can have values but if enums are extended, their kind is 'element',
  // so we check whether the node is inside an extension.
  if (node.kind === 'enum' || node._parent && node._parent.kind === 'extend')
    Object.assign( csn, expression(v) );
}

function condition( node ) {
  const expr = expression( node );
  return expr.xpr || [ expr ];
}

// TODO: calculate from compiler/builtins.js (more with HANA?):
const magicFunctions = [
  'CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP',
  'CURRENT_USER', 'SESSION_USER', 'SYSTEM_USER',
];
// TODO: quoted magic names like $now should be complained about in the compiler

function pathRef( path ) {
  const ref = { ref: path.map( pathItem ) };
  const nav = path[0]._navigation;
  if (nav && !nav.self && nav.name.query != null) {
    setHidden( ref, '$env', (nav.kind === '$navElement')
      ? nav.name.alias
      : nav.name.query + 1 );
  }
  else if ( path[0]._artifact && path[0]._artifact.query ) {
    setHidden( ref, '$env', true );
  }
  return ref;
}

function expression( node, withExtra ) {
  const en = withExtra != null && node;
  if (typeof node === 'string')
    return node;
  if (!node)                    // make to-csn robst
    return {};
  if (node instanceof Array) {
    const exprs = node.map( condition );
    const rest = exprs.slice(1).map( a => [ ',', ...a ] );
    return { xpr: [ '(' ].concat( exprs[0], ...rest, [ ')' ] ) };
  }
  if (node.scope === 'param') {
    if (node.path)
      return extra( { ref: node.path.map( pathItem ), param: true }, en );
    return extra( { ref: [ node.param.val ], param: true }, en );
  }
  if (node.path) {
    // TODO: global
    if (node.path.length !== 1)
      return extra( pathRef( node.path ), en );
    const item = pathItem( node.path[0] );
    if (typeof item === 'string' && !node.path[0].quoted &&
        // TODO: use _artifact if available
        magicFunctions.includes( item.toUpperCase() ))
      return extra( { func: item }, en );

    return extra( pathRef( node.path ), en );
  }
  if (node.literal) {
    if (typeof node.val === node.literal || node.val === null)
      return extra( { val: node.val }, en );
    else if (node.literal === 'enum')
      return extra( { '#': node.symbol.id }, en );
    else if (node.literal === 'token')
      return node.val;          // * in COUNT(*)
    return extra( { val: node.val, literal: (node.literal === 'hex') ? 'x' : node.literal },
                  en );
  }
  if (node.func) {              // TODO XSN: remove op: 'call', func is no path
    const call = { func: node.func.path[0].id };
    if (node.namedArgs) {
      call.args = args( node.namedArgs );
    }
    else if (node.args) {       // no args from CSN input for CURRENT_DATE etc
      call.args = args( node.args );
      const arg0 = call.args[0];
      const { quantifier } = node.func.path[0];
      if (arg0 && quantifier) {
        if (typeof arg0 !== 'object' || !arg0.xpr)
          call.args[0] = { xpr: [ quantifier.val, arg0 ] };
        else
          arg0.xpr.unshift( quantifier.val );
      }
    }
    return extra( call, en );
  }
  if (queryOps[node.op.val])
    return query( node );
  else if (node.op.val === 'xpr')
    // do not use xpr() for xpr, as it would flatten inner xpr's (semantically ok)
    return extra( { xpr: node.args.map( expression ) }, node );
  return { xpr: xpr( node ) };
}

function assignExpression( node, expr ) {
  const e = expression( expr );
  const r = Object.assign( node, e );
  if (e.$env)
    setHidden( r, '$env', e.$env );
  if (e.elements) {
    // possibly set hidden by backends
    setHidden( r, 'elements', e.elements );
  }
  return r;
}

function xpr( node ) {
  // if (!node.op) console.log(node)
  const op = operators[node.op.val] || node.op.val.split(' ');
  const exprs = node.args.map( condition );
  if (op instanceof Function)
    return op( exprs );
  if (node.quantifier)
    op.push( node.quantifier.val );
  if (exprs.length < 2)
    return [ ...op, ...exprs[0] || [] ];
  return exprs[0].concat( ...exprs.slice(1).map( a => [ ...op, ...a ] ) );
}

function ternary( op1, op2 ) {
  return function ternaryOp( exprs ) {
    return (exprs[2])
      ? [ ...exprs[0], ...op1, ...exprs[1], ...op2, ...exprs[2] ]
      : [ ...exprs[0], ...op1, ...exprs[1] ];
  };
}

function postfix( op ) {
  return function postfixOp( exprs ) {
    return [ ...exprs[0], ...op ];
  };
}

function query( node ) {
  while (node instanceof Array) // in parentheses -> remove
    node = node[0];
  if (node.op.val === 'query') {
    const select = { SELECT: standard( node ) };
    const elems = node.elements;
    if (elems && node._main && node !== node._main._leadingQuery && gensrcFlavor !== true) {
      // Set hidden 'elements' for csnRefs.js.  In select-item subqueries,
      // gensrcFlavor might have been set to 'column' and must be set to the
      // original value 'false' - otherwise no element appears.
      const gensrcSaved = gensrcFlavor;
      try {
        gensrcFlavor = false;
        setHidden( select, 'elements', insertOrderDict( elems ) );
      }
      finally {
        gensrcFlavor = gensrcSaved;
      }
    }
    return addLocation( node.location, select );
  }
  const csn = {};
  // for UNION, ... ----------------------------------------------------------
  if (node.op.val !== 'subquery') {
    if (node.op.val !== 'unionAll') { // XSN TODO: quantifier: 'all'|'distinct'
      csn.op = node.op.val;
    }
    else {
      csn.op = 'union';
      csn.all = true;
    }
  }
  if (node.args) {
    let exprs = node.args;
    // binary -> n-ary - TODO CDL: the while loop should be done in parser (toCdl is
    // currently not prepared)
    const block = node._leadingQuery && node._leadingQuery._block;
    if (!block || block.$frontend !== 'json') {
      while (exprs[0] && exprs[0].op && exprs[0].op.val === node.op.val &&
             !exprs[0].all === !node.all && exprs[0].args)
        exprs = [ ...exprs[0].args, ...exprs.slice(1) ];
    }
    if (node.op.val === 'unionAll') // TODO grammar: set DISTINCT - quantifier: 'all'|'distinct'
      csn.all = true;
    csn.args = exprs.map( query );
  }
  set( 'orderBy', csn, node );
  set( 'limit', csn, node );    // TODO XSN: also offset
  set( '$extra', csn, node );
  return addLocation( node.location, { SET: csn } );
}

function columns( xsnColumns, csn, xsn ) {
  const csnColumns = [];
  if (xsnColumns) {
    for (const col of xsnColumns) {
      if (col.val === '*')
        csnColumns.push( '*' );
      else
        addElementAsColumn( col, csnColumns );
    }
  }
  else {                        // null = use elements
    for (const name in xsn.elements)
      addElementAsColumn( xsn.elements[name], csnColumns );
  }
  return csnColumns;
}

function fromOld( node ) {
  // TODO: currently an array in XSN:
  if (node.length > 1)
    return from( { join: 'cross', args: node } );
  return from( node[0] );
}

// XSN TODO: remove '…Outer'
const joinTrans = { leftOuter: 'left', rightOuter: 'right', fullOuter: 'full' };

function from( node ) {
  while (node instanceof Array) // in parentheses
    node = node[0];
  // TODO: CSN: FROM ((SELECT...)) as -> also add 'subquery' op? - Together
  // with []-elimination in FROM... -> normal standard()
  if (node.join) {         // XSN TODO: remove '…Outer'
    // binary (without additions) -> n-ary - the while loop should be done in
    // parser (toCdl is currently not prepared)
    let srcs = node.args;
    while (node.join === 'cross' && srcs[0] && srcs[0].join === node.join && srcs[0].args)
      srcs = [ ...srcs[0].args, ...srcs.slice(1) ];
    const join = { join: joinTrans[node.join] || node.join, args: node.args.map( from ) };
    set( 'on', join, node );
    return extra( join, node );
  }
  else if (!node.path) {
    return addExplicitAs( query( node ), node.name ); // $extra inside SELECT/SET
  }
  else if (!node._artifact || node._artifact._main) { // CQL or follow assoc
    return extra( addExplicitAs( artifactRef( node, false ), node.name ), node );
  }
  return extra( addExplicitAs( artifactRef( node, false ), node.name, (id) => {
    const name = node._artifact.name.absolute;
    const dot = name.lastIndexOf('.');
    return name.substring( dot + 1 ) !== id;
  }), node );
}

function addElementAsColumn( elem, cols ) {
  if (elem.viaAll)              // TODO: elem.$inferred (value '*')
    return;
  // TODO: 'priority' -> '$priority'
  // only list annotations here which are provided directly with definition
  const col = (gensrcFlavor) ? annotations( elem, false ) : {};
  // with `client` flavor, assignments are available at the element
  const gensrcSaved = gensrcFlavor;

  try {
    gensrcFlavor = gensrcFlavor || 'column';
    set( 'key', col, elem );
    addExplicitAs( assignExpression( col, elem.value ),
                   elem.name, neqPath( elem.value ) );
    if (elem._typeIsExplicit || elem.redirected) { // TODO XSN: introduce $inferred
      col.cast = {};                               // TODO: what about $extra in cast?
      for (const prop of typeProperties)
        set( prop, col.cast, elem );
    }
  }
  finally {
    gensrcFlavor = gensrcSaved;
  }
  // FIXME: Currently toHana requires that an '_ignore' property on the elem is
  // also visible on the column.  Don't ignore virtual columns, let the
  // renderer decide how to render that column.
  if (!elem.virtual && elem._ignore)
    col._ignore = true;

  if (elem.value && elem.value.location && !elem.$inferred)
    location( elem.value.location, col, { kind: 'col' } );
  cols.push( extra( col, elem ) );
}

function orderBy( node ) {      // TODO XSN: flatten (no extra 'value'), part of expression
  const expr = expression( node.value );
  if (node.sort)
    expr.sort = node.sort.val;
  if (node.nulls)
    expr.nulls = node.nulls.val;
  return extra( expr, node );
}

function limit( expr, csn, node ) { // XSN TODO: use same structure, $extra
  const rows = expression( expr );
  return (node.offset)
    ? { rows, offset: expression( node.offset ) }
    : { rows };
}

function $extra( obj, csn ) {
  for (const prop of Object.keys( obj ).sort())
    csn[prop] = obj[prop];
}

function extra( csn, node ) {
  if (node && node.$extra)
    $extra( node.$extra, csn );
  return csn;
}

function setHidden( obj, prop, val ) {
  Object.defineProperty( obj, prop, {
    value: val, configurable: true, writable: true, enumerable: false,
  } );
}

function addExplicitAs( node, name, implicit ) {
  if (name && name.id &&
    (!name.calculated && !name.$inferred || !node.ref || implicit && implicit(name.id) ))
    node.as = name.id;
  return node;
}

function neqPath( ref ) {
  const path = ref && ref.path;
  return function test( id ) {
    const last = path && path[path.length - 1];
    return !last || last.id !== id;
  };
}

function compareProperties( a, b ) {
  if (a === b)
    return 0;
  const oa = propertyOrder[a] || propertyOrder[a.charAt(0)] || 9999;
  const ob = propertyOrder[b] || propertyOrder[b.charAt(0)] || 9999;
  return oa - ob || (a < b ? -1 : 1);
}

function compactQuery( q ) {    // TODO: options
  gensrcFlavor = true;
  strictMode = false;
  return q && query( q );
}

function compactExpr( e ) {     // TODO: options
  gensrcFlavor = true;
  strictMode = false;
  return e && expression( e );
}

// TODO: use style as in rest of this file: property transformators, coding style
// TODO: document CSN and XSN for technical configurations
function technicalConfig( tc/* , parentCsn, parentArtifact, prop */) {
  const csn = { [tc.backend.val]: { } };
  const be = csn[tc.backend.val];
  if (tc.backend.calculated)
    be.calculated = true;
  if (tc.migration) {
    if (!be.tableSuffix)
      be.tableSuffix = [];
    be.tableSuffix.push({ xpr: [ 'migration', value(tc.migration) ] });
  }
  if (tc.storeType)
    be.storeType = value(tc.storeType);

  if (tc.extendedStorage) {
    if (!be.tableSuffix)
      be.tableSuffix = [];
    be.tableSuffix.push({ xpr: [ 'using', 'extended', 'storage' ] });
  }
  if (tc.group) {
    if (!be.tableSuffix)
      be.tableSuffix = [];
    const group = { xpr: [] };
    if (tc.group.name)
      group.xpr.push('group', 'name', { ref: [ tc.group.name.id ] });

    if (tc.group.type)
      group.xpr.push('group', 'type', { ref: [ tc.group.type.id ] });

    if (tc.group.subType)
      group.xpr.push('group', 'subtype', { ref: [ tc.group.subType.id ] });

    be.tableSuffix.push(group);
  }
  if (tc.unloadPrio) {
    if (!be.tableSuffix)
      be.tableSuffix = [];
    be.tableSuffix.push({ xpr: [ 'unload', 'priority', expression(tc.unloadPrio) ] });
  }
  if (tc.autoMerge) {
    if (!be.tableSuffix)
      be.tableSuffix = [];
    const autoMerge = { xpr: [] };
    if (!tc.autoMerge.val)
      autoMerge.xpr.push('no');
    autoMerge.xpr.push('auto', 'merge');
    be.tableSuffix.push(autoMerge);
  }
  if (tc.partition) {
    if (!be.tableSuffix)
      be.tableSuffix = [];
    be.tableSuffix.push({ xpr: [ partition(tc.partition) ] });
  }

  if (tc.fzindexes) {
    if (!be.fzindexes)
      be.fzindexes = {};
    tc.fzindexes.forEach((i) => {
      i.columns.filter(c => !c._ignore).forEach((c) => {
        const stream = [];
        stream.push('fuzzy', 'search', 'index', 'on');
        if (i.fuzzy) {
          stream.push('fuzzy', 'search', 'mode');
          if (i.fuzzy.mode)
            stream.push(expression(i.fuzzy.mode));
        }
        const name = c.path.map(p => p.id).join('.');
        if (be.fzindexes[name])
          be.fzindexes[name].push(stream);

        else
          be.fzindexes[name] = [ stream ];
      });
    });
  }

  if (tc.indexes) {
    be.indexes = {};
    for (const idxName in tc.indexes) {
      const idx = tc.indexes[idxName];
      be.indexes[idxName] = (Array.isArray(idx)) ? idx.map(index) : index(idx);
    }
  }
  return csn;

  function index(idx) {
    const stream = [];
    if (idx.kind === 'index') {
      if (idx.unique)
        stream.push('unique');

      stream.push('index', { ref: [ idx.name.id ] }, 'on', '(');
      columns(idx.columns, stream);
      stream.push(')');
      if (idx.sort)
        stream.push(value(idx.sort));
    }
    else if (idx.kind === 'fulltextindex') {
      stream.push('fulltext', 'index', { ref: [ idx.name.id ] }, 'on', '(');
      columns(idx.columns, stream);
      stream.push(')');
      if (idx.language) {
        if (idx.language.column) {
          stream.push('language', 'column');
          stream.push(expression(idx.language.column));
        }
        if (idx.language.detection) {
          stream.push('language', 'detection', '(');
          let i = 0;
          idx.language.detection.forEach((v) => {
            if (i > 0)
              stream.push(',');
            stream.push(expression(v));
            i++;
          });
          stream.push(')');
        }
      }
      if (idx.mimeTypeColumn)
        stream.push('mime', 'type', 'column', expression(idx.mimeTypeColumn));

      if (idx.fuzzySearchIndex)
        stream.push('fuzzy', 'search', 'index', value(idx.fuzzySearchIndex));

      if (idx.phraseIndexRatio)
        stream.push('phrase', 'index', 'ratio', expression(idx.phraseIndexRatio));

      if (idx.configuration)
        stream.push('configuration', expression(idx.configuration));

      if (idx.textAnalysis)
        stream.push('text', 'analysis', value(idx.textAnalysis));

      if (idx.searchOnly)
        stream.push('search', 'only', value(idx.searchOnly));

      if (idx.fastPreprocess)
        stream.push('fast', 'preprocess', value(idx.fastPreprocess));

      if (idx.mimeType)
        stream.push('mime', 'type', expression(idx.mimeType));

      if (idx.tokenSeparators)
        stream.push('token', 'separators', expression(idx.tokenSeparators));

      if (idx.textMining) {
        if (idx.textMining.state)
          stream.push('text', 'mining', value(idx.textMining.state));

        if (idx.textMining.config)
          stream.push('text', 'mining', 'configuration', expression(idx.textMining.config));

        if (idx.textMining.overlay) {
          stream.push('text', 'mining', 'configuration', 'overlay',
                      expression(idx.textMining.overlay));
        }
      }
      if (idx.changeTracking) {
        const ct = idx.changeTracking;
        stream.push(value(ct.mode));
        if (ct.asyncSpec) {
          const asp = ct.asyncSpec;
          stream.push('flush');
          if (asp.queue)
            stream.push(value(asp.queue));

          if (asp.minutes) {
            stream.push('every', expression(asp.minutes), 'minutes');
            if (asp.documents)
              stream.push('or');
          }
          if (asp.documents)
            stream.push('after', expression(asp.documents), 'documents');
        }
      }
    }
    return stream;
  }

  function partition(p) {
    const stream = [];
    let i = 0;
    p.specs.forEach((s) => {
      if (i === 0)
        stream.push('partition', 'by', ...s.scheme.val.split(' '));
      else
        stream.push(',', ...s.scheme.val.split(' '));
      spec(s);
      i++;
    });
    if (p.wpoac)
      stream.push('with', 'partitioning', 'on', 'any', 'columns', value(p.wpoac));

    return stream;

    function spec(s) {
      if (s.columns) {
        stream.push('(');
        columns(s.columns, stream);
        stream.push(')');
      }
      if (s.partitions)
        stream.push('partitions', value(s.partitions));

      if (s.ranges) {
        stream.push('(');
        let oppStore = (s.ranges[0].store === 'default' ? 'extended' : 'default');
        let delimiter = false;
        s.ranges.forEach((r) => {
          if (r.store !== oppStore) {
            if (s.withStorageSpec) {
              if (delimiter)
                stream.push(')');

              stream.push('using', r.store, 'storage', '(');
            }
            delimiter = false;
            oppStore = r.store;
          }
          if (delimiter)
            stream.push(',');

          stream.push('partition');
          if (r.others)
            stream.push('others');


          if (r.min && !r.max)
            stream.push('value', '=');

          if (r.min)
            stream.push(expression(r.min));


          if (r.isCurrent)
            stream.push('is', 'current');

          if (r.min && r.max)
            stream.push('<=', 'values', '<', expression(r.max));

          delimiter = true;
        });
        if (s.withStorageSpec)
          stream.push(')');

        stream.push(')');
      }
    }
  }

  // eslint-disable-next-line no-shadow
  function columns(arr, stream) {
    let i = 0;
    arr.filter(c => !c._ignore).forEach((c) => {
      if (i > 0)
        stream.push(',');
      if (c.unit)
        stream.push({ func: value(c.unit), args: [ expression(c) ] });
      else
        stream.push(expression(c));
      if (c.sort)
        stream.push(value(c.sort));
      i++;
    });
  }
}

module.exports = {
  compactModel,
  compactQuery,
  compactExpr,
  sortCsn,
  csnDictionaries,
  csnDirectValues,
};
