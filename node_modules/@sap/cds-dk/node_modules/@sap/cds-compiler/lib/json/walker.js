/**
 * Walker module provides non-recursive tree walkers with different flavours
 * @module json/walker
 */

/**
 * Checks if the provided parameter is an object
 * @param obj the variable to check
 * @returns true if the parameter is an object otherwise it returns false
 */
function isObject(obj) {
  return obj && typeof obj === "object";
}

/**
 * Checks if the provided parameter is an array
 * @param obj the variable to check
 * @returns true if the parameter is an array otherwise it returns false
 */
function isArray(obj) {
  return Array.isArray(obj);
}

/**
 * Callback of the forEach function called for each node it walks
 * @callback forEachCallback
 * @param {string} name of the node
 * @param {object} node
 */

/**
 * Loops over all elements in an object and calls the specified callback(key,obj)
 * @param {object} obj
 * @param {forEachCallback} callback
 */
function forEach(obj, callback) {
  for(var key in obj) {
    callback(key, obj[key]);
  }
}

/**
 * Callback of the walkWithPath function
 * @callback walkWithPathCallback
 * @param {boolean} isNode false if leaf
 * @param {array} path specifies the path from the root to the node
 * @param {object} node
 */

 /**
 * Callback check function
 * @callback walkWithPathCheck
 * @param {array} path specifies the path from the root to the node
 * @param {object} node current node
 * @param {string} key current key
 * @param {boolean} visible Whether "key" is enumerable, i.e. visible.
 * @returns {boolean} true process the current node
 */

/**
 * Walks all nodes (also non-enumerable) calling the provided callback function for each node.
 * Use optional 'check' callback function to ignore specific nodes.
 * @param {object} node to start from
 * @param {walkWithPathCallback} callback function called for each node: callback(isNode,path,node)
 * @param {walkWithPathCheck} check optional callback function which should return true if the node should be further processed
 */
function walkWithPath(node, callback, check) {

  function filterNodes (path, objs, result) {
    let visibleKeys = Object.keys(objs);
    let allKeys = Object.getOwnPropertyNames(objs); // consider non-enumerable properties also
    let ignoreLength = isArray(objs);
    for(var key of allKeys) {
      let visible = visibleKeys.includes(key);
      if(ignoreLength && key==='length') continue; // ignore length for arrays
      var obj = objs[key];
      var newPath = path.concat([key]);
      if(isObject(obj)) {
        if(check) { // callback provided - ask if the scan should proceed
          if(check(newPath,obj,key,visible))
            result.push([newPath,obj]);
        } else {
          result.push([newPath,obj]);
        }
      } else {
        callback(false,path.concat([key]),obj);
      }
    }
  }

  var next = [[[],node]];
  while(next.length>0) {
    var more = []
    next.forEach(X => {
      var P,O;
      [P,O] = X;
      filterNodes(P, O, more);
      callback(true,P,O);
    });
    next = more;
  } // while array not empty
}

module.exports = {
  forEach,
  walkWithPath
}
