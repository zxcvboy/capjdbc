// Transform augmented CSN into compact "official" CSN

// Augmented CSN is the CDS model which includes all data which is necessary
// for checks and user-friendly error reporting (sources positions, ...).  See
// file '../compiler/definer.js for technical details.

// The transformation works as follows: from the model object, we just use the
// `definitions` property and transform its value to the following rule:
//  - if it is a non-object, return it directly
//  - if it is an array, return it with all items transformed recursively
//  - if it is a dictionary (object without [[Prototype]]), return it with
//    all property values transformed recursively; properties with value
//    `undefined` are deleted
//  - if it is another object, return it with all property values transformed
//    according to function `transformers.<prop>` or (if it does not exist)
//    recursively to the rule; properties with value `undefined` are deleted

'use strict';

let cloneWithTransformations = require('../base/model').cloneWithTransformations;
const { queryOps } = require('../base/model');
const { mergeOptions }  = require('../model/modelUtils');
const { sortMessages } = require('../base/messages');


function getCompactors(options = {} ) {
  const transformers = {
    '@': compactValue,
    '$': ignore,
    'queries': ignore,          // TODO: make it $queries
    viaAll: ignore,
    actions: compactActions,
    blocks: ignore,
    columns: ( c, node, r ) => { if (c && c[0] && c[0].val === '*') r.all = true; },
    annotationAssignments: ignore, // original with structure values
    kind: filterKind,
    location: ignore,
    name: ignore,
    // foreignKeys: compactForeignKeys,
    implicitForeignKeys: ignore,
    calculated: ignore,         // implicit foreign key
    type: options.hanaFlavor ? followTypeOf : compactName,
    projection: ignore,
    quantifier: ( q, node, r ) => { r[ q.val ] = true; },
    all: asBool,
    origin: o => o._artifact && o._artifact._outer ? undefined : compactName(o),
    target: compactName,
    scope: ignore,
    query: compactQuery,
    from: n => n.map( compactWithAbsolute ),
    args: n => n.map( compactWithAbsolute ),
    path: compactPath,
    quoted: ignore,             // really?  What about CURRENT_DATE vs "CURRENT_DATE"?
    targetElement: compactTargetElement,
    length: value,
    precision: value,
    scale: value,
    srid: value,
    typeArguments: ignore,
    sourceMax: value,
    targetMin: value,
    targetMax: value,
    artifacts: ignore,
    dbType: asBool,
    typeOf: options.hanaFlavor ? ignore : asBool,
    key: asBool,
    localized: asBool,
    virtual: asBool,
    value: value,
    // val: value,
    alias: compactName,
    notNull: asBool,
    abstract: asBool,
    masked: asBool,
    includes: compactIncludes,
    sequenceOptions: ignore,    // TODO: currently not in the JSON by HANA
    default: compactCondOrExpr,
    annoExtensions: ignore,
    extensions: ignore,
    onCond : compactCondOrExpr,
    on: (x => (typeof x === 'string') ? undefined : compactCondOrExpr(x)),
    where: compactCondOrExpr,
    groupBy: compactCondOrExpr,
    having: compactCondOrExpr,
    limit: value,
    offset: value,
    redirected: asBool,
    opLocation: ignore, // TODO: clarify expression parser depth and the locations to the nodes
    op: compactOp,
  }

  function compactOp(node) {
    if(node && node.val) return node.val;
    return node;
  }

  const typeProperties = [        // used in followTypeOf()
    'length', 'precision', 'scale', 'srid', 'items', 'target', 'source',
    'elements', 'enum'
  ]

  // Export all publicly usable compactors here
  // FIXME: Once we get rid of 'options', we won't need the indirection via getCompactors any more
  return {
    compactNode,
    compactValue,
    compactName,
    compactPath,
    compactCondOrExpr,
  };

  // Default compactor - applies all transformers listed above
  function compactNode(node) {
    return cloneWithTransformations(node, transformers);
  }

  function ignore() {}

  function asBool(loc) {
    return loc && loc.val;
  }

  function value(val) {
    return (val == null || typeof val !== 'object')
      ? val
      : compactValue(val);
  }

  function filterKind(kind) {
    // We always filter these
    if (!['element', 'key', 'enum', 'annotate', '$tableAlias'].includes(kind))
      return kind;
    return undefined;
  }

  function compactTargetElement( elem, node, result ) {
    if (!elem || typeof elem !== 'object')
      return null;
    result.path = compactPath( elem.path ); // compatibility - TODO: use {ref:[…]} .
    return undefined;
  }

  function compactName( name ) {
    if (!name || typeof name !== 'object')
      return null;
    if (name.absolute || name._artifact && name._artifact.kind !== 'builtin')
      return refString( name );
    return null;                // for CURRENT_DATE etc in origin
  }

  function followTypeOf( name, node, r ) {
    if (!name._artifact || name._artifact.kind !== 'element')
      return compactName( node.type );

    let final = node._finalType;
    while (node !== final && node.type._artifact && node.type._artifact.kind === 'element')
      // We do not need to consider `origin`, as this is for --hana-flavor
      node = node.type._artifact;

    for (let prop of typeProperties) {
      if (node[prop] !== undefined) {
        let func = transformers[prop];
        let item = func ? func(node[prop]) : compactNode(node[prop]);
        if (item !== undefined)
          r[prop] = item;
      }
    }
    return node.type ? compactName( node.type ) : undefined;
  }

  function compactPath( path ) {
    return path && path.map( id => id.id ).join('.');
  }

  function compactActions(actions) {
    // Ignore empty actions section
    if (!actions || Object.keys(actions).length === 0) {
      return undefined;
    }
    return compactNode(actions)
  }

  function compactIncludes(includes) {
    return includes.map( refString );
  }
  // Transform value `node` to the official CSN form
  // TODO: small change so it can also be used instead of `value` and `asBool`
  function compactValue( node ) {
    if (!node)
      return true;                // `@aBool` short for `@aBool: true`
    if (node.literal === 'array')
      return node.val.map( compactValue );
    if (node.literal === 'enum') {
      return { "#" : node.symbol.id };
    }
    if (node.path)              // TODO: incompatibility HANA CDS
      return { '=': node.path.map( id => id.id ).join('.') };

    if(node.op && node.op.val === "notyet" && node.args === undefined) { // TODO: remove this when notyet is gone
      return { op : "notyet" };
    }

    if(node instanceof Array || node.op && node.args) {
      return compactCondOrExpr(node)
    }
    if (node.literal !== 'struct')
      return !('val' in node) || node.val;
    let r = Object.create( null );
    for (let prop in node.struct)
      r[prop] = compactValue( node.struct[prop] );
    return r;
  }

  function compactQuery( query, node, result ) { // not for projections - TEMP?
    if (query.from && query.from.length === 1 && query.from[0] && query.from[0].path)
      result.source = compactName( query.from[0] );
    return (node.projection) ? undefined : compactCondOrExpr( query );
  }

  function compactWithAbsolute( node ) {
    let r = compactNode( node );
    if (node._artifact)
      r.absolute = node._artifact.name.absolute;
    return r;
  }

  // Compact a condition or expression tree
  // TODO: there should be nothing special about it, i.e. performed by compactNode()
  // if ref paths are written as { ref: […] } and values like { val: […] }
  function compactCondOrExpr(condOrExpr) {
    if (condOrExpr == null || typeof condOrExpr !== 'object')
      return condOrExpr;
    if (Array.isArray(condOrExpr)) { // brackets in expressions result arrays
      let r = condOrExpr.map(compactCondOrExpr);
      return r;
    }
    // Query expressions are rendered as normal nodes (as should all, see TODO above)
    if (condOrExpr.op && queryOps[ condOrExpr.op.val ])
      return compactNode( condOrExpr );
    // Dive recursively into nested conditions or expressions
    if (condOrExpr && 'op' in condOrExpr && 'args' in condOrExpr) {
      let r = { op : condOrExpr.op.val, args : condOrExpr.args.map(compactCondOrExpr) };
      if(condOrExpr.quantifier)
        r.quantifier=condOrExpr.quantifier.val;
      if (condOrExpr.func)
        r.func = compactPath( condOrExpr.func.path );
      return r;
    }
    // Treat everything else as values
    return compactValue(condOrExpr);
  }
}

// Top-level compactor function for a whole model. Strips everything but definitions,
// compacts definitions, according to provided 'options' or model options.
function compact( model, options ) {
  options = mergeOptions(model.options, options);
  const { compactNode } = getCompactors(options);
  let newModel = { definitions: compactNode(model.definitions) }
  for (let name in newModel.definitions) {
    let art = newModel.definitions[name];
    if (art && typeof art === 'object' && art.kind === 'namespace')
      delete newModel.definitions[name];
  }
  // hard code the final old style compact CSN version
  if (!options.testMode) {
    newModel.version = { csn: "0.1.0" };
  }

  let PERSIST_COMPACTED_CSN = "PERSIST_COMPACTED_CSN" in process.env;
  if(PERSIST_COMPACTED_CSN) {
    let fs = require("fs");
    let rnd = Math.random();
    let fn1 = "tmp/csn."+rnd+".augmented.json"
    let fn2 = "tmp/csn."+rnd+".compacted.json"
    let augmentedModel = { definitions: model.definitions};
    fs.writeFileSync(fn1, JSON.stringify(augmentedModel,null,2));
    let dumpModel = { definitions: compactNode(model.definitions)};
    fs.writeFileSync(fn2, JSON.stringify(dumpModel,null,2));

    //options
    let fn3 = "tmp/csn."+rnd+".options.json"
    fs.writeFileSync(fn3, JSON.stringify(options,null,2));
  }

  return newModel;
}

// normalize CSN: sort properties alphabetically if no prototype (also sort model.definitions)
// for "niceness", put the following properties first: op, kind, name
const earlyProperties = { op: '\x01', kind: '\x02', name: '\x03' };

function compactSorted( ...args ) {
  return sortCsn(compact( ...args ));
}

function sortCsn(model) {
  if (model.definitions) {
    let result = Object.create(null);
    let definitions = model.definitions;
    for (let k of Object.keys( definitions ).sort())
      result[k] = normalizeNode( definitions[k] );
    model.definitions = result;
  }
  if (model.messages) {
    model.messages = sortMessages(model.messages);
  }
  return model;
}

// TODO: put the following directly into compact() ?
function normalizeNode( node ) {
  if (node === null || typeof node !== 'object') {
    return node
  }
  // Transform arrays element-wise
  if (node instanceof Array) {
    return node.map( normalizeNode );
  }
  // Things not having 'proto' are dictionaries
  let proto = Object.getPrototypeOf(node);
  // Iterate own properties of 'node' and transform them into 'resultNode'
  let result = Object.create(proto);
  let keys = Object.keys(node);
  if (proto)
    keys.sort( compareProperties );
  for (let k of keys)
    result[k] = normalizeNode( node[k] );
  return result;
}

function compareProperties( a, b ) {
  if (a === b)
    return 0;
  else if ((earlyProperties[a] || a) < (earlyProperties[b] || b))
    return -1;
  else
    return 1;
}

// Return string for complete reference
function refString( name ) {
  // prepare that resolvePath does not set ref.absolute etc:
  if (name._artifact)
    name = name._artifact;
  if (name.name)
    name = name.name;
  let compact = '';
  if (name.alias)
    compact = '.$alias.' + name.alias;
  if (name.action)
    compact = '.$action.' + name.action;
  if (name.param)
    compact += '.$param.' + name.param;
  if (name.element)
    compact += (compact ? '.' : '..') + name.element;
  // Yes, omit $query.0 -> test is (name.query), not (name.query != null)
  return name.absolute +
    (name.query ? '.$query.' + name.query : '') + compact;
}

module.exports = {
  compact,
  compactSorted,
  getCompactors,
  sortCsn,
};
