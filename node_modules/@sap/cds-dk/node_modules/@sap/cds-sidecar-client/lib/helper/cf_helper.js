const os = require('os');
const { execFile } = require('child_process');
const logger = require('./logging');
const { schemaRegex } = require('./url_helper');
const format = require('./string_helper').formatObjectsFixedWidth;

function getErrorMessage(error, stdout) {
    return stdout.includes('Not logged in')
        ? 'not logged in'
        : error && error.message || stdout.replace('\n', ' ');
}

async function getAppFromSuggestions() {
    const apps = await getApps();
    if (apps.length === 0) {
        logger.debug('Failed to obtain list of apps from CF');
        return undefined;
    }

    const askQuestion = require('./question').askQuestion;
    let choice;
    do {
        choice = await askQuestion(`App URL not given.  From the following apps running in the CF org and space you are logged into,
select one by entering a number or leave empty to quit:

${format(apps, ['name', 'url'], 3, { numbering: true })}

Your choice: `);

        if (!choice) {
            break;
        }
        choice = Number(choice);
    } while (choice > apps.length + 1);

    if (!choice) {
        logger.debug('No app URL selected');
        return undefined;
    }

    return apps[choice - 1];
}

async function getApps(nameRegex = /(?<!-db)$/) {
    logger.debug('Getting apps from CF');

    return new Promise(resolve => {
        execFile('cf', ['apps'], function(error, stdout) {
            if (! /^OK$/m.test(stdout)) {
                return resolve(errorResult(getErrorMessage(error, stdout)));
            }

            const relevantLines = getRelevantLines(stdout);

            const heading = relevantLines.shift();
            if (!heading || relevantLines.length === 0) {
                return resolve(errorResult('CF reports no running apps'));
            }
            const offsets = {
                name: 0,
                state: heading.indexOf('requested state'),
                urls: heading.indexOf('urls')
            };

            const result = [];

            relevantLines.forEach(line => {
                if (getSubstring(line, offsets.state) !== 'started') {
                    return;
                }
                const name = getSubstring(line, offsets.name);
                if (!nameRegex.test(name)) {
                    return;
                }
                let urls = getSubstring(line, offsets.urls, true);
                if (!urls) {
                    return;
                }
                urls.split(/,\s*/).forEach(url => {
                    if (!url.includes('://')) {
                        url = 'https://' + url;
                    }
                    result.push({
                        name,
                        url
                    });
                });
            });

            return resolve(result);
        });
    });

    function getSubstring(line, offset, allowSpace = false) {
        if (allowSpace) {
            return line.substr(offset).trimRight();
        }
        const match = /^\S+/.exec(line.substr(offset));
        if (!match) {
            return undefined;
        }
        return match[0];
    }

    function getRelevantLines(stdout) {
        let relevant = false;
        return stdout.split('\n').filter(line => {
            if (/^name\b/.test(line)) {
                relevant = true;
                return true;
            }
            return line.length && relevant;
        });
    }

    function errorResult(message) {
        logger.debug(`Failed to suggest app URLs: ${message}`);
        return [];
    }
}

async function getSubdomain(appName) {
    logger.debug('Getting subdomain from CF env');

    return new Promise(resolve => {
        execFile('cf', ['env', appName], function(error, stdout) {
            if (! /^OK$/m.test(stdout)) {
                if (stdout.includes('not found')) {
                    return resolve(errorResult(`CF reports that app '${appName}' is not found`));
                }
                return resolve(errorResult(getErrorMessage(error, stdout)));
            }

            const nl = os.EOL;
            const match = new RegExp(`^System-Provided:${nl}(\\{${nl}(?:.+${nl})*\\})`, 'm').exec(stdout);
            if (!match) {
                return resolve(errorResult(`CF reports no system-provided environment for app '${appName}'`));
            }

            let value = JSON.parse(match[1]);
            for (const segment of ['VCAP_SERVICES', 'xsuaa', 0, 'credentials', 'identityzone']) {
                value = value[segment];
                if (!value) {
                    return resolve(errorResult(`CF reports insufficient information for app '${appName}'`));
                }
            }

            return resolve(value);
        });
    });

    function errorResult(message) {
        logger.debug(message);
        return undefined;
    }
}

async function getAppName(appUrl) {
    function equalIgnoringTls(url1, url2) {
        return url1.replace(schemaRegex, '') === url2.replace(schemaRegex, '');
    }

    logger.debug('Getting app name from CF apps');
    const apps = await getApps();
    const app = apps.find(app => equalIgnoringTls(app.url, appUrl));
    return app && app.name;
}

module.exports = {
    getAppFromSuggestions,
    getApps,
    getSubdomain,
    getAppName
};
