const fse = require('fs-extra');
const path = require('path');
const os = require('os');

const { requireGlobal } = require('./helper/dependency_helper');

let keytar;
try {
    keytar = requireGlobal('keytar');
} catch (error) {
    // keytar is optional
}

const logger = require('./helper/logging');
const { extractSubdomain, schemaRegex, defaultSchema } = require('./helper/url_helper');
const { getAppFromSuggestions, getAppName, getSubdomain } = require('./helper/cf_helper');

const SETTINGS_MIGRATION = {
    passcode_url: 'passcodeUrl',         // previous settings key
    to: 'appUrl',                        // from CLI
    url: 'appUrl',                       // from CLI
    'delete-settings': 'deleteSettings', // from CLI
    'clear-invalid': 'clearInvalid'      // from CLI
};
const SETTINGS_KEYS = [
    'appUrl',
    'subdomain',
    'passcodeUrl',
    'tokenUrl'
];
const AUTH_KEYS = [
    'token',
    'tokenExpirationDate',
    'refreshToken'
];
const CENSORED_PARAMS = [
    'passcode',
    'token',
    'refreshToken',
    'reqAuth'
];
const ABBREVIATED_PARAMS = [
    'passcodeUrl',
    'tokenUrl'
];
const HIDDEN_PARAMS = [
    'clearOtherTokenStorage'
];

const TOKEN_STORAGE = {
    plain: 'plain',
    keyring: 'keyring'
};
const TOKEN_STORAGE_DESCRIPTION = {
    plain: 'plain-text storage',
    keyring: 'keyring'
};
const MTX_FULLY_QUALIFIED = 'com.sap.cds.mtx';
const OAUTH_PATH = '/mtx/v1/oauth/token';

const KEYRING_DESIGNATIONS = {
    linux: 'libsecret',
    darwin: 'Keychain',
    win32: 'Credential Vault'
}
const CONFIG_SUBDIRS = {
    linux: '.config',
    darwin: path.join('Library', 'Preferences'),
    win32: 'AppData'
}

const SETTINGS_DIR = path.join(os.homedir(), CONFIG_SUBDIRS[os.platform()] || '', MTX_FULLY_QUALIFIED);
const SETTINGS_FILE = 'projects.json';
const AUTH_FILE = 'auth.json';

const CONFIG = {
    paths: {
        settings: path.join(SETTINGS_DIR, SETTINGS_FILE),
        auth: path.join(SETTINGS_DIR, AUTH_FILE)
    },
    keyringDesignation: KEYRING_DESIGNATIONS[os.platform()] || 'not supported'
};


/* Nomenclature:
    Settings are persisted. In this file, "settings" is meant to include "persistable options".
    Options  are passed along the API.  Options take precedence over settings.
    Params   are a mixture of settings and/or options.
 */


function getProjectFolder(settings) {
    return path.resolve(settings.projectFolder || settings.directory || (
        fse.existsSync(settings.subdomain)
            ? settings.subdomain
            : '.'
    ));
}

function removeFalsy(params) {
    if (!params) {
        return;
    }
    for (const [key, value] of Object.entries(params)) {
        if (value === undefined || value === null) {
            delete params[key];
        }
    }
    return params;
}

function filter(params, allowedKeys) {
    const result = Object.assign({}, params);
    Object.keys(result).forEach(key => {
        if (!allowedKeys.includes(key)) {
            delete result[key];
        }
    });
    return result;
}

async function getAppUrlAndSubdomainFromSuggestions(params) {
    const app = await getAppFromSuggestions();
    if (!app) {
        return;
    }

    params.appUrl = app.url;

    if (!params.subdomain) {
        params.subdomain = await getSubdomain(app.name);
        if (params.subdomain) {
            logger.log(`Subdomain determined from CF app environment: ${params.subdomain}`);
        } else {
            logger.log('Failed to determine subdomain from CF app environment');
        }
    }
}

function getTokenBaseUrl(params, renewUrl) {
    if (params.tokenUrl && !renewUrl) {
        return params.tokenUrl;
    }
    if (!params.appUrl) {
        throw new Error('Failed to determine token URL: app URL not given');
    }
    const baseUrl = new URL(params.appUrl);
    baseUrl.pathname = baseUrl.pathname.replace(/\/?$/, OAUTH_PATH);
    return baseUrl.toString();
}

function getKeyringAccountName(params) {
    return `${params.appUrl}|${params.subdomain}`;
}

function format(params) {
    const censoredSettings = Object.assign({}, params);
    const censoredValue = '...';
    for (const key in params) {
        if (!params.hasOwnProperty(key)) {
            continue;
        }
        if (HIDDEN_PARAMS.includes(key)) {
            delete censoredSettings[key];
        }
        if (CENSORED_PARAMS.includes(key) || !process.env.DEBUG && ABBREVIATED_PARAMS.includes(key)) {
            censoredSettings[key] = censoredValue;
        }
    }
    return JSON.stringify(censoredSettings);
}

function logConfigPaths() {
    logger.debug(`Settings are stored in ${CONFIG.paths.settings}`);
    logger.debug(`Authentication data is stored in ${CONFIG.paths.auth} or keyring ('${CONFIG.keyringDesignation}' on this platform)`);
}


class SettingsManager {

    static init() {
        logConfigPaths();
    }

    static get config() {
        return CONFIG;
    }

    // Call with params.projectFolder as a resolved path.
    static async saveSettings(params) {
        logger.debug(`Saving settings for project ${params.projectFolder}`);
        if (params.token && ! params.tokenStorage) {
            logger.log('Note: the authentication token is not saved by default. To save the token for later commands, please run `cds login`.');
        }

        const migrated = this.migrateSettings(params);

        await this._saveToFile(params.projectFolder, filter(migrated, SETTINGS_KEYS));

        if (!migrated.token) {
            return;
        }

        if (migrated.clearOtherTokenStorage) {
            // Delete token from the other storage.
            await this.deleteToken(migrated, migrated.tokenStorage === TOKEN_STORAGE.keyring ? TOKEN_STORAGE.plain : TOKEN_STORAGE.keyring);
            delete migrated.clearOtherTokenStorage;
        }

        const auth = filter(migrated, AUTH_KEYS);
        if (migrated.tokenStorage === TOKEN_STORAGE.plain) {
            await this._saveAuthToFile(migrated, auth);
        } else if (migrated.tokenStorage === TOKEN_STORAGE.keyring) {
            await this._saveAuthToKeyring(migrated, auth);
        }
    }

    static async addSettings(params) {
        logger.debug(`Adding settings ${format(params)}`);

        const merged = await this.loadAndMergeSettings(params);
        await this.saveSettings(merged);
    }

    static async loadAndMergeSettings(options, logout = false) {
        options = Object.assign({}, options, { projectFolder: getProjectFolder(options) });
        delete options.directory;
        removeFalsy(options);

        logger.debug(`Loading settings for project ${options.projectFolder}`);

        const settings = await this._loadFromFile(options.projectFolder);
        logger.debug(`Loaded project settings: ${format(settings)}`);

        const params = await this.mergeAndNormalize(settings, options, logout);
        await this.checkKeytar(params, logout);
        const auth = params.username ? {} : await this.getAuthData(params);
        const paramsWithAuth = Object.assign({}, params, auth);
        logger.debug(`Effective project settings: ${format(paramsWithAuth)}`);

        return paramsWithAuth;
    }

    static async mergeAndNormalize(settings, options, logout) {
        let params;

        function merge() {
            const migratedOptions = SettingsManager.migrateSettings(options);
            params = Object.assign({}, settings, migratedOptions);
        }
        function addSchema() {
            if (params.appUrl && !schemaRegex.test(params.appUrl)) {
                params.appUrl = defaultSchema + params.appUrl;
                logger.debug(`Added schema to app URL: ${params.appUrl}`);
            }
        }
        async function addAppUrlAndSubdomain() {
            if (!logout) {
                if (!params.appUrl) {
                    await getAppUrlAndSubdomainFromSuggestions(params);
                } else if (!params.subdomain) {
                    const appName = await getAppName(params.appUrl);
                    if (appName) {
                        params.subdomain = await getSubdomain(appName);
                    }
                }
            }
            if (!params.appUrl) {
                throw new Error('App URL not given');
            }
            if (!params.subdomain) {
                params.subdomain = extractSubdomain(params.appUrl);
                if (!params.subdomain) {
                    throw new Error('Subdomain not given');
                }
            }
        }
        async function addPassword() {
            if (params.username && !params.password) {
                const askQuestion = require('./helper/question').askQuestion;
                params.password = await askQuestion('Password: ', undefined, true);
                if (params.password === '') {
                    throw new Error('Password cannot be empty');
                }
            }
        }
        function renewTokenUrl() {
            const renewUrl = params.appUrl !== settings.appUrl;
            if (!params.tokenUrl || renewUrl) {
                params.tokenUrl = getTokenBaseUrl(params, renewUrl);
            }
        }

        merge();
        addSchema();
        await addAppUrlAndSubdomain();

        if (!logout) {
            await addPassword();
            renewTokenUrl();
        }

        return params;
    }

    static migrateSettings(settings) {
        const result = Object.assign({}, settings);

        if (!settings) {
            return result;
        }

        Object.entries(SETTINGS_MIGRATION).forEach(([oldKey, newKey]) => {
            if (result.hasOwnProperty(oldKey)) {
                // Un-migrated `oldKey` will be from options, not settings. May overwrite setting `newKey`.
                result[newKey] = result[oldKey];
                delete result[oldKey];
                logger.debug(`Migrated setting '${oldKey}' to new key '${newKey}'`);
            }
        });

        return result;
    }

    static async checkKeytar(params, logout) {
        if (!keytar) {
            if (params.tokenStorage === TOKEN_STORAGE.keyring) {
                throw new Error('Keyring storage requested but keytar not installed. Please run `npm install -g keytar` and try again.');
            }
            if (params.renewLogin || logout) {
                logger.log('Disabling keyring functionality: \'keytar\' module not found. Run `npm install -g keytar` to install it.');
            }
        }
    }

    static async getAuthData(params) {
        function other(tokenStorage) {
            return tokenStorage === TOKEN_STORAGE.plain ? TOKEN_STORAGE.keyring : TOKEN_STORAGE.plain;
        }

        logger.debug(`Consolidating authentication data for project ${params.projectFolder}`);

        const auth = {
            keyring: await this._loadAuthFromKeyring(params.appUrl, params.subdomain),
            plain: await this._loadAuthFromFile(params.appUrl, params.subdomain)
        };

        if (!auth.keyring.tokenStorage && !auth.plain.tokenStorage) {
            // No data stored.
            return {};
        }

        // If `keytar` is not functional, keyring storage will not be selected.

        if (auth.keyring.tokenStorage && auth.plain.tokenStorage) {
            // Both storage places contain data. Prefer selected or keyring.
            const storage = params.tokenStorage || TOKEN_STORAGE.keyring;
            logger.debug('WARNING: authentication data found in both kinds of storage. ' +
                `Using data from ${TOKEN_STORAGE_DESCRIPTION[storage]}; other storage will be cleared when next saving.`);
            return Object.assign(auth[storage], {
                clearOtherTokenStorage: true
            });
        } else if (params.tokenStorage && auth[other(params.tokenStorage)].tokenStorage) {
            // Selected storage contains no data. Retrieve from other one, but earmark selected for saving.
            logger.debug(`Using authentication data from ${TOKEN_STORAGE_DESCRIPTION[other(params.tokenStorage)]}; will be migrated to other storage on save.`);
            return Object.assign(auth[other(params.tokenStorage)], {
                tokenStorage: params.tokenStorage,
                clearOtherTokenStorage: true
            });
        } else {
            // Selected storage contains data, or no storage selected.
            const storage = auth.keyring.tokenStorage || auth.plain.tokenStorage;
            logger.debug(`Using authentication data from ${TOKEN_STORAGE_DESCRIPTION[storage]}.`);
            return auth[storage];
        }
    }

    static async deleteToken(options, fromStorage) {
        const params = await this.loadAndMergeSettings(options, true);

        const target = `URL ${params.appUrl}, subdomain '${params.subdomain}'`;
        logger.debug(`Deleting authentication data for ${target}`);

        let unchanged = true;
        fromStorage = fromStorage || params.tokenStorage;
        if (fromStorage === TOKEN_STORAGE.plain || params.clearOtherTokenStorage) {
            await this._saveAuthToFile(params, null);
            unchanged = false;
        }
        if (fromStorage === TOKEN_STORAGE.keyring || params.clearOtherTokenStorage) {
            await this._saveAuthToKeyring(params, null);
            unchanged = false;
        }
        if (unchanged) {
            logger.log(`No authentication data found for ${target}`);
        }
    }

    static async deleteSettingsWithoutToken(options) {
        const projectFolder = getProjectFolder(options);
        logger.debug(`Deleting settings for project ${projectFolder}`);
        await this._saveToFile(projectFolder, null);
    }

    static async deleteInvalid() {
        logger.log('Deleting invalid project settings');

        const allSettings = await this._loadFromFile(undefined, true);
        const deletionFolders = [];
        const deletionUrlsAndSubdomains = new Set();

        Object.entries(allSettings)
            .filter(entry => ! fse.pathExistsSync(entry[0]))
            .forEach(entry => {
                delete allSettings[entry[0]];
                deletionFolders.push(entry[0]);
                deletionUrlsAndSubdomains.add(entry[1].appUrl + '|' + entry[1].subdomain);
            });

        await this._saveAllSettingsToFile(allSettings);

        if (deletionFolders.length) {
            for (const urlAndSubdomain of deletionUrlsAndSubdomains.values()) {
                const appUrl = urlAndSubdomain.replace(/\|.*/, '');
                const subdomain = urlAndSubdomain.replace(/.*\|/, '');
                const urlReference = Object.values(allSettings).find(settings => settings.appUrl === appUrl && settings.subdomain === subdomain);
                if (!urlReference) {
                    await this.deleteToken({ appUrl, subdomain });
                }
            }
            logger.log(`Deleted settings for nonexistent project folders:${deletionFolders.map(folder => ' ' + folder)}`);
        } else {
            logger.log('All settings seem valid');
        }
    }

    static async _saveToFile(projectFolder, settings) {
        const allSettings = await this._loadFromFile(undefined, true);
        if (settings === null) {
            delete allSettings[projectFolder];
            await this._saveAllSettingsToFile(allSettings);
            logger.log('Deleted project settings');
        } else {
            allSettings[projectFolder] = settings;
            await this._saveAllSettingsToFile(allSettings);
            logger.debug(`Saved project settings: ${format(settings)}`);
        }
    }

    static async _saveAllSettingsToFile(allSettings) {
        logger.debug(`Saving all settings to ${CONFIG.paths.settings}`);
        await fse.outputJson(CONFIG.paths.settings, allSettings, { spaces: 2 });
        logger.debug('Saved settings');
    }

    static async _saveAuthToFile(settings, auth) {
        logger.debug(`Updating authentication data to ${CONFIG.paths.auth}`);
        const location = `plain-text storage for app URL ${settings.appUrl}, subdomain ${settings.subdomain}`;

        const allAuthInfo = await this._loadAuthFromFile(undefined, undefined, true);
        if (auth) {
            (allAuthInfo[settings.appUrl] || (allAuthInfo[settings.appUrl] = {}))[settings.subdomain] = auth;
            await fse.outputJson(CONFIG.paths.auth, allAuthInfo, { spaces: 2 });
            logger.log(`Saved authentication data to ${location}`);
        } else if (allAuthInfo[settings.appUrl]) {
            delete allAuthInfo[settings.appUrl][settings.subdomain];
            if (Object.keys(allAuthInfo[settings.appUrl]).length === 0) {
                delete allAuthInfo[settings.appUrl];
            }
            await fse.outputJson(CONFIG.paths.auth, allAuthInfo, { spaces: 2 });
            logger.log(`Deleted authentication data from ${location}`);
        } else {
            logger.log(`No authentication data to delete from ${location}`);
        }
    }

    static async _saveAuthToKeyring(settings, auth) {
        logger.debug('Updating authentication data to keyring');
        const location = `keyring for app URL ${settings.appUrl}, subdomain ${settings.subdomain}`;

        if (auth === null) {
            await keytar.deletePassword(MTX_FULLY_QUALIFIED, getKeyringAccountName(settings));
            logger.log(`Deleted authentication data from ${location}`);
        } else {
            await keytar.setPassword(MTX_FULLY_QUALIFIED, getKeyringAccountName(settings), JSON.stringify(auth));
            logger.log(`Saved authentication data to ${location}`);
        }
    }

    static async _loadFromFile(projectFolder, all = false) {
        if (!fse.existsSync(CONFIG.paths.settings)) {
            logger.debug('Settings file absent');
            return {};
        }

        logger.debug('Reading settings file');
        const allSettings = await fse.readJson(CONFIG.paths.settings);

        if (!allSettings) {
            logger.debug('Empty settings file');
            return {};
        }

        if (all) {
            return allSettings;
        }

        if (!allSettings[projectFolder]) {
            logger.debug(`No settings found for project ${projectFolder}`);
            return {};
        }

        return allSettings[projectFolder];
    }

    static async _loadAuthFromFile(appUrl, subdomain, all = false) {
        if (!fse.existsSync(CONFIG.paths.auth)) {
            logger.debug('Authentication-data file absent');
            return {};
        }

        logger.debug(`Reading authentication data from ${CONFIG.paths.auth}`);
        const allAuth = await fse.readJson(CONFIG.paths.auth);

        if (!allAuth) {
            logger.debug('Empty authentication data');
            return {};
        }

        if (all) {
            return allAuth;
        }

        if (!allAuth[appUrl]) {
            logger.debug(`No authentication data found for app URL ${appUrl}`);
            return {};
        }

        const authForUrl = allAuth[appUrl];

        const authForSubdomain = authForUrl[subdomain];
        if (!authForSubdomain) {
            logger.debug(`No authentication data found for subdomain ${subdomain}`);
            return {};
        }

        if (authForSubdomain.token) {
            authForSubdomain.tokenStorage = TOKEN_STORAGE.plain;
        }

        return authForSubdomain;
    }

    static async _loadAuthFromKeyring(appUrl, subdomain) {
        if (!keytar) {
            return {};
        }

        logger.debug('Reading authentication data from keyring');

        const authString = await keytar.getPassword(MTX_FULLY_QUALIFIED, getKeyringAccountName({ appUrl, subdomain }));

        if (!authString) {
            logger.debug(`No authentication data found for URL ${appUrl} and subdomain '${subdomain}'`);
            return {};
        }

        let auth;

        try {
            auth = JSON.parse(authString);
        } catch (error) {
            auth = {};
        }

        if (auth.token) {
            auth.tokenStorage = TOKEN_STORAGE.keyring;
        }

        return auth;
    }

}

module.exports = SettingsManager;
