const got = require('got');
const path = require('path');
const BaseCommand = require('./base_command');
const clientLog = require('./helper/logging');
const fs = require('fs-extra');
const fsHelper = require('./helper/fs_helper');
const AuthManager = require('./auth_manager');

const COMMAND_URL_SUFFIX = 'asyncActivate';
const STATUS_URL_SUFFIX = 'status';
const UPDATE_CUSTOM_FILE_URL_SUFFIX = 'updateCustomTenantContent';

const I18N_WHITELIST = ['.properties', '.csv'];

const JOB_STATUS = {
    QUEUED: 'QUEUED',
    RUNNING: 'RUNNING',
    FINISHED: 'FINISHED',
    FAILED: 'FAILED'
};

async function checkFinished(jobId, statusUrl, authOptions, finisher) {
    const getOptions = Object.assign({
        method: 'GET'
    }, authOptions);

    let jobResult = await got(statusUrl, getOptions).json();

    if (!jobResult) {
        return finisher.reject(new Error(`Job ${jobId} failed: did not receive job result`));
    }
    if (typeof jobResult === 'string') {
        jobResult = JSON.parse(jobResult);
    }
    const { status, error } = jobResult;

    if ((status === JOB_STATUS.FINISHED || status === JOB_STATUS.FAILED) && !finisher.finished) {
        finisher.finished = true;
        clearInterval(finisher.timer);
        if (status === JOB_STATUS.FAILED) {
            return finisher.reject(new Error(`Job ${jobId} failed: ${error}`));
        }
        clientLog.log('Extension active');
        finisher.resolve();
    }
}

class Apply extends BaseCommand {

    static get COMMAND_URL_SUFFIX() { return COMMAND_URL_SUFFIX; }
    static get UPDATE_CUSTOM_FILE_URL_SUFFIX() { return UPDATE_CUSTOM_FILE_URL_SUFFIX; }
    static get STATUS_URL_SUFFIX() { return STATUS_URL_SUFFIX; }

    static async run(sources, options) {
        try {
            options = await AuthManager.loginAndUpdateSettings(options);

            if (process.env.DEBUG) {
                clientLog.log('Activating extension with parameters ' + JSON.stringify({
                    appUrl: options.appUrl,
                    projectFolder: options.projectFolder,
                    undeploy: options.undeploy
                }), null);
            } else {
                clientLog.log(`Activating extension located at ${options.projectFolder} to URL ${options.appUrl}`);
            }

            if (!await Apply.checkProject(options.projectFolder)) {
                throw new Error(options.projectFolder + ' is not a valid extension project');
            }

            try {
                await Apply.runApply(sources, options);
                if (options.wsdl) {
                    await Apply.runCustomFileUpload(options.appUrl, options.projectFolder, options.reqAuth);
                }
            } catch (error) {
                Apply.handleHttpError(error, options);
            }
        } catch (error) {
            clientLog.error(undefined, error);
        }
    }

    static async collectExtensionFiles(cds, projectFolder) {

        const absoluteFolder = projectFolder;
        const dbFolder = path.join(absoluteFolder, 'db');
        const srvFolder = path.join(absoluteFolder, 'srv');

        const resolvedPathDb = cds.resolve(dbFolder, { root: dbFolder });
        const resolvedPathSrv = cds.resolve(srvFolder, { root: srvFolder });

        let resolvedPaths = [];
        if (resolvedPathSrv) {
            resolvedPaths = resolvedPaths.concat(resolvedPathSrv);
        }

        if (resolvedPathDb) {
            resolvedPaths = resolvedPaths.concat(resolvedPathDb);
        }

        let allFiles = new Map();

        if (resolvedPaths.length < 1) {
            clientLog.log('No extension files found');
            return allFiles;
        }

        const csn = await cds.load(resolvedPaths);

        const filteredSources = csn._sources && csn._sources.filter((entry) => {
            if (! entry.startsWith(projectFolder)) {
                /* Current file might be below the base model's node_modules, in which case compilation on server should succeed.
                   Otherwise, compilation will probably fail, with this message giving a hint. */
                clientLog.debug(`Source file outside project folder will not be uploaded: ${entry}`);
                return false;
            }
            const unixFilename = fsHelper.toUnixFileName(entry);
            return !/.*node_modules\/_base\/.*/.test(unixFilename);
        }) || [];

        let sourceFiles = await fsHelper.collectFileContent(filteredSources, projectFolder);
        allFiles = new Map([...allFiles, ...sourceFiles]);

        const modelFiles4I18n = {
            _sources: filteredSources
        };

        let i18nFolders = cds.localize.folders4(modelFiles4I18n);
        i18nFolders = i18nFolders.filter(i18nFolder => {
            const unixFilename = fsHelper.toUnixFileName(i18nFolder);
            return !(/.*node_modules\/_base\/.*/.test(unixFilename));
        });

        i18nFolders.forEach(async(folder) => {
            let i18nFiles = await fsHelper.collectFiles(projectFolder, folder, (entry) => {
                const ext = path.extname(entry);
                return I18N_WHITELIST.includes(ext);
            });
            allFiles = new Map([...allFiles, ...i18nFiles]);
        });

        try {
            const pkgJson = await fs.readFile(path.join(absoluteFolder, 'package.json'), 'utf-8');
            allFiles.set('package.json', pkgJson);
        } catch(e) {
            clientLog.log('No package.json file found');
            clientLog.error('No package.json file found', e);
        }

        return allFiles;
    }

    static async collectCustomFiles(projectFolder) {
        const wsdlFolder = path.join(projectFolder, 'wsdl');

        try {
            const wsdlFiles = await fsHelper.collectFiles(projectFolder, wsdlFolder);
            if (wsdlFiles.length === 0) {
                clientLog.log('No custom files found');
            }
            return wsdlFiles;
        } catch (error) {
            clientLog.error(undefined, error);
            throw new Error('No custom files found');
        }
    }

    static async runApply({ cds }, options) {
        let activationUrl;

        return Apply.collectExtensionFiles(cds, options.projectFolder)
        .then(allFiles => {
            if (allFiles.size === 0) {
                return null;
            }

            clientLog.log('Activating extension...');

            activationUrl = Apply.getMtxApiUrl(options.appUrl, Apply.COMMAND_URL_SUFFIX);
            const requestOptions = Object.assign({
                method: 'POST',
                json: {
                    extension: [...allFiles],
                    undeployExtension: options.undeploy
                },
            }, options.reqAuth);

            return got(activationUrl, requestOptions).json();
        })
        .then(response => {
            if (response === null) {
                return;
            }

            const { jobID: jobId, statusPath } = response;

            if (jobId === undefined) {
                throw new Error('Activation failed: did not receive job ID');
            }

            if (!statusPath) {
                throw new Error(`Job ${jobId} failed: did not receive job-status path`);
            }

            clientLog.debug(`Job ID: ${jobId}`);

            return new Promise((resolve, reject) => {
                const statusUrl = new URL(statusPath, activationUrl).toString();
                const finisher = {
                    resolve,
                    reject,
                    finished: false
                };
                finisher.timer = setInterval(checkFinished.bind(undefined, jobId, statusUrl, options.reqAuth, finisher), 250);
            });
        });
    }

    static async runCustomFileUpload(url, projectFolder, authOptions) {
        clientLog.log(`Uploading custom files to ${url}...`);

        const customFiles = await Apply.collectCustomFiles(projectFolder);

        const customFilesSerialized = [];
        customFiles.forEach((value, key) => {
            customFilesSerialized.push({
                category: "wsdl",
                name: key,
                content: value
            });
        });

        const customFileUrl = Apply.getMtxApiUrl(url, Apply.UPDATE_CUSTOM_FILE_URL_SUFFIX);
        const options = Object.assign({
            method: 'POST',
            json: {
                content: customFilesSerialized
            },
        }, authOptions);

        await got(customFileUrl, options);

        clientLog.log('Custom file upload finished');
    }

}

module.exports = Apply;
