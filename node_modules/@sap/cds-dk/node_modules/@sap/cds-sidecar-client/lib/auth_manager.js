const util = require('util');
const got = require('got');
const { URL } = require('url');

const SettingsManager = require('./settings_manager');
const log = require('./helper/logging');

function addTokenInfo(params, authInfo) {
    params.token = authInfo.access_token;
    if (authInfo.expires_in) {
        params.tokenExpirationDate = Date.now() + authInfo.expires_in * 1000;
    } else {
        delete params.tokenExpirationDate;
    }
    if (authInfo.refresh_token) {
        params.refreshToken = authInfo.refresh_token;
    } else {
        delete params.refreshToken;
    }
}
function addUrlInfo(params, authInfo) {
    params.passcodeUrl = authInfo.passcode_url;
}
function getTokenUrl(params) {
    const tokenUrl = new URL(params.tokenUrl);
    tokenUrl.search = `subdomain=${params.subdomain}`;

    if (params.refreshToken) {
        tokenUrl.search += `&refresh_token=${params.refreshToken}`;
    } else if (params.passcode) {
        tokenUrl.search += `&passcode=${params.passcode}`;
    }
    return tokenUrl;
}
function censorAuthData(tokenUrl, params) {
    let cleanUrl = tokenUrl.toString();
    if (params.passcode) {
        cleanUrl = cleanUrl.replace(params.passcode, '<hidden>');
    }
    if (params.refreshToken) {
        cleanUrl = cleanUrl.replace(params.refreshToken, '<hidden>');
    }
    return cleanUrl;
}

async function retrieveTokenOrPasscodeUrl(params) {
    if (params.token) {
        if (params.renewLogin || params.tokenExpirationDate <= Date.now()) {
            log.debug((params.renewLogin ? 'Renewing' : 'Refreshing expired') + ' authentication token');
            delete params.token;
            delete params.tokenExpirationDate;
            delete params.renewLogin;
        } else {
            return;
        }
    }
    if (!params.passcode && !params.refreshToken && params.passcodeUrl) {
        return;
    }

    let retry;
    let authInfo;
    do {
        const tokenUrl = getTokenUrl(params);
        log.debug(`Getting authentication token or passcode URL from ${(censorAuthData(tokenUrl, params))}`);

        const response = await got(tokenUrl.toString(), { method: 'GET', throwHttpErrors: false });
        try {
            authInfo = JSON.parse(response.body);
        } catch (error) {
            throw new Error(`Failed to get authentication token: ${error}.\n` +
                `Response body: ${util.inspect(response && response.body)}`);
        }

        if (authInfo.error_description && authInfo.error !== 'unauthorized') {
            throw new Error(`Failed to get authentication token: ${authInfo.error_description}`);
        }

        retry = !authInfo.access_token && params.refreshToken && (delete params.refreshToken, true);
    } while (retry);

    if (authInfo.access_token) {
        addTokenInfo(params, authInfo);
    } else {
        addUrlInfo(params, authInfo);
    }
}


class AuthManager {

    static async loginAndUpdateSettings(options) {
        SettingsManager.init();
        const params = await SettingsManager.loadAndMergeSettings(options);
        if (params.username) {
            params.reqAuth = { auth: params.username + ':' + params.password };
        } else {
            await retrieveTokenOrPasscodeUrl(params);
            if (!params.token) {
                await SettingsManager.saveSettings(params); // saves token conditionally
                throw new Error('Failed to login: no valid token or passcode provided. ' +
                    'Get a passcode' + (params.passcodeUrl ? ' from ' + params.passcodeUrl : '') +
                    ' and supply the code when re-running the command');
            }
            params.reqAuth = { headers: { Authorization: 'Bearer ' + params.token } };
        }

        await SettingsManager.saveSettings(params); // saves token conditionally

        return params;
    }

    static async logout(options) {
        SettingsManager.init();
        options = await SettingsManager.migrateSettings(options);
        if (options.clearInvalid) {
            await SettingsManager.deleteInvalid();
        } else {
            await SettingsManager.deleteToken(options);
            if (options.deleteSettings) {
                await SettingsManager.deleteSettingsWithoutToken(options);
            }
        }
    }

}

module.exports = AuthManager;
