const COMMAND_URL_SUFFIX = 'content';
const CUSTOM_FILE_FOLDERS = ['wsdl'];
const DB_FOLDER = 'db';
const SRV_FOLDER = 'srv';
const TEMPLATE_FOLDER = 'tpl';

const os = require('os');
const got = require('got');
const path = require('path');
const fs = require('fs-extra');
const BaseCommand = require('./base_command');
const clientLog = require('./helper/logging');
const askBooleanQuestion = require('./helper/question').askBooleanQuestion;
const fsHelper = require('./helper/fs_helper');
const AuthManager = require('./auth_manager');

function folderExists(folder) {
    return `${folder} already contains an extension project, use another directory or use --force.` +
        '\nWhen using --force, make sure you are using a version control system (like git) to avoid data loss';
}


class Extend extends BaseCommand {

    static get COMMAND_URL_SUFFIX() { return COMMAND_URL_SUFFIX; }

    static async storeFiles(content, targetDirectory, filter) {
        const writtenFiles = new Set();
        const filesToWrite = new Map();
        for (const [filename, filecontent] of content) {
            const filepath = path.resolve(targetDirectory, filename);
            if (filepath.startsWith(targetDirectory) && (!filter || await filter(filepath))) {
                filesToWrite.set(filepath, filecontent);
            }
        }
        for (const [filepath, content] of [...filesToWrite.entries()]) {
            let normalizedFilepath = fsHelper.normalizeFileName(filepath);
            fs.mkdirpSync(path.dirname(normalizedFilepath));
            fs.writeFileSync(normalizedFilepath, content);
            writtenFiles.add(path.relative(process.cwd(), normalizedFilepath));
            Extend._logWrittenFile(normalizedFilepath);
        }
        return writtenFiles;
    }

    static async storeCustomFiles(directory, customFiles) {
        let customFileMap = new Map();
        customFiles.forEach(entry => {
            if (entry.category === 'wsdl') {
                let normalizedFilename = fsHelper.normalizeFileName(entry.name);
                let folder = normalizedFilename.split(path.sep)[0];
                if (CUSTOM_FILE_FOLDERS.includes(folder)) {
                    customFileMap.set(entry.name, entry.content);
                }
            }
        });
        await Extend.storeFiles([...customFileMap], directory);
    }

    static async storeTemplateFiles(templates, directory) {
        await Extend.storeFiles(templates, directory, async(filepath) => {
            let normalizedFilename = fsHelper.normalizeFileName(filepath);
            if (!normalizedFilename.includes(path.join(directory, DB_FOLDER)) && !normalizedFilename.includes(path.join(directory, SRV_FOLDER))) {
                clientLog.log(`Ignoring template ${normalizedFilename}: not in ${DB_FOLDER} or ${SRV_FOLDER}`);
                return false;
            }
            return true;
        });
    }

    static async run(options) {
        try {
            options = await AuthManager.loginAndUpdateSettings(options);


            if (process.env.DEBUG) {
                clientLog.log(`\n\nCreating extension project with parameters ${JSON.stringify({
                    appUrl: options.appUrl,
                    projectFolder: options.projectFolder,
                    subdomain: options.subdomain,
                    passcode: options.passcode,
                    username: options.username,
                    password: options.password ? '***' : 'undefined'
                })}`);
            } else {
                clientLog.log(`\n\nCreating extension project for ${options.appUrl}, subdomain '${options.subdomain}', in folder '${options.projectFolder}'`);
            }

            let runOnExistingProject = await Extend.checkProject(options.projectFolder);
            if (runOnExistingProject && !(options.force || options.templates)) {
                throw new Error(folderExists(options.projectFolder));
            }

            try {
                await Extend.runExtend(options);
            } catch (error) {
                await Extend.handleHttpError(error, options);
            }
        } catch (mainError) {
            clientLog.error(undefined, mainError);
        }
    }


    static async runExtend(options) {
        const extendUrl = Extend.getMtxApiUrl(options.appUrl, COMMAND_URL_SUFFIX);
        const requestOptions = Object.assign({
            method: 'GET',
            retry: 0
        }, options.reqAuth);

        clientLog.log('Retrieving files...');

        const [ response ] = await got(extendUrl, requestOptions).json();

        clientLog.log('\nWriting files to: ' + options.projectFolder);

        if (options.templates) {
            await Extend.storeTemplateFilesToTpl(response, options.projectFolder);
            return; // only write templates
        }

        const content = response.base.concat(response.extension);

        await Extend.storeFiles(content, options.projectFolder);

        await fs.mkdirp(path.join(options.projectFolder, DB_FOLDER));
        await fs.mkdirp(path.join(options.projectFolder, SRV_FOLDER));

        clientLog.log(`\nPut database extension models into ${DB_FOLDER} folder.`);
        clientLog.log(`Put service extension models into ${SRV_FOLDER} folder.`);

        if (response.templates && (response.templates.length > 0)) {
            // only write templates if there are no extensions so far
            if (!(response.extension && response.extension.length > 0)) {
                clientLog.log(`Writing template files to ${DB_FOLDER} and ${SRV_FOLDER} folder`);
                await Extend.storeTemplateFiles(response.templates, options.projectFolder);
            } else {
                clientLog.log('Ignoring templates because extension is already active.');
            }
        }

        if (options.wsdl) {

            clientLog.log('Writing custom files');

            const customFileUrl = Extend.getMtxApiUrl(options.appUrl, Extend.CUSTOM_FILE_URL_SUFFIX);
            const customFiles = await got(customFileUrl, options).json();
            await Extend.storeCustomFiles(options.projectFolder, customFiles);
        }
    }

    static async storeTemplateFilesToTpl(response, projectFolder) {
        if (response.templates && (response.templates.length > 0)) {
            const targetDirectory = path.join(projectFolder, TEMPLATE_FOLDER);
            const targetExists = await fs.pathExists(targetDirectory);
            if (!targetExists || await this.promptTemplateOverwrite()) {
                if (targetExists) {
                    await fs.remove(targetDirectory);
                }
                clientLog.log(`Writing template files to ${TEMPLATE_FOLDER} folder`);
                await Extend.storeTemplateFiles(response.templates, targetDirectory);
            }

        } else {
            clientLog.log('No templates available');
        }
    }

    static promptTemplateOverwrite() {
        return askBooleanQuestion(`This  will overwrite extisting templates in folder ${TEMPLATE_FOLDER}. Continue (yN)? `, false, false);
    }

    static _logWrittenFile(file) {
        clientLog.log('CREATE: ' + file);
    }

}

module.exports = Extend;
