const fs = require('@sap/cds-foss')('fs-extra')
const path = require('path')
const cli = require('../../bin/cds')
const _cds = require('..')
const BuildTaskHandlerFactory = require('./buildTaskHandlerFactory')
const { hasJavaNature, isOldJavaStack, adaptBuildTargetSettingForJava, BuildRuntimeError, getProperty } = require('./util')
const { FILE_EXT_CDS, BUILD_TASK_HANA, BUILD_TASK_FIORI, BUILD_TASK_JAVA, BUILD_TASK_NODE, BUILD_TASK_MTX,
    CDS_CONFIG_PATH_SEP, BUILD_MODE_INPLACE } = require("./constants")

const DEBUG = process.env.DEBUG

class BuildTaskFactory {
    constructor(logger, cds) {
        this._logger = logger || global.console
        this._cds = cds ? cds : _cds
        this._handlerFactory = new BuildTaskHandlerFactory(this._logger, this._cds)
    }
    get cds() {
        return this._cds
    }
    get env() {
        return this._cds.env
    }
    get logger() {
        return this._logger
    }

    // the following order for determining build tasks is used
    // 1. create from commandline input, e.g. cds build/all --for hana --src db --model srv --dest db
    // 2. read using cds.env.build.tasks
    // 3. create from cds.env.folders config data
    async getTasks(buildOptions = { root: process.cwd() }) {
        try {
            let tasks = await this._createTasks(buildOptions)
            buildOptions.target = path.resolve(buildOptions.root, this.env.build.target)

            // log build tasks
            let tasksOutput = "   {\n     \"build\": {\n       \"target\": \"" + this.env.build.target + "\",\n       \"tasks\": ["
            for (let i = 0; i < tasks.length; i++) {
                tasksOutput += "\n         " + BuildTaskFactory._stringifyTask(tasks[i]) + (i + 1 < tasks.length ? "," : "")
            }
            tasksOutput += "\n       ]\n     }\n   }\n"
            this.logger.log(tasksOutput)

            if (DEBUG) {
                this.logger.log("[cds] - cds.env used for build:")
                this.logger.log(JSON.stringify(this.env, null, 1))
            }

            // always resolve tasks for input validation
            if (buildOptions.resolve || buildOptions.cli) {
                const resolvedTasks = tasks.map(task => this._handlerFactory.resolveTask(task, buildOptions))
                if (buildOptions.resolve) {
                    return resolvedTasks
                }
            }
            return tasks
        } catch (e) {
            this.logger.log('')
            cli.log(e, { log: this.logger.log })
            throw e
        }
    }

    async _createTasks(buildOptions) {
        const { root: projectPath } = buildOptions
        this.logger.log(`[cds] - determining build tasks for project [${projectPath}].`)

        let tasks = this._getExistingTasks()
        if (tasks.length === 0) {
            tasks = await this._createTasksFromConfig(buildOptions)
            if (tasks.length > 0) {
                this.logger.log(`[cds] - the following build tasks have been auto-created and will be executed.`)
            } else {
                this.logger.log(`[cds] - the following build tasks have been defined and will be executed.`)
            }
        }
        if (buildOptions.cmdOptions) {
            // filters the list of build tasks and adapts according to given CLI options
            tasks = this._applyCliTaskOptions(tasks, projectPath, buildOptions.cmdOptions)
        }
        // ensure correct values for optional build task properties, error for missing mandatory properties
        tasks = this._ensureConsistentTaskSettings(tasks, projectPath)
        return tasks
    }

    _getExistingTasks() {
        let tasks = []
        if (Array.isArray(this.env.build.tasks)) {
            tasks = this.env.build.tasks
        }
        return tasks
    }

    _ensureConsistentTaskSettings(tasks, projectPath) {
        // do not modify existing tasks
        return tasks.map((task) => {
            task = Object.assign(task)
            this._handlerFactory.loadHandler(task)
            this._setTaskSrc(task)
            this._setTaskOptions(task, projectPath)
            return task
        })
    }

    async _createTasksFromConfig(buildOptions) { // NOSONAR
        if (DEBUG) {
            this.logger.log("[cds] - Determining CDS build tasks from CDS configuration - applying defaults")
        }
        const { root: projectPath } = buildOptions
        let db = typeof this.env.folders.db === "string" ? [BuildTaskFactory._normalizePath(this.env.folders.db)] : this.env.folders.db
        let srv = typeof this.env.folders.srv === "string" ? [BuildTaskFactory._normalizePath(this.env.folders.srv)] : this.env.folders.srv

        const defaultModels = this._getDefaultModelOptions(projectPath)
        const dbOptions = {
            model: [...defaultModels]
        }
        const srvOptions = {
            model: [...defaultModels]
        }
        let tasks = []
        if (Array.isArray(db) && db.length > 0) {
            db = BuildTaskFactory._getModuleFolder(projectPath, db) || null
        }
        if (Array.isArray(srv) && srv.length > 0) {
            srv = BuildTaskFactory._getModuleFolder(projectPath, srv) || null
        }
        if (db) {
            // create hana build task
            const dbTask = this._createDbTask(projectPath, db, dbOptions, buildOptions)
            if (dbTask) {
                tasks.push(dbTask)
            }
        } else {
            this.logger.log(`[cds] - project doesn't have a database module [${this.env.folders.db}]`)
        }

        if (srv) {
            // create java or node build task
            const srvTask = this._createSrvTask(projectPath, srv, srvOptions)
            if (srvTask) {
                tasks.push(srvTask)
            }

            // auto-create fiori build tasks only in Webide Fullstack compatibility mode
            if (this.env.build.mode === BUILD_MODE_INPLACE) {
                // create fiori build tasks
                const fioriSrvOptions = {
                    model: [...defaultModels]
                }
                const fioriTasks = this._createFioriTasks(projectPath, fioriSrvOptions)
                if (fioriTasks.length > 0) {
                    const appDirs = this._getFioriAppModelPaths(fioriTasks, projectPath)
                    srvOptions.model = BuildTaskFactory._pushModelPaths(projectPath, srvOptions.model, appDirs)
                    dbOptions.model = BuildTaskFactory._pushModelPaths(projectPath, dbOptions.model, appDirs)
                    tasks = tasks.concat(fioriTasks)
                }
            }
        } else {
            this.logger.log(`[cds] - project doesn't have a service module [${this.env.folders.srv}]`)
        }

        // create mtx build task for node applications
        if (db && tasks.find(task => task.for === BUILD_TASK_NODE)) {
            const mtxTask = this._createMtxTask()
            if (mtxTask) {
                tasks.push(mtxTask)
            }
        }
        return tasks
    }

    _createDbTask(projectPath, src, taskOptions, buildOptions) {
        if (DEBUG) {
            this.logger.log("[cds] - Determining database kind.")
        }
        let task = null

        if (this._useHana(projectPath, buildOptions)) {
            if (DEBUG) {
                this.logger.log("[cds] - Found HANA database.")
            }
            // legacy build supports dest property
            const compileDest = this.env.get("data.dest")
            if (compileDest) {
                //../db/src/gen
                // compileDest is relative to src folder in modular build - resolve correctly
                taskOptions.compileDest = path.relative(path.resolve(projectPath, src), path.resolve(projectPath, compileDest))
            }

            task = {
                src: src,
                for: BUILD_TASK_HANA,
                options: taskOptions
            }
        } else {
            if (DEBUG) {
                this.logger.log("[cds] - Found sqlite database - skipping HANA build task")
            }
        }
        return task
    }

    _useHana(projectPath, buildOptions) {

        if (this.env.get("build.mode") === BUILD_MODE_INPLACE
            // || !this.env.get("requires.db.kind")
            || getProperty(buildOptions, "for.hana.skipManifestGeneration") // fallback for webide fullstack and mtx
            || this.env.get("requires.db.kind") === "hana"
            || this.env.get("requires.db.use") === "hana") {

            return true
        }
        // false if other db has been defined
        if (this.env.get("requires.db.kind")) {
            return false
        }
        // check whether cds config represents a legacy build system config for which requires.db was not configured
        // Note: compat layer sets requires.db: {}
        const userEnv = this.cds.env.for("cds", projectPath, false, true)
        return userEnv && (userEnv.get("data.model") || userEnv.get("service.model"))
    }

    _createMtxTask() {
        if (DEBUG) {
            this.logger.log("[cds] - Determining single or multi-tenant strategy.")
        }
        let task = null

        if (this.env.get("requires.db.multiTenant") === true && (this.env.get("requires.db.kind") === "hana" || this.env.get("requires.db.use") === "hana")) {
            if (DEBUG) {
                this.logger.log("[cds] - Found multi-tenant app.")
            }
            task = {
                src: ".",
                for: BUILD_TASK_MTX,
                dest: "srv"
            }
        } else {
            if (DEBUG) {
                this.logger.log("[cds] - Found single-tenant app - skipping mtx build task")
            }
        }
        return task
    }

    _createSrvTask(projectPath, src, taskOptions) {
        if (DEBUG) {
            this.logger.log("[cds] - Determining implementation technology")
        }
        let task = this._createJavaTask(projectPath, src, taskOptions)

        if (!task) {
            if (DEBUG) {
                this.logger.log("[cds] - Found implementation technology node")
            }
            task = {
                src: src,
                for: BUILD_TASK_NODE,
                options: taskOptions
            }
        }
        return task
    }

    _createJavaTask(projectPath, src, taskOptions) {
        if (this._hasJavaNature(projectPath, src)) {
            if (DEBUG) {
                this.logger.log("[cds] - Found implementation technology java")
            }
            // legacy build supports dest property
            const compileDest = this.env.get("service.dest")
            if (compileDest) {
                // compileDest is relative to src folder in modular build - resolve correctly
                taskOptions.compileDest = path.relative(path.resolve(projectPath, src), path.resolve(projectPath, compileDest))
            }
            // Java projects that do not define any build related configuration use "." as the default build target folder -> compatibility to legacy build.
            // Projects that have build tasks configured also need to configure the build target folder, otherwise the default "gen" is used.
            if (adaptBuildTargetSettingForJava(this.env, projectPath) && DEBUG) {
                this.logger.log("[cds] - using inplace build for java project instead of default staging build")
            }
            return {
                src: src,
                for: BUILD_TASK_JAVA,
                options: taskOptions
            }
        }
        return null
    }

    _createFioriTasks(projectPath, fioriSrvOptions) {
        let tasks = []
        if (DEBUG) {
            this.logger.log("[cds] - Determining fiori modules - matching modules */webapp/manifest.json")
        }
        // fiori-app build-tasks
        let appDirs = this.env.ui && this.env.ui.apps ? this.env.ui.apps : undefined
        if (!appDirs) {
            const DEFAULT_UI_MANIFEST_PATTERNS = [
                "*/webapp/manifest.json" // top-level UI apps  (typical Web IDE layout)
            ]
            let app = BuildTaskFactory._normalizePath(this.env.folders.app)
            if (typeof app === "string") {
                DEFAULT_UI_MANIFEST_PATTERNS.push(path.join(app, "*/webapp/manifest.json"))
            } else if (Array.isArray(app)) {
                app.forEach(entry => DEFAULT_UI_MANIFEST_PATTERNS.push(path.join(entry, "*/webapp/manifest.json")))
            }

            const manifestPaths = BuildTaskFactory._findFiles(projectPath, DEFAULT_UI_MANIFEST_PATTERNS)

            // use '/' for any cds-config path entries
            appDirs = manifestPaths.map(manifestPath => path.relative(projectPath, manifestPath.split("webapp")[0]).replace(/\\/g, CDS_CONFIG_PATH_SEP))
        } else {
            appDirs = appDirs.map(appDir => {
                if (path.basename(appDir) === "webapp") {
                    return path.dirname(appDir)
                }
                return appDir
            })
        }
        if (DEBUG) {
            this.logger.log(`[cds] - Found fiori app paths [${appDirs}]`)
        }
        appDirs.forEach(appDir => {
            appDir = BuildTaskFactory._normalizePath(appDir)
            let modelPaths = this._resolveModel(path.resolve(projectPath, appDir))
            const newTask = {
                src: appDir,
                for: "fiori",
                options: {
                    model: BuildTaskFactory._pushModelPaths(projectPath, fioriSrvOptions.model, modelPaths.length > 0 ? [appDir] : [])
                }
            }
            if (!tasks.find((task) => {
                return task.src === newTask.src && task.for === newTask.for
            })) {
                tasks.push(newTask)
            }
        })
        return tasks
    }

    _getDefaultModelOptions(projectPath) {
        const rm = Object.values(this.env.requires).map(r => r.model).filter(m => m)
        return BuildTaskFactory._pushModelPaths(projectPath, [], this.env.roots, rm)
    }

    _getFioriAppModelPaths(tasks, projectPath) {
        const appDirs = []

        tasks.forEach((task) => {
            // the build task is only relevant if it contains an annotations model
            // only in that case options.model is containing an entry <task.src>
            if (task.for === BUILD_TASK_FIORI && task.options.model.find(cur => cur === task.src)) {
                const appRoot = task.src.split(CDS_CONFIG_PATH_SEP)[0]
                let appDir = task.src
                let model = this._resolveModel(path.resolve(projectPath, appRoot))
                if (model.length > 0) {
                    // appRoot may contain index.cds file
                    appDir = appRoot
                }

                if (appDir && !appDirs.find(cur => cur === appDir)) {
                    appDirs.push(appDir)
                }
            }
        })
        return appDirs
    }

    _resolveModel(modelPath) {
        let model
        try {
            model = this.cds.resolve(modelPath)
        } catch (e) {
            // silently ignore -> assume no model exists
        }
        return model ? model : []
    }

    /**
     * Returns <code>true</code> if this project is an old java service-sdk project,
     * <code>false</code> if it is a java-NG project or if no pom.xml has been found.
     * @param {string} projectPath - the absolute project path
     * @param {string} src - the folder name of the service module
     */
    async _isOldJavaStack(projectPath, src) {
        return isOldJavaStack([path.join(projectPath, src), projectPath])
    }

    /**
     * Returns whether this project is a java project or not.
     * @param {string} projectPath - the absolute project path
     * @param {string} src - the folder name of the service module
     */
    _hasJavaNature(projectPath, src) {
        return hasJavaNature([path.join(projectPath, src), projectPath])
    }

    _applyCliTaskOptions(tasks, projectPath, options) {
        const optionUse = BuildTaskHandlerFactory._getUseValueFromTask(options)
        const optionFor = BuildTaskHandlerFactory._getForValueFromTask(options)

        // filter tasks using either option for, use, src
        tasks = tasks.filter(task => {
            // ensure handler implementation can be loaded
            this._handlerFactory.loadHandler(task)

            // set default src folder for built-in tasks
            this._setTaskSrc(task)

            const taskUse = BuildTaskHandlerFactory._getUseValueFromTask(task)
            return (!optionUse || optionUse === taskUse) && (!options.src || options.src === task.src)
        })

        if (tasks.length === 0 && (options.for || options.use)) {
            tasks = [{}]
            if ((options.for)) {
                tasks[0].for = options.for
            }
            if ((options.use)) {
                tasks[0].use = options.use
            }
            if (options.src) {
                tasks[0].src = options.src
            }
            // Java projects that do not define any build related configuration use "." as the default build target folder
            if (optionFor === BUILD_TASK_JAVA) {
                if (adaptBuildTargetSettingForJava(this.env, projectPath) && DEBUG) {
                    this.logger.log("[cds] - using inplace build for java project instead of default staging build")
                }
            }
        }
        // apply remaining cli options to all tasks
        tasks.forEach(task => {
            if (options.dest) {
                task.dest = options.dest
            }
            if (options.opts) {
                const opts = BuildTaskFactory._scanTaskOptionParams(options.opts)
                task.options = task.options ? Object.assign(task.options, opts) : opts
            }
        })
        return tasks
    }

    _setTaskOptions(task, projectPath) {
        task.options = task.options || {}
        if (!task.options.model || Array.isArray(task.options.model) && task.options.model.length === 0) {
            const models = new Set(this._getDefaultModelOptions(projectPath))
            if (task.src) {
                models.add(task.src)
            }
            task.options.model = [...models]
        }
        else if (!Array.isArray(task.options.model)) {
            task.options.model = [task.options.model]
        }
    }

    _setTaskSrc(task) {
        if (!task.src) {
            const taskFor = BuildTaskHandlerFactory._getForValueFromTask(task)
            switch (taskFor) {
                case BUILD_TASK_HANA:
                    task.src = BuildTaskFactory._normalizePath(this.env.folders.db)
                    break
                case BUILD_TASK_JAVA:
                case BUILD_TASK_NODE:
                    task.src = BuildTaskFactory._normalizePath(this.env.folders.srv)
                    break
                case BUILD_TASK_FIORI:
                    task.src = BuildTaskFactory._normalizePath(this.env.folders.app)
                    break
                case BUILD_TASK_MTX:
                    task.src = "."
                    break
                default:
                    throw new BuildRuntimeError(`Invalid build task definition - value of property 'src' is missing in [${taskFor}].`)
            }
            if (DEBUG) {
                this.logger.log(`Using source folder ${task.src} for build task ${taskFor}`)
            }
        }
    }

    static _stringifyTask(task) {
        // ensures identical order of properties
        const order = ["for", "use", "src", "dest", "options"]
        const keys = Object.keys(task).sort((a, b) => order.indexOf(a) - order.indexOf(b))

        return keys.reduce((acc, key) => {
            return acc + (acc !== "{" ? ", " : "") + JSON.stringify(key) + ":" + JSON.stringify(task[key])
        }, "{") + "}"
    }

    static _scanTaskOptionParams(optsParams) {
        // need to create new regex every call since a constant would keep the match state
        const quoteRegex = /([\w-]+)=([\w/.]+|\[([\w/,.]+)\])/g

        // captures a=1             => a:1
        //          a=[x,y,z]       => a:[x,y,z]
        //          a=1,b=[x,y,z]   => a:1 b=[x,y,z]
        let match = quoteRegex.exec(optsParams)
        const taskOptions = {}

        while (match != null) {
            const key = match[1]
            const value = match[3] || match[2]
            const valueArray = value.split(",")
            taskOptions[key] = valueArray.length > 1 ? valueArray.map((entry) => entry.trim()) : value
            match = quoteRegex.exec(optsParams)
        }
        return taskOptions
    }

    static _pushModelPaths(projectPath, model, ...modelPaths) {
        model = new Set(model)
        // may contain nested arrays
        modelPaths = BuildTaskFactory._flatten(modelPaths)

        modelPaths.forEach(m => {
            if (m && !model.has(m) && !model.has(m + "/")) {
                const dir = path.resolve(projectPath, m)
                if (fs.existsSync(dir)) {
                    model.add(BuildTaskFactory._normalizePath(m))
                } else if (fs.existsSync(dir + FILE_EXT_CDS)) { //might be cds file name, compability to old build configs
                    model.add(m)
                }
            }
        })
        return [...model]
    }

    static _flatten(modelPaths) {
        return modelPaths.reduce((acc, m) => {
            if (Array.isArray(m)) {
                acc = acc.concat(BuildTaskFactory._flatten(m))
            } else if (m) {
                acc.push(m)
            }
            return acc
        }, [])
    }

    static _strippedPath(p) {
        return p.replace(/^(\/|\\)/, '').replace(/(\/|\\)$/, '') // strip leading and trailing slash or backslash
    }

    static _readDirs(dir) {
        if (!fs.existsSync(dir) || !fs.lstatSync(dir).isDirectory()) return []
        return fs.readdirSync(dir)
            .map(f => path.resolve(dir, f))
            .filter(f => fs.lstatSync(f).isDirectory())
    }

    static _findFiles(projectPath, patterns) {
        const files = []
        patterns.forEach(pattern => {
            const starIndex = pattern.indexOf('*')
            if (starIndex >= 0) {
                const dir = path.resolve(projectPath, pattern.substring(0, starIndex))
                const subPattern = BuildTaskFactory._strippedPath(pattern.substring(starIndex + 1, pattern.length)) // '*/foo/bar/' -> 'foo/bar'
                files.push(...BuildTaskFactory._readDirs(dir).map(subDir => BuildTaskFactory._findFiles(subDir, [subPattern])))
            } else {
                const file = path.resolve(projectPath, pattern)
                if (fs.existsSync(file)) files.push(file)
            }
        })

        function _flatten(o, arr = []) {
            if (o) {
                Array.isArray(o) ? o.forEach(e => _flatten(e, arr)) : arr.push(o)
            }
            return arr
        }
        return _flatten(files)
    }

    /**
     * For valid paths remove trailing '/'. Otherwise return as is - important!!
     * @param {*} dir
     */
    static _normalizePath(dir) {
        return typeof dir === "string" ? dir.replace(/\/$/, '') : dir
    }

    /**
     * Determines the module folder from the past list that may represent files or folders w or w/o .cds file extension.
     * @param {string} projectPath
     * @param {Array} filesOrFolders
     */
    static _getModuleFolder(projectPath, filesOrFolders) {
        const resources = [...filesOrFolders]
        filesOrFolders.forEach(fileOrFolder => {
            if (path.extname(fileOrFolder) !== FILE_EXT_CDS) {
                resources.push(fileOrFolder + FILE_EXT_CDS)
            }
        })
        return resources.reduce((acc, resource) => {
            if (!acc) {
                let resourcePath = path.resolve(projectPath, resource)
                if (fs.existsSync(resourcePath)) {
                    if (fs.lstatSync(resourcePath).isDirectory()) {
                        acc = resource
                    } else {
                        // represents file
                        acc = path.dirname(resource)
                    }
                }
            }
            return acc
        }, null)
    }

    // !!! has been used by cds-dk < 1.6.0 !!!
    static _isJavaServiceImpl(dir) {
        return hasJavaNature([dir, path.dirname(dir)])
    }
}
module.exports = BuildTaskFactory
