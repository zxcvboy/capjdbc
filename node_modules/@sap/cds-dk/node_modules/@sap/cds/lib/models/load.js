const cdsc = require('./cdsc'), {_csn4} = require('./parse')
const cds = require ('..')
const env = cds.env.cdsc
let _compile = async (...args) => _csn4 (await cdsc.compile(...args))

module.exports = Object.assign (load, {only:get})

/**
 * cds.load reads and compiles one or more cds source files into
 * an effective model, including all resolved imports.
 * @returns a CDS model is CSN format
 */
async function load (files, o, compile=_compile) {
  if (!files || files.length === 0) files = '*'
  const all = this.resolve (files) || _notFound (files)
  const csn = await compile (all, o && o.cwd, _options(o))
  return _loaded (csn, o)
}

/**
 * cds.get reads and parses a single file, without resolving imports,
 * includes and extensions.
 * @returns a CDS model is CSN format
 */
async function get (files, o, compile=_compile) {
  if (!files || files.length === 0) files = '*'
  const all = this.resolve (files) || _notFound (files)
  const csn = await compile (all, undefined, {..._options(o), parseCdl:true})
  return _loaded (csn, o)
}

function _options (_o) {
  const o = {..._o, ...env}
  const names = o.names || o.sql_mapping || cds.env.sql.names
  if (names !== 'plain') o.sqlMapping = names
  if (o.clean) o.toCsn = {flavor:'gensrc'}
  if (o.docs) o.docComment = true
  return o
}

function _loaded (model, options={}) {
  if (options.min)  model = require('../alpha/_skip_unused') (model)
  if (snapi && model.messages) delete model.messages
  cds.emit ('loaded', model)
  return model
}


function _notFound (file) {
  const e = Object.assign (new Error (`Couldn't find a CDS model for: ${file} in: ${process.cwd()}`), {
      code: 'MODEL_NOT_FOUND', model: file
  })
  Error.captureStackTrace(e,_notFound)
  throw e
}


// adjust for existing/former implementation
const {snapi} = cds.env.features
if (!snapi) {
  const compile_new = _compile; _compile = require('./cdsv').compile
  load.new = function (files,o) { return load.call (this, files, o, compile_new) }
}
