const cdsc = require ('./cdsc')
const cds = require ('..')
const _skip_unused = require ('../alpha/_skip_unused')

const compile = module.exports = Object.assign ((csn) => ({

  /** @example compile(csn).for('odata') */
  for: Object.assign ((x,o) => _fluent (compile.for, x, csn,o), {
    /** @example compile(csn).for.odata() */
    odata: (o)=> compile.for.odata (csn,o),
    hana: (o)=> compile.for.hana (csn,o),
    sql: (o)=> compile.for.sql (csn,o),
  }),

  /** @example compile(csn).to('edmx') */
  to: Object.assign ((x,o) => _fluent (compile.to, x, csn,o), {
    /** @example compile(csn).to.edmx() */
    'edmx-v2': (o)=> compile.to['edmx-v2'] (csn,o),
    'edmx-v4': (o)=> compile.to['edmx-v4'] (csn,o),
    edmx: (o)=> compile.to.edmx (csn,o),
    edm: (o)=> compile.to.edm (csn,o),
    yaml: (o)=> compile.to.yaml (csn,o),
    json: (o)=> compile.to.json (csn,o),
    sql: (o)=> compile.to.sql (csn,o),
    cdl: (o)=> compile.to.cdl (csn,o),
    hdi: (o)=> compile.to.hdi (csn,o),
    hana: (o)=> compile.to.hana (csn,o),
    hdbcds: (o)=> compile.to.hdbcds (csn,o),
    hdbtable: (o)=> compile.to.hdbtable (csn,o),
  }),

}), {

  // NOTE: this is the former cds.parse.cdl
  /** @example compile.cdl(src) */
  cdl: (src,o) => cdsc.compactModel (cdsc.compileSources (src,o)),

  /** @example compile.for.odata(csn) */
  for: {
    // REVISIT: we cache successive calls to for.odata -> wrong if called on same csn with different options
    odata: (csn,o)=> compile4odata (csn, _options4odata(o)),
    sql: compile4sql,
  },

  /** @example compile.for.edmx(csn) */
  to: {
    /** @param {EdmOptions} o */ 'edmx-v2': (csn,o) => compile.to.edmx (csn, {...o, version:'v2'}),
    /** @param {EdmOptions} o */ 'edmx-v4': (csn,o) => compile.to.edmx (csn, {...o, version:'v4'}),
    /** @param {EdmOptions} o */ edmx: (csn,o) => compile2edm (cdsc.to.edmx, csn, o),
    /** @param {EdmOptions} o */ edm: (csn,o={}) => compile2edm (cdsc.to.edm, csn,
      o.version ? o : {...o, version:'v4' },
      o.as === 'str' ? JSON.stringify : x=>x
    ),

    hdbcds: (csn,o) => { _skip_unused (csn); return _2hdbcds (cdsc.to.hdbcds (csn, _options(o)))},
    hana: (csn,o) => compile.to.hdbcds (csn,o),
    hdbtable: (csn,o) => compile.to.hdi (csn, o),
    hdi: (csn,o) => { _skip_unused (csn); return _2many (cdsc.to.hdi (csn, _options(o)))},
    sql: (csn,o) => compile2sql (csn, _options(o)),
    cdl: (csn,o) => _2many (cdsc.to.cdl (csn,o), undefined, {suffix:'.cds'}),

    hdbtabledata: (csn,o) => require('./2tabledata').create (csn,o),
    serviceinfo: (csn,o) => require('./2srvinfo') (csn,o),
    xsuaa: (csn,o) => require('./2xsuaa').xsuaaConfig (csn,o),

    json: x => JSON.stringify (x, _2json, 2),
    yaml: x => YAML.stringify (x),
    yml: x => YAML.stringify (x),
  },

})

if (cds.env.features.snapi === 'runtime-only') {
  const old = require('./compile')
  compile.to.hdbcds = old.to.hana
  compile.to.hana = old.to.hana
  compile.to.hdi = old.to.hdi
  compile.to.sql = old.to.sql
}




function _fluent (compile_, to_or_for, csn, o) {
  let fn = compile_[to_or_for];  if (!fn)  throw new TypeError (`cds.compile.for.${to_or_for} is not defined`)
  if (typeof csn === 'string')  csn = cds.parse (csn)
  return fn (csn,o)
}




/** Adds caching to cdsc.for.odata */
function compile4odata (csn, o) {
  // is this csn allready a model unfolded for odata?
  if (csn.meta && csn.meta.transformation === 'odata')  return csn   // REVISIT w/ @Simon: können wir das nach innen ziehen?
  // was this csn already unfolded for odata before?
  if (csn._4odata)  return csn._4odata
  // actually unfold it...
  const ocsn = cdsc.for.odata (csn,o)
  // preserve ._sources // REVISIT w/ @Simon können wir das auch nach innen ziehen?
  if (!ocsn._sources)  Object.defineProperty (ocsn, '_sources', {value: csn._sources})
  // compatibility with generated csn.json for old Java stack
  if (o.sql_mapping) ocsn['@sql_mapping'] = o.names || o.sql_mapping || cds.env.sql.names
  // cache for subsequent uses
  Object.defineProperty (csn, '_4odata', {value: ocsn, configurable:1, writable:1 })
  return ocsn
}

/** REVISIT: uses internal APIs to restore compile.for.sql in SNAPI */
function compile4sql (csn, _options) {
  const backends = require ('@sap/cds-compiler/lib/backends')
  compile.for.sql = (csn,o) => backends.toSqlWithCsn(csn,{...o, csn:true}).csn
  return compile.for.sql (csn,_options)
}

/**
 * Compiles a given model to EDM or EDMX.
 * Argument `fn` is expected to be one of `cdsc.to.edm` or `cdsc.to.edmx`,
 * which will be executed to generate the respective output.
 *
 * Use option `{service}` to specify the service for which to obtain a single
 * output — can be omitted if only one service is found in the model.
 * Alternatively specify `{service:'all'}` to request multiple outputs for
 * all services found in the model.
 *
 * @returns { '<EDM/X>' | ManyResults } a single <EDM/X> output or an iterator yielding pairs of `[ '<EDM/X>' ,{name} ]` in case of option `{service:'all'}`
 * @param {function} fn - one of `cdsc.to.edm` or `cdsc.to.edmx`
 * @param {object} csn - the CSN model to compile
 * @param {EdmOptions} [_options] - options to pass to compiler
 * @param {function} [callback] - a callback function used to transform results
 * @typedef {{ service: 'all' | '<pattern matching service name>', version: 'v2' | 'v4', format: 'flat' | 'structured' }} EdmOptions
 */
function compile2edm ( fn, csn, _options, callback = x=>x ) {

  // fetch services and fail early if none are found...
  const services = cds.reflect(csn) .all (cds.service)
  if (services.length < 1) throw new Error (
    `There are no service definitions found at all in given model(s).`
  )

  // prepare options to send in cdsc calls subsequently...
  const o = _options4odata (_options)

  // if no service requested but many found caller has to specify o.service
  if (services.length > 1 && !o.service) throw new Error (`\n
  Found multiple service definitions in given model(s).
  Please choose by adding one of... \n
    -s all ${services.map (s => `\n    -s ${s.name}`).join('')}
  `)

  // if no service requested but only one found use that one
  if (!o.service && services.length === 1) {
    o.service = services[0].name
  }

  // if a specific service is requested use the first matching one if any
  if (o.service && o.service !== 'all') {
    const re = RegExp(o.service,'i'), srv = services.find (s => s.name.match(re))
    if (!srv) throw new Error (`No service definition matching ${re} found in given model(s).`)
    o.service = srv.name
  }

  // everything's ok and prepared -> here we go...
  const ocsn = compile4odata(csn,o)  //> REVISIT: check w/ Hans-Joachim + Simon: ist das richtig so, bzgl. optimierung oder sollte man alle edmxe in einem rutsch abholen?
  if (fn.all && o.service === 'all') return _2many (fn.all (ocsn,o), callback, {})
  else return callback (fn (ocsn,o))
}


function _options4odata (options) {
  let x,o = _options (options, { ...cds.env.odata, ...cds.env.cdsc, ...options })
  if (o.version === 'x4') {
    o.odataVersion = 'v4'
    o.odataFormat = 'structured'
    o.odataContainment = true
    o.odataProxies = true
  } else {
    if ((x = o.version)) o.odataVersion = x
    if ((x = o.format)) o.odataFormat = x
    if ((x = o.containment)) o.odataContainment = x
    if ((x = o.proxies)) o.odataProxies = x
  }
  return o
}

function _options (options, o = { ...options, ...cds.env.cdsc }) {
  const names = o.names || o.sql_mapping || cds.env.sql.names
  if (names !== 'plain') o.sqlMapping = names
  if (!o.messages) o.messages = []
  return o
}


/** Adds _unfold_localized to cds.compile.to.sql */
function compile2sql (csn,o) {
  if (cds.env.features.skip_unused) {
    (compile2sql.skip_unused || (compile2sql.skip_unused = require ('../alpha/_skip_unused'))) (csn)
  }
  if (csn['_with-mocks']) {
    o = {...o, severities:{ 'to-many-no-on': 'debug' }}
  }
  const sql = cdsc.to.sql (csn,o)
  .map (each => each.replace(/^-- generated by .+\n/,'').replace(/;$/,''))   // REVISIT w/ @Simon: können wir das nach innen ziehen?
  if (cds.env.features.localized) {
    (compile2sql.unfold_ddl || (compile2sql.unfold_ddl = require ('../alpha/_localized').unfold_ddl)) (sql,csn,o)
  }
  if (o && o.as === 'str') return '\n'+ sql.join(';\n\n') +';\n'
  return sql
}


/** Returns outputs of 2edm/x, 2hana and 2hdi as an iterable
 * @returns {ManyResults} an iterator yielding pairs of `[ '<content>' ,{name} ]`
 * @typedef { Iterable<[ '<content>' , {name:string} ]> } ManyResults
 */
function* _2many (content, callback = x=>x, etc={suffix:''}) {
  for (let file in content) yield [ callback (content[file]), { file, ...etc } ]
}

/** Ensure filenames are as in old implementation */
function* _2hdbcds (content, callback = x=>x, etc={suffix:''}) {
  for (let file in content) yield [ callback (content[file]), { file: file.replace(/\./g,'_').replace(/_hdbcds$/,'.hdbcds'), ...etc } ]
}


function _2json (key,v) {
  if (!v) return v

  else if (v.grant && v.where) try {
    // Add a parsed _where clause for @restrict.{grant,where} annotations
    return {...v, _where: JSON.stringify (cds.parse.xpr(v.where)) }
  } catch(e){/* ignored */}

  else if (v.kind === "service" && !v['@source'] && v.$location && v.$location.file) {
    // Preserve original sources for services so we can use them for finding
    // sibling implementation filed when reloaded from csn.json.
    return { '@source': v.$location.file.replace(/\\/g,'/'), ...v }
  }

  return v
}


/** loads 2yaml.js lazily */
const YAML = {
  stringify: (...args) => (YAML.stringify = require('./2yaml')) (...args)
}



if (!cds.env.features.snapi) {
  const old = cds.extend (require('./compile')) .with ({ // for tests...
    old:{}, get new() { return {
      parse: require('./parse').new,
      load: require('./load').new,
      compile, unfold:compile
    }},
  })
  Object.assign (module,{exports:old})
  // eslint-disable-next-line no-console
  if (!global.it && process.env.NODE_ENV !== 'test') console.warn ('[cds] - using old compiler (!snapi)')
}
