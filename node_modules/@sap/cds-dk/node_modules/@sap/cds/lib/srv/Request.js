const Event = require('./Event')
const cds = require('..')

class Request extends Event {

  get event() {
    if (this._.method) return super.event = Http2Crud[this.method] || this.method
    if (this._.query) return super.event = Query2Crud(this._.query)
    return super.event = undefined
  }

  get method() {
    return super.method = Crud2Http[this.event] || this.event
  }

  get path() {
    const q = this.query
    return super.path = q ? _path_from (
      q.SELECT ? q.SELECT.from :
      q.INSERT ? q.INSERT.into :
      q.UPDATE ? q.UPDATE.entity :
      q.DELETE ? q.DELETE.from :
      undefined
    ) : this.entity
  }

  get target() { // IMPORTANT: this is the only place where we need access to a model; and this shall stay like that!
    const {_} = this, defs = this._model ? this._model.definitions : {}
    if (_.entity) return super.target = _.entity.name ? _.entity : _resolve(_.entity, defs)
    if (_.path) return super.target = _resolve(_.path.slice(1), defs)
    if (typeof _.query === 'object') return super.target = cds.infer(_.query, defs)
    else return super.target = undefined
  }

  get timestamp () {
    return super.timestamp = this.context && this.context.timestamp || Date.now()
  }

  get data() {
    const q = this.query
    return super.data = q && (
      q.INSERT
      ? q.INSERT.entries && (q.INSERT.entries.length > 1 ? q.INSERT.entries : q.INSERT.entries[0]) ||
        q.INSERT.rows || q.INSERT.values
      : q.UPDATE ? q.UPDATE.data || {} : {})
  }

  get user() { return super.user = new cds.User }
  set user(user) { super.user = user }

  reply (results) { return this.results = results }
  notify (...args) { return _message (args, this, 'messages', 1) }
  info   (...args) { return _message (args, this, 'messages', 2) }
  warn   (...args) { return _message (args, this, 'messages', 3) }
  error  (...args) { return _message (args, this, 'errors', 4) }
  reject (...args) {
    const e = this.error(...args)
    throw e.stack ? e : Object.assign(new Error,e)
  }

  async diff (...args) {
    if (!this.target._service) return Promise.resolve([])
    return cds.services[this.target._service.name]._calculateDiff(this, ...args)
  }

  // REVISIT: better/GA solution for subrequests structure
  _adopt (req, srv) {
    if (!this._children) this._children = new Map()
    if (!this._children.get(srv)) this._children.set(srv, [])
    this._children.get(srv).push(req)
		// REVISIT: req._model was meant to be a provate concept which should not to spread across implementations
    if (!this._model) {
      this._model = srv.model
    }

    req.context = this

    // REVISIT: remove after req.statements isn't used anymore in @sap/cds-runtime
    if (!this.statements && req.statements) this.statements = req.statements
  }

  // REVISIT: better solution for property "inheritance"
  _from (req = {}) {
    req.context && (this.context = req.context)
		// REVISIT: req._model was meant to be a provate concept which should not to spread across implementations
    req._model && (this._model = req._model)
    req.user && (this.user = req.user)
    req.run && (this.run = req.run)
    req.diff && (this.diff = req.diff)
    req._ && (this._ = Object.assign(this._, req._))

    this.info = this.info.bind(req)
    this.warn = this.warn.bind(req)

    return this
  }

}

const Crud2Http = {
  READ: 'GET',
  CREATE: 'PUT',
  UPDATE: 'PATCH',
  UPSERT: 'POST',
  DELETE: 'DELETE',
}

const Http2Crud = {
  POST: 'CREATE',
  GET: 'READ',
  PUT: 'UPDATE',
  PATCH: 'UPDATE',
  DELETE: 'DELETE',
}

const Query2Crud = (q) => {
  if (typeof q === 'string') {
    return Query2Crud({[(q.match(/^\s*(INSERT|SELECT|CREATE|UPDATE|DELETE|DROP)/) || q.match(/^\s*(\w+)/))[1]]:true})
  }
  if ('INSERT' in q) return 'CREATE'
  if ('SELECT' in q) return 'READ'
  if ('UPDATE' in q) return 'UPDATE'
  if ('DELETE' in q) return 'DELETE'
  if ('CREATE' in q) return 'CREATE ENTITY'
  if ('DROP' in q)   return 'DROP ENTITY'
}

const _message = ([ code, message, target, args ], req, kind, severity) => { // NOSONAR
  let e // be filled in below...
  if (typeof code === 'object') e = code; else {
    if (typeof code === 'number') e = { code }; else [ code, message, target, args, e ] = [ undefined, code, message, target, {} ]
    if (typeof message === 'object') e = Object.assign(message,e); else {
      if (typeof target === 'object') [ target, args ] = [ undefined, target ]
      if (message) e.message = message //; else if (code) e.message = String(code)
      if (target) e.target = target
      if (args) e.args = args
    }
  }
  if (!e.numericSeverity) e.numericSeverity = severity
  const messages = req[kind] || (req[kind] = [])
  messages.push(e)
  return e
}

const _path_from = (from) => !from || typeof from === 'string' ? from : from.ref && from.ref.map(x=>x.id||x).join('/')
const _resolve = (name, defs) => defs && defs[name] || { name, _unresolved: true }
module.exports = Object.assign(Request, { Http2Crud, Crud2Http, Query2Crud })
