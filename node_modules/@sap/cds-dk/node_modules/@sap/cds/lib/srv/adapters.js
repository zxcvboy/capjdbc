const lib = require ('@sap/cds-runtime')
const cds = require ('..')


class ProtocolAdapter {

  static at (p) {
    return registry[p] || cds.error `Service protocol ${p} is not supported`
  }


  /**
  * Constructs / returns a ProtocolAdapter for the given service and protocol.
  * The constructed adapters are cached per service, so subsequent calls
  * for same service and protocol returns the formerly constructed one.
  * @returns {ProtocolAdapter}
  */
  static serve (srv, protocol = _protocol4(srv)) {
    const cached = (srv._adapters || (srv._adapters={})) [protocol]; if (cached) return cached
    const Adapter = this.at (protocol)
    const adapter = new Adapter (srv)
    // REVISIT: -> move that into base implementations
    let {dispatch} = srv; srv.dispatch = (eve, ...etc) => {
      const req = eve._.req
      if (req) {
        Adapter.patch (eve)
        req.emit ('dispatch', eve)
      }
      return dispatch.call (srv, eve, ...etc)
    }
    cds.extend (adapter) .with (ProtocolAdapter.prototype, {service:srv})
    return srv._adapters [protocol] = adapter
  }

  static patch(){}


  /**
  * Mounts the adapter to an express app.
  */
  in (app) {
    const srv = this.service
    lib.performanceMeasurement (app)
    // audit logger to be provided here, current workaround: take it from service
    lib.passport (srv, app, srv._auditLogger, srv.options)
    // catch Fiori's lookup requests for resources in webapp and ugly warnings
    app.use (srv.path+'/webapp/', (_,res)=> res.sendStatus(404))
    // finally mount the service's protocol adaptor
    app.use (srv.path, this)
    return srv
  }

  /**
  * Returns a proxy handler function with the specified service
  * as its prototype to allow usages like this:
  *
  *    const { CatalogService } = cds.serve(...)
  *    app.use ('/cats', CatalogService)
  */
  asRouter() {
    if (!this._as_service) {
      const router = this._as_service = (...args) => this (...args)
      Object.defineProperty (router, 'name', {value: this.service.name})
      Object.setPrototypeOf (router, this.service)
    }
    return this._as_service
  }

}


class ProtocolAdapter4REST extends ProtocolAdapter {
  constructor (srv) { return lib.to.rest(srv) } // NOSONAR
  static patch (req) {
    req._path = req._.req.path
    req._query = req._.req.query
  }
}


class ProtocolAdapter4OData extends ProtocolAdapter4REST {
  constructor (srv) { return lib.to.odata_v4(srv) } // NOSONAR
  static patch (req) {
    req._path = req._.odataReq._url.pathname
    req._query = req._.odataReq._queryOptions
  }
}



const registry = {
  rest: ProtocolAdapter4REST,
  odata: ProtocolAdapter4OData,
  odata_v2: ProtocolAdapter4OData,
  odata_v4: ProtocolAdapter4OData,
  fiori: ProtocolAdapter4OData,
}


const _protocol4 = (srv) => {
  const def = srv.definition, o = srv.options
  return o.to || def && def['@protocol'] || 'odata_v4'
}

module.exports = { ProtocolAdapter }
