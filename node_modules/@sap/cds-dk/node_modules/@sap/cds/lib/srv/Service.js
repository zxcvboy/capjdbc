const cds = require('..'), { SELECT, INSERT, UPDATE, DELETE } = cds.ql
const Request = require('./Request') //, { Http2Crud } = Request

const { implicit_next } = cds.env.features

class Service {

	constructor (name, model, options={}) {
		this._handlers = { on:[], before:[], after:[], _initial:[] }
    this.name = name || new.target.name
    if (options.kind) this.kind = options.kind // shortcut
		if (model) this.model = model
    this.options = options
	}

	// Model Reflection API
	set model(m) { super.model = m && cds.linked(m) }
	get definition() { return super.definition = this.model && this.model.definitions [this.name] }
	get operations() { return super.operations = this.reflect (d => d.kind === 'action' || d.kind === 'function') }
	get entities() { return super.entities = this.reflect (d => d.kind === 'entity') }
	get events() { return super.events = this.reflect (d => d.kind === 'event') }
	get types() { return super.types = this.reflect (d => !d.kind || d.kind === 'type') }
	reflect (filter) { return !this.model ? [] : this.model.childrenOf (
		this.definition && this.definition.name || this.model.namespace || this.name, filter
	)}

	// Handler Registration API
	on     (...args) { return this.register ('on',     ...args) }
	before (...args) { return this.register ('before', ...args) }
	after  (...args) { return this.register ('after',  ...args) }
	reject (eve,e/*,m*/) { // REVISIT: what is m?
		const handler = req => req.reject(405, `Event "${req.event}" not allowed${req.target ? ` for entity "${req.target.name}"`: ''}.`)
		handler._initial = true
		return this.register ('before', eve, e, handler)
	}
	register (phase, event, path, handler) { //NOSONAR
		if (!handler) [ path, handler ] = [ '*', path ] // argument entity is optional
		if (!handler) throw new Error ('handler must not be null')
		if (event === 'SAVE') event = ['CREATE', 'UPDATE']
		if (is_array(event))  for (let each of event)  this.register (phase, each, path, handler)
		else if (is_array(path)) for (let each of path) this.register (phase, event, each, handler)
		else { // this is the basic registration case:
			if (event === 'each' || phase === 'after' && /^\(?each\)?/.test(handler)) {
				const h=handler; event = 'READ'
				handler = (rows,req) => is_array(rows) ? rows.forEach (r => h(r,req)) : rows && h (rows,req)
			}
			// else if (event in Http2Crud) event = Http2Crud[event]
			else if (event === 'SELECT') event = 'READ'
			else if (event === 'INSERT') event = 'CREATE'
			if (typeof event === 'object') { // > CSN operation
				event = /[^.]+$/.exec(event.name)[0]
			}
			if (typeof path !== 'string') {
				if (!path.name) throw new Error (`Expected a string or a CSN definition for argument 'path' but got: ${path}`)
				path = path.name
			} else if (path !== '*' && !path.startsWith(this.name+'.')) {
				// REVISIT: activate check
				// if (!this.entities[entity]) {
				// 	throw new Error(`Invalid event handler registration. Entity "${entity.split('.').pop()}" does not exist in service "${this.name}".`)
				// }
				// REVISIT: make fully qualified or adapt relevant check
				path = this.name + '.' + path
			}
			if (handler._initial) phase = '_initial'
			return this.subscribe (phase, event, path, handler)
		}
		return this
	}
	subscribe (phase, event, path, handler) {
		this._handlers[phase].push ({ event, path, handler })
		if (phase === 'on') cds.emit('subscribe',this,event)
		return this
	}

	onSucceeded (...args) { return this._on ('succeeded', ...args) }
	onFailed (...args) { return this._on ('failed', ...args) }
	_on (succeeded_or_failed, event, path, handler) {
			if (!handler) [path,handler] = [undefined,path]
			return this.before (event,path, req => req.on(succeeded_or_failed, ()=>{ handler(req) }))
	}

	async prepend (...impl_functions) {
		const {_handlers} = this, _new = this._handlers = { on:[], before:[], after:[], _initial:[] }
		await Promise.all (impl_functions.map (fn => is_impl(fn) && fn.call (this,this)))
		for (let each in _new) if (_new[each].length) _handlers[each] = [ ..._new[each], ..._handlers[each] ]
		this._handlers = _handlers
		return this
	}

	// Event Emitting & Dispatching
	async dispatch (/** @type Request */ req) { //NOSONAR
		const { on, before, after, _initial } = this._handlers, tx = this
		const relevant = ({event,path}) => ( // filter to match relevant handlers
			(event  === '*' || event  === req.event) &&
			(path === '*' || path === req.entity || path === req.path)
		)
		try {
			const _i = _initial.filter (relevant)
			if (_i.length) for (const each of _i) await each.handler.call (tx,req)
			if (req.errors) throw _error.for(req)

			const b = before.filter (relevant)
			if (b.length) await Promise.all (b.map (each => each.handler.call (tx,req)))
			if (req.errors) throw _error.for(req)

			const o = on.filter (relevant)
			if (o.length) await async function next (r=req) {
				const each = o.shift(); if (!each) return //> exit unhandled
				let x = each.handler.call (tx,r,next) //> we call handlers with this = tx = {__proto__:srv}
				if (is_query(x))     return r.reply (await (x.then ? x : (x._srv||cds).tx(r).run(x)))
				if (is_promise(x))   x = await x
				if (is_defined(x))   return r.reply(x)
				if (r.results)       return r.results
				if (implicit_next)   return next()
			}()
			else if (req.query && Object.keys(req.query).length > 0) { // > no empty object -> REVISIT: when is this the case?
				// REVISIT
				req.reject(501, `No on handler for event "${req.event}"${req.target ? ` entity "${req.target.name}"` : ''} in service "${this.name}".`)
			}
			if (req.errors) throw _error.for(req)

			const a = after.filter (relevant)
			if (a.length) await Promise.all (a.map (each => each.handler.call (tx, req.results, req)))
			if (req.errors) throw _error.for(req)

			for (let each of req.listeners('succeeded')) await each.call(req,req.results)
			return req.results
		}
		catch (e) {
			for (let each of req.listeners('failed')) await each.call(req, e)
			throw e.stack ? e : Object.assign(new Error(e.message), e) // REVISIT
		}
		finally {
			for (let each of req.listeners('done')) await each.call(req)
		}
	}

	emit (event, data) {
		const req = new Request (typeof event === 'object' ? event : { event, data })._from(this.context)
		if (this.context) this.context._adopt(req, this.__proto__)
		// REVISIT: req._model was meant to be a provate concept which should not to spread across implementations
		if (this.model && !req._model) Object.defineProperty (req,'_model',{ value: this.model })
		return this.dispatch (req)
	}

	// Transaction API
	get transaction() { return super.transaction = this.tx } //> alias
	/** @returns {this} - a derivate of `this` (i.e. {__proto__:this}) representing the current transaction for `this` within `req.context` */
	tx (r = new Request()) { // NOSONAR
		if (this._is_tx) return this
		const req = r instanceof Request ? r : new Request(r)
		const root = req.context || req //> req.context always points to root req
		if (!(r instanceof Request)) r.context = root //> add context to non cds.Request r param for joining tx later
		const txs = root.transactions || (root.transactions = new Map)
		const xt = txs.get(this); if (xt) return xt		// join existing tx

		// construct a new tx as a derived srv instance
		// (Note: using separate const tx variable by intent -> pls keep)
		const tx = {__proto__:this,	_is_tx:true, context:root,
			once: (e,h) => root.once(e,h),
			on: (e,h) => root.on(e,h),

			// REVISIT
			_terminate: async function (event) {
				try {
					for (let each of root.listeners(event)) await each.call(root)
				} catch (e) {
					if (event !== 'failed') {
						try {
							for (let each of root.listeners('failed')) await each.call(root, e)
						} catch (e1) {
							// > rollback failed... REVISIT: what to do?
						}
					} else {
						// > rollback failed... REVISIT: what to do?
					}
					// REVISIT: pass error up?!
					throw e
				} finally {
					for (let each of root.listeners('done')) await each.call(root)
				}
			},

			commit: function () {
				if ('commit' in this.__proto__) this.commit = this.__proto__.commit
				else this.commit = _no_op
				return this._terminate('succeeded')
			},
			rollback: function () {
				if ('rollback' in this.__proto__) this.rollback = this.__proto__.rollback
				else this.rollback = _no_op
				return this._terminate('failed')
			}
		}

		// REVSIIT: for triggering commit/rollback in protocol adapter
		root._commit = root._commit || tx.commit.bind(tx)
		root._rollback = root._rollback || tx.rollback.bind(tx)

		// convenience interface to subclasses implementing begin/end/commit/rollback
		if ('begin' in this) { // queue all further ops behind an initial .begin()
			// REVISIT: move to first non.read db interaction?
			// REVISIT: ready = tx.begin() -> promise must be awaited -> this._busy === true if commit/rollback w/o any runs (cf. cds-runtime/lib/db/Service.js)
			const ready = tx.begin()
			tx.dispatch = async req => {
				await ready
				return (tx.dispatch = this.dispatch) .call (tx,req)
			}
		}
		if ('rollback' in this) tx.once ('failed', ()=> tx.rollback())
		if ('commit' in this) tx.once ('succeeded', ()=> tx.commit())
		if ('end' in this) tx.once ('done', ()=> tx.end())

		// REVISIT: compat for continue with tx
		tx._state = 'new'

		// register and return new tx
		txs.set (this,tx)
		return tx
	}

	// Querying API
	async run (query, data) {
		let tx, terminate, res
		tx = this._is_tx ? this : cds.local.req ? this.tx(cds.local.req) : (terminate = true) && this.tx()
		try {
			if (is_array(query)) {
				res = await Promise.all (query.map (q => tx.run(q)))
			} else {
				res = await tx.emit ({ query, data })
			}
		} catch(e) {
			terminate && await tx._terminate('failed')
			throw e
		}
		terminate && await tx._terminate('succeeded')
		return res
	}
	foreach (query, data, callback) {
		if (!callback)  [ data, callback ] = [ undefined, data ]
		return this.run (query, data) .then (rows => rows.forEach(callback) || rows)
	}
	insert (...args) { ensure_target(args, this); return this.query(INSERT(...args)) }
	create (...args) { ensure_target(args, this); return this.query(INSERT.into(...args)) }
	read   (...args) { ensure_target(args, this); return this.query(SELECT.from(...args)) }
	update (...args) { ensure_target(args, this); return this.query(UPDATE.entity(...args)) }
	delete (...args) { ensure_target(args, this); return is_rest(args[0]) ? this.send('DELETE',...args) : this.query(DELETE.from(...args)) }
	query  (q) { return Object.defineProperty (q,'_srv',{value:this}) }

	// REST-style API
	send  (method, path, data) { return this.emit ({ method, path, data }) }
	get   (path, data) { return is_rest(path) ? this.send('GET',  path,data) : this.read   (path, data) }
	put   (path, data) { return is_rest(path) ? this.send('PUT',  path,data) : this.update (path, data) }
	post  (path, data) { return is_rest(path) ? this.send('POST', path,data) : this.create (path, data) }
	patch (path, data) { return is_rest(path) ? this.send('PATCH',path,data) : this.update (path, data) }

	/** Subclasses can override to free resources */
	disconnect (tenant) { // eslint-disable-line no-unused-vars
		if (this === cds.db) cds.db = undefined
		delete cds.services[this.name]
	}
}

const is_array = Array.isArray
const is_query = x => x && (x.SELECT || x.INSERT || x.UPDATE || x.DELETE)
const is_promise = x => x && x.then
const is_defined = x => x !== undefined

// REVISIT
const ensure_target = (args, srv) => args[0] = args[0].name ? args[0] : srv.entities && srv.entities[args[0]] || args[0]

const is_rest = x => x && typeof x === 'string' && x[0] === '/'
const is_impl = x => typeof x === 'function' && !is_class(x)
const is_class = x => typeof x === 'function' && x.prototype && /^class\b/.test(x)

const _error = {
	for: req => {
		const e = req.errors.length === 1 ? req.errors[0] : { message: 'MULTIPLE_ERRORS', details: req.errors }

		// REVISIT: OKRA expects a stack
		e.stack = e.stack || 'not available'

		return e
	}
}

const _no_op = () => {}

Service._is_service_class = Service.prototype._is_service_instance = true //> for factory
module.exports = Service
