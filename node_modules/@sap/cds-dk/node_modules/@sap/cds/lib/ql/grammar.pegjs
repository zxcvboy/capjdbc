// TEST = o x:column o {return x}

//--------------------------------------------------------------------------
// Queries


  columns
    = cols:(c:column {return[c]}) tail:(comma c:column {cols.push(c)})*
    {return cols}

	column
    = "*" / ref:path ".*" {return { ref, inline:['*'] }}
      / x:(cast / expr) ((_"as"i_/_) a:name {x.as=a})? {return x}

  cast
    = "CAST"i LEFT x:expr _"AS"i_ t:xref RIGHT
      {return {xpr:['cast','(',x,'as',t,')']} }

  obyx  = x:expr
    (_ ad:("ASC"i / "DESC"i) {x.sort=ad.toLowerCase()} )?
    (_"NULLS"i_ fl:("FIRST"i / "LAST"i) {x.nulls=fl.toLowerCase()} )?
    {return x}

	alias "" = (_"as"i_/_) n:name {return n}


//--------------------------------------------------------------------------
// Expressions

  expr  // returns one of {val:...}, {ref:...} or {xpr:...}
    = xpr:_xpr { return xpr.length==1 ? xpr[0] : {xpr} }

    _xpr  //> internal rule to construct expressions as an array of operators and operands
      = CASE / LEFT _xpr:_xpr RIGHT {return ['(', ..._xpr, ')'] }
      / o:unary_operator o a:_xpr {return [o,...a]}
      / a:operand o"?:"o b:expr {return [{ func:'coalesce', args: [a,b] }]}
      / a:operand o"?"o b:expr o":"o c:expr {return [ 'case', 'when', a, 'then', b, 'else', c, 'end' ]}
      / a:operand o op:binary_operator o b:_xpr {return [a,op,...b]}
      / a:operand {return [a]}

  operand
    = LEFT list:(x:expr {return ['(',x]}) (comma x:expr {list.push(',',x)})* RIGHT
    { list.push(')'); return list}
    / "?" {return {ref:['?'], param:true}}
    / ':' p:(name/anInteger) {return {ref:[p],param:true}}
    / null {return 'null'}
    / up:unparsed {return {xpr:[up]}}
    / func:qname args:args {return {func,args}}
    / ref:path {return {ref}}
    / val:Literal {return {val}}

  unary_operator "an operator"
    = "-" !aNumber
    / "+" !aNumber
    / "~"
    / "!"i {return 'not'}
    / "NOT"i !alpha {return 'not'}
    / "EXISTS"i !alpha {return 'exists'}

  binary_operator "an operator"
    = arithmetic_operator
    / comparison_operator
    / logic_operator
    / !"as"i n:name {return n}

  arithmetic_operator "an operator"
    = "||"
    / "&&"
    / "+="
    / "-="
    / [*/%+-]

  comparison_operator "an operator" =
    "==" / "=" / "!=" / "<>" / "<=" / ">=" / "<" / ">"
    / o:( "eq"i/"ne"i/"lt"i/"gt"i/"le"i/"ge"i )!alpha {return o}
    / o:( "IS NOT"i/"NOT IN"i )!alpha {return o}
    / o:( "IS"i/"IN"i )!alpha {return o}
    / o:( "BETWEEN"i / "LIKE"i / "GLOB"i / "MATCH"i / "REGEXP"i )!alpha {return o}

  logic_operator "an operator"
    = "AND"i !alpha {return 'and'}
    / "OR"i !alpha {return 'or'}

  CASE = o _xpr:("CASE"i !alpha {return ['case']})
    (_"WHEN"i_ w:expr _"THEN"i_ t:expr { _xpr.push ('when',w, 'then',t) })+
    (_"ELSE"i_ e:expr { _xpr.push ('else',e) })?
    _"END"i !alpha  { _xpr.push('end'); return _xpr}

  // maybe_operator "an operator" = o op:$[:!|&~\?^]+ o {return op}


//--------------------------------------------------------------------------
// Path Expressions

	path "a path expression"
    = p:( head:pseg {return [head]} )
    ( dot tail:pseg {p.push(tail)} )* {return p}

	pseg
    = id:name filter:filter?
    {return !filter ? id : {id, ...filter} }

	filter
    = BLEFT one:("1:")? o where:( expr / "*" )? BRIGHT
    {let f={where}; if(one) f.cardinality={max:1}; return f}

  args
    = LEFT a:( '*'{return['*']} / named_args / positional_args / ""{return[]} ) RIGHT
    {return a}

  named_args
    = args:(n:name colon v:_xpr {return {[n]:v}})
    ( comma n:name colon v:_xpr {args[n]=v} )*
    {return args}

  positional_args
    = head:expr tail:(comma x:expr {return x})*
    {return [head, ...tail]}

  //


//--------------------------------------------------------------------------
// Names and References

  xref "a reference"   //> to other definitions -> 2b resolved to fqns
    =  c:":"? r:qname
    {return c?c+r:r}

  eref "a reference"  //> to elements with optional target prefix
    = r:(qname ":")? e:qname
    {return r ? r[0] : e}


  name "a name" = $(![0-9]alpha+) / quoted
	qname "a name" = q:qualified id:name { return q+id }
	qualified = all:( id:name dot { return id+'.' })* {return all.join('')}
  quoted = '"' i:$('""'/[^"])+ '"' { return i.replace(/""/g,'"') }
  alpha = [_$A-Za-z0-9]


//--------------------------------------------------------------------------
// Literals

  Literal
    = anArray
    / aScalar

  aScalar "a literal"
    = aSymbol
    / aNumber
    / aString
    / aDate
    / true
    / false
    / null

  anArray
    = a:BLEFT
    (x:(Literal/anExpression) comma {a.push(x)})*
    (x:(Literal/anExpression) {a.push(x)})?  //last
    BRIGHT {return a}

  aSymbol // an enum symbol
    = "#" s:name
    {return{'#':s}}

  aDate
    = $(("datetime"/"timestamp"/"date"/"time") aString)

  aString
    = ['] s:$("''"/[^'])* [']
    {return s.replace(/''/g,"'")}

  aNumber
    = x:$([-]?[0-9]+("."[0-9]+)?("e"[0-9]+)? )
    { return parseFloat(x) }

  anInteger
    = x:$([-]?[0-9]+ )
    {return parseInt(x)}

	anExpression
    = x:unparsed {return {'=':x}}
    / r:$(qname('@'qname('#'qname+)?)?) {return{'=':r}}


  null  =  "null"i !alpha {return null}
  true  =  "true"i !alpha {return true}
  false = "false"i !alpha {return false}
  unparsed "(...)"  = "#(" u:$( unparsed / (![()] .)+ )* ")"o {return u}
  //> reads arbitrary input between balenced parenthesis


//--------------------------------------------------------------------------
// Punctuation

  LEFT "(" = o"("o {return "("}
  RIGHT ")" = o")" {return ")"}
  BLEFT "[" = o"["o {return[/* can be filled in subsequently*/]}
  BRIGHT "]" = o"]" {return}
  colon "a colon" = o":"o {return ":"}
  comma "a comma" = o","o {return ","}
  dot "" = o"."o {return "."}
  eq "=" = o"="o {return "="}


//--------------------------------------------------------------------------
// Whitespaces and Comments

  _ "" = [ \t\n]+
  o "" = [ \t\n]*

//--------------------------------------------------------------------------
