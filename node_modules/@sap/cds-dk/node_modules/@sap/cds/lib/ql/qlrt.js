/* eslint-disable no-inner-declarations */
const cds = require('..')
const lib = require ('@sap/cds-runtime')
const { inspect } = require('util')
const { extend } = cds

const { BaseStatement } = lib.statements

const Query = extend(BaseStatement).with(
  class Query extends BaseStatement {

    static new (_context) {
      const q = new this, cmd = this.name.toUpperCase() // NOSONAR
      if (_context) q._context = _context
      return Object.defineProperties (q, {_:{value:q[cmd]}, cmd:{value:cmd}})
    }

    /** Turns all queries into Thenables which execute with primary db by default */
    then (r,e) {
      if (this._promised) return this._promised.then(r,e)
      const srv = this._srv || this._target._service && cds.services[this._target._service.name] || cds.db
      const tx = srv._is_tx ? srv : this._context ? srv.tx(this._context) : srv
      return this._promised = tx.run(this).then(r,e)
    }

    set _promised(v) { Object.defineProperty (this, '_promised', {value:v}) }
    set _service(v) { Object.defineProperty (this, '_service', {value:v}) }
    set _context(v) { Object.defineProperty (this, '_context', {value:v}) }
    // FIXME: Ugly legacy API which should never have been added
    withRequest(req) { this._context = req; return this }

    /** Beautifies output in REPL */
    [inspect.custom]() {
      const colors = process.env.CDS_TERM_COLORS !== false
      const cmd = this.cmd
      return (
        `{ ${cmd}: ` +
        inspect(this[cmd], { colors, depth: 22 })
          .replace(/^\w*\s/, '')
          .replace(
            /{ ref: \[([^\]]*)\] }/g,
            (_, ref) => '{ref:[' + ref.slice(1, -1) + ']}'
          )
          .replace(/{ val: ([^ ]*) }/g, '{val:$1}')
          .replace(/{ (xpr|ref|val): /g, '{$1:') +
        '}'
      )
    }

    target(e) { //NOSONAR
      const t = (
        !e ? cds.error(`Expected a query target but received ${e}`) :
        typeof e === 'string' ? { name: e } :
        e.name ? e : //> assumed to be a linked csn definition
        e.ref ? { name: e.ref[0] } :
        e._entityName ? { __proto__: e, name: e._entityName } :
        e._target || { name: undefined }
      )
      Object.defineProperty (this, '_target', { value:t, configurable:true })
      return t
    }

    byKey(key) {
      if (this.SELECT) this.SELECT.one = true
      if (typeof key !== 'object') {
        const e = this._target
        const ID = e.keys ? Object.keys(e.keys)[0] : 'ID'
        key = { [ID]: key }
      }
      return this.where(key)
    }

    clone() {
      const q = this.constructor.new (this._context)
      if (this._srv) Object.defineProperty (q,'_srv',{value:this._srv})
      Object.assign (q._, this._)
      return q
    }

    static factory(fn, _context) { // NOSONAR
      const factory = (e, ...etc) => {
        // NOTE: DO NOT add || entity.name, as ql.BaseStatement impl does something special for views
        const q = fn(e._entityName || e, ...etc)
        q.target(e)
        return q
      }
      return !_context ? factory
        : (..._) => {
            return Object.defineProperty(factory(..._), '_context', { value: _context })
          }
    }
  }
)

const Select = lib.statements.SELECT.from('x').constructor
const Insert = lib.statements.INSERT.into('x').constructor
const Update = lib.statements.UPDATE('x').constructor
const Delete = lib.statements.DELETE.from('x').constructor

const select_columns = Select.prototype.columns
const select_limit = Select.prototype.limit
const update_set = Update.prototype.set


class SELECT extends Select {

  static from(..._) { return this.new().from(..._) }
  static in(c) {
    return $((..._) => this.new(c).columns(..._), {
      distinct: $((...x) => $(this.new(c).distinct.from(...x), {
        from: (..._) => this.new(c).distinct.from(..._).columns(...x)
      }),{ from: (..._) => this.new(c).distinct.from(..._) }),
      one: $((...x) => $(this.new(c).one.from(...x), {
        from: (..._) => this.new(c).one.from(..._).columns(...x)
      }),{ from: (..._) => this.new(c).one.from(..._) }),
      from: (..._) => this.new(c).from(..._),
    })
  }

  from (entity, second, third) {
    this.target(entity)
    this._parseEntity(entity)
    if (second) {
      if (is_projection(second)) return this.columns(second)
      else this.byKey(second)
      if (third) this.columns(third)
    } else {
      this._parseColumns (undefined,entity) // REVISIT: compatibility with overly eager implementation in cds-runtime
    }
    return this
  }

  limit (rows,offset) {
    if (!rows) return this
    if (typeof rows === 'object') this._.limit = rows
    else select_limit.call(this,rows,offset)
    return this
  }

  get distinct() {
    this._.distinct = true
    return this
  }
  get one() {
    this._.one = true
    return this
  }

  /** Allows to redirect queries
   * @example
   * req.query.redirectTo ('OtherEntity')
   */
  redirectTo(entity) {
    return this.clone().from(entity)
  }

  /** @example
   * SELECT.from('Foo') .columns ((foo)=>{...})
   */
  columns(cols, ...more) {
    if (!this._.from) {
      this.from = (..._) => {
        delete this.from
        return this.from(..._).columns(cols,...more)
      }
      return this
    }
    if (!cols) return this
    if (is_function(cols)) cols = _projection4(cols, this.entity)
    if (is_array(cols)) return select_columns.call(this, ...cols)
    else return select_columns.call(this, cols, ...more)
  }

  /** @example
   * SELECT.from(...).expand(...)
   */
  expand(ref, cols, exp = 'expand') {
    const { SELECT } = this,
      columns = SELECT.columns || (SELECT.columns = [])
    const col = { ref: ref.split('.'), [exp]: cols ? _projection4(cols) : ['*'] }
    columns.push(col)
    return this
  }

  /** @example
   * SELECT.from(...).inline(...)
   */
  inline(ref, cols) {
    return this.expand(ref, cols, 'inline')
  }

  /** @example
   * SELECT.from(...).foreach(...)
   */
  foreach(callback) {
    return this.then((rows) => rows.map(callback))
  }
}

class INSERT extends Insert {

  static in(c) {
    return $((..._) => this.new(c).entries(..._), {
      into: (..._) => this.new(c).into(..._),
    })
  }

  into(entity, data) {
    this._.into = Insert._isEntity (this.target(entity), 'INSERT.into()')
    if (data) this.entries(data)
    return this
  }
}

class UPDATE extends Update {

  static in(c) {
    return $((..._) => this.new(c).entity(..._), {
      entity: (..._) => this.new(c).entity(..._),
    })
  }

  entity(e, key) {
    this._.entity = Update._isEntity(this.target(e), 'UPDATE()')
    if (key) this.byKey(key)
    return this
  }

  /** Add support for UPDATE('Foo').set ( expr | fragments | feather ) */
  with(...args) {
    return this.set(...args)
  }
  set(...args) { // NOSONAR
    if (typeof args[0] === 'object') return update_set.call(this, ...args)
    let _d; const d = {}
    let _w; const w = {}
    const cqn = this._.with = {}
    if (args.length === 1)
      for (let each of _data(args[0])) {
        const { xpr: [lhs, op, ...rhs] } = cds.parse.expr(each)
        _add (lhs.ref.join('.'), lhs, op, ...rhs)
      }
    else
      for (let i = 0; i < args.length; ++i) {
        const [, col, op] = /\s*([\w.]+)\s*([%*+-]?=)/.exec(args[i])
        _add (col, {ref:[col]}, op, { val: args[++i] })
      }
    function _add (col, lhs, op, ...rhs) {
      const v = (
        op === '=' ? (rhs.length === 1 ? rhs[0] : { xpr: rhs }) :
        op.length === 2 && op[1] === '=' ? { xpr: [ lhs, op[0], ...rhs] } :
        cds.errror('Invalid operator in UPDATE(...).set() expression: ' + op)
      )
      if (v.val) (_d=d)[col] = v.val
      else (_w=w)[col] = v
    }
    if (_w) this._.with = w
    if (_d) this._.data = d
    return this
  }
}

class DELETE extends Delete {
  static in(c) {
    return $((..._) => this.new(c).from(..._), {
      from: (..._) => this.new(c).from(..._),
    })
  }

  from(entity, key) {
    this._.from = Delete._isEntity(this.target(entity), 'DELETE.from()')
    if (key) this.byKey(key)
    return this
  }
}

extend(Select).with(SELECT)
extend(Insert).with(INSERT)
extend(Update).with(UPDATE)
extend(Delete).with(DELETE)

function _data(s) { // NOSONAR
  let all = [],
    start = 0,
    scope = 0,
    close = 0,
    stack = [close]
  for (let i = 0; i < s.length; ++i) {
    const c = s[i]
    if (c === ',' && !scope) {
      all.push(s.slice(start, i))
      start = i + 1
    } else if (c === "'") {
      while (i < s.length) {
        if (s[++i] === "'") {
          if (s[i + 1] === "'") ++i // NOSONAR
          else break
        }
      }
    } else if (c === '(') {
      scope++
      stack.unshift((close = ')'))
    } else if (c === '[') {
      scope++
      stack.unshift((close = ']'))
    } else if (c === '{') {
      scope++
      stack.unshift((close = '}'))
    } else if (c === close) {
      scope--
      stack.shift()
      close = stack[0]
    }
  }
  all.push(s.slice(start))
  return all
}

/* eslint no-unused-vars: off */
function _projection4(x, entity) { // NOSONAR
  if (!x || x === '*') return ['*']
  if (is_projection(x[0])) x = x[0]
  if (is_array(x)) return x.map((c) => (c.ref ? c : { ref: c.split('.') }))
  if (typeof x === 'function') {
    const columns = []
    x(
      new Proxy(x, {
        // handle top-level projections or subselects such as
        // (foo)=>{ foo('*'), foo(SELECT...).as('bar') }
        apply: (_, __, [x]) => {
          columns.push(x)
          return { as: (alias) => (x.as = alias) }
        },
        // handle top-level paths like (foo)=>{ foo.bar }
        get: (_, p) => {
          const col = { ref: [p] }
          columns.push(col)
          const nested = new Proxy(x, {
            // handle n-fold paths like (foo)=>{ foo.bar.car }
            get: (_, p) => {
              if (p === 'where') return (x) => ((col.where = _predicate4(x)), nested)
              if (p === 'as') return (alias) => ((col.as = alias), nested)
              else col.ref.push(p)
              return nested
            },
            // handle nested projections e.g. (foo)=>{ foo.bar (b=>{ ... }) }
            apply: (_, __, args) => {
              const [a, b] = args
              if (!a) col.expand = ['*']
              else if (a === '*') col.expand = ['*']
              else if (a === '.*') col.inline = ['*']
              else {
                let x = (col[/^\(?_\b/.test(a) ? 'inline' : 'expand'] = _projection4(args))
                if (b && b.levels)
                  while (--b.levels) x.push({ ...col, expand: (x = [...x]) })
              }
              return nested
            },
          })
          return nested
        },
      })
    )
    return columns
  }
  else throw new Error('SELECT w/ invalid projection argument: ' + JSON.stringify(x))
}

/**
 * Helper to create a predicate from a feather object
 */
function _predicate4(o) {
  const predicates = []
  for (let each in o) {
    predicates.push('and', { ref: each.split('.') }, '=', { val: o[each] })
  }
  return predicates.slice(1)
}

function disable_cds_run() {
  if (disable_cds_run.once || cds.env.singletenant) return
  else disable_cds_run.once = true
  const disabled = () => {
    throw new Error(`
    Shortcut srv.run() is only available in plain node programs and disabled
    when running services. Always run queries like that in event handlers:
     srv.on('READ','Foo', (req)=>{
        const tx = cds.transaction(req)
        tx.run (SELECT.from('Foo'))
     }
    `)
  }
  Object.defineProperty(lib.Service.prototype, 'run', { value: disabled })
}
disable_cds_run.once = true //> REVISIT: switching that off for the time being

const $ = Object.assign
const is_array = Array.isArray
const is_object = (x) => typeof x === 'object' && !is_array(x)
const is_function = (x) => typeof x === 'function'
const is_projection = (x) => typeof x === 'function' || is_array(x)

const cds_ql = (_context) => ({
  get SELECT() { return SELECT.in(_context) },
  get INSERT() { return INSERT.in(_context) },
  get UPDATE() { return UPDATE.in(_context) },
  get DELETE() { return DELETE.in(_context) },
})

module.exports = Object.assign (cds_ql, lib.statements, cds_ql(), {
  connect: (...args) => new lib.Service(...args), // FIXME: for compatibility to double-services messaging implementation only
  disable_cds_run,
  Query,
})
