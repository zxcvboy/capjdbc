class Query {
  constructor(_ = {}) {
    set(this, '_', (this[this.cmd] = _))
  }
  get cmd() {
    return this.constructor.name
  }
  target (e) {
    return set(this, '_target', e.name ? e : e._target || { name: e })._target
  }
  then (r,e) {
    const srv = this._srv || global.cds.db
    return srv.run(this).then(r,e)
  }
  foreach(cb) {
    return this.then((rows) => {
      for (let r of rows) cb(r)
      return rows
    })
  }
  clone() {
    return new this.constructor({ ...this._ })
  }
  valueOf(preamble = 'Query on') {
    return preamble + ' ' + this._target.name.replace(/[.:]/g, '_') + ' '
  }
}

class Whereable extends Query {
  where(...x) {
    const pred = _where(x)
    if (pred.length > 0)
      this._.where = !this._.where ? pred : ['(', ...this._.where, ')', 'and', ...pred]
    return this
  }
  and(...x) {
    this._.where = [...this._.where, 'and', ..._where(x)]
    return this
  }
  or(...x) {
    this._.where = [...this._.where, 'or', ..._where(x)]
    return this
  }
  byKey(ID) {
    if (this.SELECT) this._.one = true
    return this.where(typeof ID === 'object' ? ID : { ID })
  }
}

const _where = (args) => {
  if (is_array(args[0])) return args[0]
  if (is_xpr(args)) return args
  if (is_object(args)) return _where_object(args)
  else return _where_fluid(args)
}

// .where ('ID=',4711, 'and stock >=',1)
const _where_fluid = (args) => {
  // 1. construct a full expr string with ? for values collected in vals
  let expr = args.filter((_, i) => i % 2 === 0).join(' ? ')
  let vals = args.filter((_, i) => i % 2 === 1)
  if (args.length % 2 === 0) expr += ' ?'
  // 2. parse the expr string -> returns cxn ...
  let {xpr} = parse.expr(expr), flat=[]
  // 3. and replace {params} in there with collected vals
  for (let x of xpr) {
    const v = x.param ? val(vals.shift()) : x
    is_array(v) ? flat.push(...v) : flat.push(v)
  }
  return flat
}

// .where ({ID:4711, stock: {'>=':1})
const _where_object = ([arg]) => {
  const pred = []
  for (let k in arg) {
    const x = arg[k]
    if (k === 'and') {
      let p2 = _where([x])
      if (x.or) p2 = ['(',...p2,')']
      pred.push('and', ...p2)
      continue
    }
    if (k === 'or') {
      pred.push('or', ..._where([x]))
      continue
    } else pred.push('and', parse.expr(k))
    // if (x === null || x === undefined) pred.push('is null')
    if (!x) pred.push('=', { val: x })
    else if (is_array(x)) pred.push('in', { val: x })
    else if (x.SELECT) pred.push('in', x)
    else if (x.ref || x.val || x.xpr) pred.push('=', x)
    else if (x instanceof RegExp) pred.push('like', { val: x })
    else if (typeof x === 'object') for (let op in x) pred.push(op, { val: x[op] })
    else pred.push('=', { val: x })
  }
  return pred.slice(1)
}

const parser = require('./parser')
const parse = {
  columns:(x) => simple(x) || parser.parse(x,{startRule:'columns'}),
  column:(x) => simple(x) || parser.parse(x,{startRule:'column'}),
  expr:(x) => simple(x) || parser.parse(x,{startRule:'expr'}),
}

const simple = (x) => {
  if (typeof x !== 'string') return {val:x}
  const t = /^\s*([\w.'?]+)(?:\s*([!?\\/:=\-+<~>]+|like)\s*([\w.'?]+))?\s*$/.exec(x); if (!t) return
  const [,ref,op,rhs] = t
  return op ? {xpr:[rv(ref),op,rv(rhs)]} : rv(ref)
}

const rv = (x) => {
  if (x[0] === '?') return { param: true, ref: x }
  if (x[0] === "'") return { val: x.slice(1, -1).replace(/''/g, "'") }
  if (x === 'null') return { val: null }
  if (x === 'true') return { val: true }
  if (x === 'false') return { val: false }
  if (!isNaN(x)) return { val: Number(x) }
  else return { ref: x.split('.') }
}

const val = (x) => {
  if (x === undefined || x.xpr || x.ref || x.val || x.func || x.SELECT) return x
  if (is_array(x)) {
    const xpr = []
    for (let each of x) xpr.push(',',rv(each))
    xpr[0]='('; xpr.push (')')
    return xpr
  }
  return {val:x}
}

const set = (o, p, value) => Object.defineProperty(o, p, { value, configurable: true })
const is_object = (args) => args.length === 1 && typeof args[0] === 'object'
const is_xpr = (x) => x.length === 1 && (is_array(x[0]) || x[0].xpr || x[0].ref || x[0].val || x[0].func || x[0].SELECT)
const is_array = Array.isArray

module.exports = { Query, Whereable, _where, parse }
