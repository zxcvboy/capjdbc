const { Whereable, parse } = require('./Whereable')
const is_array = Array.isArray
const $ = Object.assign

module.exports = class UPDATE extends Whereable {
  static get _() {
    return $((..._) => new this().entity(..._), {
      entity: (..._) => new this().entity(..._),
    })
  }

  entity(e, key) {
    this._.entity = this.target(e).name
    if (key) this.byKey(key)
    return this
  }

  with(...args) {
    this._.with = (is_object(args) ? _with_object : _with_fluid)(args)
    return this
  }

  data(data) {
    this._.data = data
    return this
  }

  get _set() {
    //> .set is an alias to .with
    return this.with
  }

  valueOf() {
    return super.valueOf('UPDATE')
  }
}

// .with ({ stock:{'-=':1}, lastOrder:{'=':'$now'} })
const _with_object = ([arg]) => {
  const _set = {}
  for (let lhs in arg) {
    let rhs = arg[lhs]
    if (typeof rhs === 'object' && !is_array(rhs))
      for (let op in rhs) _set[lhs] = _value(lhs, op, rhs[op])
    else _set[lhs] = _value(lhs, '=', rhs)
  }
  return _set
}

// .with ('my.stock -=',1, 'lastOrder =', '$now')
const _with_fluid = (args) => {
  const _set = {}
  for (let i = 0; i < args.length; ++i) {
    const [, lhs, op] = /\s*([\w.]+)\s*(=|-=|\+=)/i.exec(args[i])
    _set[lhs] = _value(lhs, op, args[++i])
  }
  return _set
}

const _value = (lhs, op, rhs) => {
  if (op === '-=') return { xpr: [parse.expr(lhs), '-', parse.expr(rhs)] }
  if (op === '+=') return { xpr: [parse.expr(lhs), '+', parse.expr(rhs)] }
  else return parse.expr(rhs) || {val:rhs}
}

const is_object = (args) => args.length === 1 && typeof args[0] === 'object'
