const { Whereable, _where, parse } = require('./Whereable')
const $ = Object.assign

module.exports = class SELECT extends Whereable {
  static get _() {
    return $((..._) => new this().columns(..._), {
      distinct: $((...x) => $(new this().distinct.from(...x), {
        from: (..._) => new this().distinct.from(..._).columns(...x)
      }),{ from: (..._) => new this().distinct.from(..._) }),
      one: $((...x) => $(new this().one.from(...x), {
        from: (..._) => new this().one.from(..._).columns(...x)
      }),{ from: (..._) => new this().one.from(..._) }),
      from: (..._) => new this().from(..._),
    })
  }

  get distinct() {
    this._.distinct = true
    return this
  }
  get one() {
    this._.one = true
    return this
  }

  from(entity, second, third) {
    this._.from = { ref: [this.target(entity).name] }
    if (is_projection(second)) this.columns(second)
    else if (second) {
      if (second) this.byKey(second)
      if (third) this.columns(third)
    }
    return this
  }

  columns(...x) {
    const p = projection(x)
    this._.columns = this._.columns ? this._.columns.concat(p) : p
    return this
  }

  expand(ref, x, _kind = 'expand') {
    const cols = this._.columns || (this._.columns = [])
    cols.push({ ref: ref.split('.'), [_kind]: projection(x) })
    return this
  }

  inline(ref, cols) {
    return this.expand(ref, cols, 'inline')
  }

  excluding(...x) {
    this._.excluding = x
    return this
  }

  groupBy(...x) {
    this._.groupBy = x.map((x) => parse.expr(x))
    return this
  }

  having(...x) {
    this._.having = _where(x)
    return this
  }

  orderBy(...x) {
    this._.orderBy = order_by(x)
    return this
  }

  limit(rows, offset) {
    const _ = this._.limit = { rows:{val:rows} }
    if (offset) _.offset = {val:offset}
    return this
  }

  redirectedTo(entity) {
    return this.clone().from(entity)
  }

  foreach(callback) {
    return this.then((rows) => rows.map(callback))
  }

  valueOf() {
    return super.valueOf('SELECT * FROM')
  }
}

const is_projection = (x) => typeof x === 'function' || is_array(x)
const column_expr = (x) => {
  if (x === '*' || x === undefined || x.xpr || x.ref || x.val || x.func || x.SELECT) return x
  if (typeof x === 'object') for (let one in x) {
    const r = parse.expr(one); r.as = x[one]
    return r
  }
  return typeof x === 'string' ? parse.column(x) : {val:x}
}

const projection = (x) => {
  if (is_projection(x[0])) x = x[0]
  if (!x || x === '*') return ['*']
  if (is_array(x)) return x.map(column_expr)
  if (typeof x === 'function') {
    const columns = []
    x(
      new Proxy(x, {
        // handle top-level projections or subselects such as
        // (foo)=>{ foo('*'), foo(SELECT...).as('bar') }
        apply: (_, __, [x]) => {
          columns.push(x)
          return { as: (alias) => (x.as = alias) }
        },
        // handle top-level paths like (foo)=>{ foo.bar }
        get: (_, p) => {
          const col = { ref: [p] }
          columns.push(col)
          const nested = new Proxy(x, {
            // handle n-fold paths like (foo)=>{ foo.bar.car }
            get: (_, p) => {
              if (p === 'where') return (x) => ((col.where = _where(x)), nested)
              if (p === 'as') return (alias) => ((col.as = alias), nested)
              else col.ref.push(p)
              return nested
            },
            // handle nested projections e.g. (foo)=>{ foo.bar (b=>{ ... }) }
            apply: (_, __, args) => {
              const [a, b] = args
              if (!a) col.expand = ['*']
              else if (a === '*') col.expand = ['*']
              else if (a === '.*') col.inline = ['*']
              else {
                let x = (col[/^\(?_\b/.test(a) ? 'inline' : 'expand'] = projection(args))
                if (b && b.levels)
                  while (--b.levels) x.push({ ...col, expand: (x = [...x]) })
              }
              return nested
            },
          })
          return nested
        },
      })
    )
    return columns
  }
}

const order_by = (args) => (is_object(args) ? _order_by_object : _order_by_fluid)(args)

// e.g. .orderBy ({ x:'asc', y:'desc', y:-1 })
const _order_by_object = ([arg]) => {
  const all = []
  for (let each in arg) {
    const order = parse.expr(each)
    all.push(order)
    const ad = arg[each]
    order[ad === 1 ? 'asc' : ad === -1 ? 'desc' : ad] = true
  }
  return all
}

// e.g. .orderBy ('x asc','y desc')
const _order_by_fluid = (args) => {
  const all = []
  for (let each of args) {
    const order = parse.expr(each)
    all.push(order)
    if (each.endsWith(' asc')) order.asc = true
    if (each.endsWith(' desc')) order.desc = true
  }
  return all
}

const is_object = (args) => args.length === 1 && typeof args[0] === 'object'
const is_array = Array.isArray
