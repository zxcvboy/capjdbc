const cds = require('..')
const cwd = process.cwd()
const DEBUG = cds.debug('deploy')

/**
 * Implementation of `cds.deploy` common to all databases.
 * It uses the database-specific `db.deploy` to prepare the database, e.g.
 * deploy create tables and views in case of a SQL database, then fills
 * in initial data, if present.
 */
exports = module.exports = function cds_deploy (model,options) { return {
  async to (db,o=options) { // NOSONAR

    if (model && !model.definitions)  model = await cds.load (model)
    if (o && o.mocked) exports.include_external_entities_in (model)
    else exports.exclude_external_entities_in (model)

    if (!db.run) db = await cds.connect.to(db)
    if (!cds.db) cds.db = cds.services.db = db
    if (!db.model) db.model = model

    const any = await db.deploy (model,o)
    if (!any)  return

    // fill in initial data...
    const SILENT = o && o.silent || global.it || process.env.NODE_ENV === 'test'
    await init_from_js (db,model,SILENT)
    await init_from_csv (db,model,SILENT)
    await init_from_json (db,model,SILENT)

    const {credentials} = db.options, file = credentials && credentials.database
    if (!SILENT) {
      if (file !== ':memory:')  console.log (`/> successfully deployed to ./${file}\n`)
      else console.log (`/> successfully deployed to sqlite in-memory db\n`)
    }

    return db
  },
  // continue to support cds.deploy() as well...
  then(n,e) { return this.to (cds.db||'db') .then (n,e) },
  catch(e) { return this.to (cds.db||'db') .catch (e) },
}}




const { path, isdir, isfile } = cds.utils
const { promisify } = require('util')
const readdir = promisify (cds.utils.readdir)
const read = promisify (cds.utils.readFile)

exports.include_external_entities_in = function (model) {
  let any = false
  for (let each in model.definitions) {
      const def = model.definitions[each]
      if (def['@cds.persistence.mock'] === false) continue
      if (def['@cds.persistence.skip'] === true) {
          delete (any = def)['@cds.persistence.skip']
          if (model._xsn) delete model._xsn.definitions[each]['@cds.persistence.skip']
      }
  }
  if (any) Object.defineProperty(model,'_with-mocks',{value:true})
  return model
}

exports.exclude_external_entities_in = function (model) { // NOSONAR
  for (let [each,{service=each}] of Object.entries (cds.requires)) {
    if (!each.model) continue //> not for internal services like cds.requires.odata
    const prefix = service+'.'
    for (let each in model.definitions) if (each.startsWith(prefix)) {
      _exclude (each)
    }
  }
  return model

  function _exclude (each) {
    const def = model.definitions[each]; if (def.kind !== 'entity') return
    def['@cds.persistence.skip'] = true
    if (model._xsn) model._xsn.definitions[each]['@cds.persistence.skip'] = {val:true}
    DEBUG && DEBUG ('excluded imported', each)
    // propagate to all views...
    for (let other in model.definitions) {
      const q = model.definitions[other].query
      if (q && q.SELECT && q.SELECT.from && q.SELECT.from.ref && q.SELECT.from.ref[0] === each)
        _exclude (other)
    }
  }
}


function init_from_js (db, csn, SILENT) {

  if (!csn._sources)  return
  const folders = new Set([ path.resolve('db'), ...csn._sources.map (path.dirname)])
  const inits = []

  for (let each of folders) {
    const file = isfile (path.resolve(each,'init.js'));  if (!file)  continue
    SILENT || console.log (` > initializing database from ${path.relative(cwd,file)}`)  // eslint-disable-line
    let init = require(file);  if (!init)  continue
    if (!init.then && typeof init === 'function')  inits.push (init(db))
    else  inits.push (init)
  }

  return Promise.all (inits)
}

function init_from_csv (db, csn, SILENT) {
  return init_from_ (['data','csv'], _csvs, db, csn, SILENT, (entity, src) => {
    let [ cols, ...rows ] = cds.parse.csv (src)
    return rows && rows[0] && INSERT.into (entity) .columns (cols) .rows (rows)
  });

  function _csvs (filename,_,allFiles) {
    if (filename[0] === '-' || !filename.endsWith ('.csv'))  return false
    if (/_texts\.csv$/.test (filename) && check_lang_file(filename, allFiles)) {
      return false
    }
    return true
  }
}

function init_from_json (db, csn, SILENT) {
  return init_from_ (['data'], _jsons, db, csn, SILENT, (entity, src) => {
      let json = JSON.parse (src)
      return json[0] && INSERT.into (entity) .entries (json)
  });

  function _jsons (filename,_,allFiles) {
    if (filename[0] === '-' || !filename.endsWith ('.json'))  return false
    if (/_texts\.json$/.test (filename) && check_lang_file(filename, allFiles)) {
      return false
    }
    return true
  }
}

function check_lang_file(filename, allFiles) {
  // ignores 'Books_texts.csv/json' if there is any 'Books_texts_LANG.csv/json'
  const basename = path.basename(filename)
  const monoLangFiles = allFiles.filter (file => new RegExp('^'+basename+'_').test (file))
  if (monoLangFiles.length > 0) {
    DEBUG && DEBUG (`ignoring '${filename}' in favor of [${monoLangFiles}]`)  // eslint-disable-line
    return true
  }
  return false
}

async function init_from_ (locations, filter, db, csn, SILENT, INSERT_into) { // NOSONAR

  if (!csn._sources)  return
  const folders = new Set
  for (let model of csn._sources) {
    for (let data of locations) {
      for (let each of [ model+data, model+'/../'+data ]) {
        let folder = path.resolve (each)
        if (isdir (folder))  folders.add(folder)
      }
    }
  }

  if (folders.size === 0) return

  const cwd = process.env._original_cwd || process.cwd()
  const {relative} = require('path'), _relative = file => relative (cwd,file)
  const tx = await db.tx()
  const inits = []
  for (let folder of folders) {
    const files = await readdir (folder)
    for (let each of files.filter (filter)) {
      let name = each.replace(/-/g,'.').slice(0, -path.extname(each).length)
      let entity = _entity4 (name)
      if (!entity) { DEBUG && DEBUG (`warning: ${name} not in model`); continue }
      if (entity['@cds.persistence.skip'] === true) continue
      const file = path.join(folder,each)
      const src = await read (file, 'utf8'); if (!src) continue
      const q = INSERT_into (entity,src); if (!q) continue
      SILENT || console.log (`\x1b[2m > filling ${entity.name} from ${_relative(file)} \x1b[0m`) // eslint-disable-line
      inits.push (tx.run(q))
    }
  }
  await Promise.all(inits)
  return tx.commit()

  function _entity4 (name) {
    let entity = csn.definitions [name]
    if (!entity) {
      if (/(.+)_texts_?/.test (name)) { // 'Books_texts', 'Books_texts_de'
        const base = csn.definitions [RegExp.$1]
        return base && _entity4 (base.elements.texts.target)
      }
      else return
    }
    // We also support insert into simple views if they have no projection
    if (entity.query) {
      let {SELECT} = entity.query
      if (SELECT && !SELECT.columns && SELECT.from.ref && SELECT.from.ref.length === 1) {
        if (csn.definitions [SELECT.from.ref[0]])  return entity
      }
    }
    return entity.name ? entity : { name, __proto__:entity }
  }

}
/* eslint no-console: off */
/* global INSERT */
