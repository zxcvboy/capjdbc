/* eslint-disable no-console */
const Severities = ['Error', 'Warning', 'Info', 'Debug']

// sorts, filters, and writes compilation messages to console
module.exports = (messages, options={}) => {
  const { format } = require('./term')
  const level = _effectiveLogLevel (options)
  const log = options.log || console.error

  if (!Array.isArray (messages))  messages = [messages]
  messages.forEach (m => { if (!m.severity)  m.severity = 'Error' })

  messages = messages.filter (m => level.includes (m.severity))
  messages = _sortUnique (messages)

  for (let m of messages) {
    // show stack for resolution issues since there the requiring code location is in the stack
    const withStack = options.withStack || m.code === 'MODULE_NOT_FOUND'
    const mf = format (m, m.severity, isInternalError(m), withStack)
    log (mf)
  }
}

function _sortUnique (a, comparator=_compareCompilationMessage) {
  let arr = [];
  for (let i = 0; i < a.length; i++) {
    const hasDup = arr.some(v => comparator(v, a[i]) === 0)
    if (!hasDup)  arr.push(a[i])
  }
  return arr.sort (comparator)
}

function _compareCompilationMessage (a, b) {
  let rc = Severities.indexOf (a.severity) - Severities.indexOf (b.severity);  if (rc !== 0)  return rc
  rc = eq( a.message, b.message );  if (rc !== 0)  return rc

  if (a.location && b.location) {
    let aend = a.location.end || a.location.start;
    let bend = b.location.end || b.location.start;
    return ( eq( a.location.filename, b.location.filename ) ||
             eq( a.location.start.line, b.location.start.line ) ||
             eq( a.location.start.column, b.location.start.column ) ||
             eq( aend.line, bend.line ) ||
             eq( aend.column, bend.column ))
  }
  else
    return (!a.location ? (!b.location ? 0 : 1) : -1)
  }

function eq(x, y) {
  return (x === y) ? 0 : (x > y) ? 1 : -1
}

function _effectiveLogLevel (options) {
  const logLevel = options && options['log-level'] || require('../../lib').env["log-level"]
  if (/^debug$/i.test (logLevel))  return ['Error', 'Warning', 'Info', 'Debug']
  else if (/^info$/i.test (logLevel))  return ['Error', 'Warning', 'Info']
  else if (/^warn/i.test (logLevel))  return ['Error', 'Warning']
  else if (/^error/i.test (logLevel))  return ['Error']
  else return ['Error', 'Warning']
}

function isInternalError(e) {
  // check for standard Error classes, but not Error itself
  return e.name === 'EvalError' || e.name === 'InternalError' || e.name === 'RangeError'
    || e.name === 'ReferenceError' || e.name === 'SyntaxError' || e.name === 'TypeError'
    || e.name === 'URIError'
}
