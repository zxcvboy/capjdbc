import { Moment } from 'moment';
import { Field, StringFilterFunction, BooleanFilterFunction, NumberFilterFunction, FilterFunctionPrimitiveParameterType, FieldType, CollectionField } from '../common';
import { CollectionFilterFunction } from '../common/filter/collection-filter-function';
import { Entity } from './entity';
/**
 * Build a filter function to test whether a string is a substring of the other. Evaluates to boolean.
 * @param substr - The substring to test for. This can either be a string, a reference to a field or another filter function.
 * @param str - The string to test. This can either be a string, a reference to a field or another filter function.
 *
 * @returns The newly created filter function
 */
export declare function contains<EntityT extends Entity>(substr: string | Field<EntityT> | StringFilterFunction<EntityT>, str: string | Field<EntityT> | StringFilterFunction<EntityT>): BooleanFilterFunction<EntityT>;
/**
 * Build a filter function to test whether a string matches a pattern. Evaluates to boolean.
 * @param str - The string to get the index from. This can either be a string, a reference to a field or another filter function.
 * @param regex - The pattern to test against. This should be a regular expression as a string.
 * @returns The newly created filter function
 */
export declare function matchesPattern<EntityT extends Entity>(str: string | Field<EntityT> | StringFilterFunction<EntityT>, regex: string): BooleanFilterFunction<EntityT>;
/**
 * Build a filter function to get the fractional seconds of a date. Evaluates to decimal.
 * @param date - The date to get the fractional seconds for. This can either be a date (Moment) or a reference to a field.
 * @returns The newly created filter function
 */
export declare function fractionalSeconds<EntityT extends Entity>(date: Moment | Field<EntityT>): NumberFilterFunction<EntityT>;
/**
 * Build a filter function to get the signed number of minutes in the time zone offset. Evaluates to int.
 * @param date - The date to get the offset minutes for. This can either be a date (Moment) or a reference to a field.
 * @returns The newly created filter function
 */
export declare function totalOffsetMinutes<EntityT extends Entity>(date: Moment | Field<EntityT>): NumberFilterFunction<EntityT>;
/**
 * Build a filter function to get the latest possible point in time. Evaluates to DateTimeOffset.
 * @returns The newly created filter function
 */
export declare function maxDateTime<EntityT extends Entity>(): NumberFilterFunction<EntityT>;
/**
 * Build a filter function to get the earliest possible point in time. Evaluates to DateTimeOffset.
 * @returns The newly created filter function
 */
export declare function minDateTime<EntityT extends Entity>(): NumberFilterFunction<EntityT>;
/**
 * Build a filter function to get the current point in time. Evaluates to DateTimeOffset.
 * @returns The newly created filter function
 */
export declare function now<EntityT extends Entity>(): NumberFilterFunction<EntityT>;
/**
 * Build a filter function to test whether a set is a subset of the other, i. e. wheter the second parameter can be transformed into the first by reordering and / or removing items. Evaluates to boolean.
 * @param subset - The subset to test for. This can either be an array, a reference to a field or another filter function.
 * @param set - The set to test. This can either be an array, a reference to a field or another filter function.
 *
 * @returns The newly created filter function
 */
export declare function hasSubset<EntityT extends Entity, ParamT extends FilterFunctionPrimitiveParameterType, ReturnT extends FieldType>(subset: ParamT[] | CollectionField<EntityT, any> | CollectionFilterFunction<EntityT, ReturnT>, set: ParamT[] | CollectionField<EntityT, any> | CollectionFilterFunction<EntityT, ReturnT>): BooleanFilterFunction<EntityT>;
/**
 * Build a filter function to test whether a set is a subsequence of the other, i. e. wheter the second parameter can be transformed into the first by removing items. Evaluates to boolean.
 * @param subsequence - The subsequence to test for. This can either be an array, a reference to a field or another filter function.
 * @param sequence - The sequence to test. This can either be an array, a reference to a field or another filter function.
 *
 * @returns The newly created filter function
 */
export declare function hasSubsequence<EntityT extends Entity, ParamT extends FilterFunctionPrimitiveParameterType, ReturnT extends FieldType>(subsequence: ParamT[] | Field<EntityT> | CollectionFilterFunction<EntityT, ReturnT>, sequence: ParamT[] | Field<EntityT> | CollectionFilterFunction<EntityT, ReturnT>): BooleanFilterFunction<EntityT>;
/**
 * TODO: totalseconds, time
 */
/**
 * OData v4 specific filter functions
 */
export declare const filterFunctions: {
    contains: typeof contains;
    matchesPattern: typeof matchesPattern;
    fractionalSeconds: typeof fractionalSeconds;
    totalOffsetMinutes: typeof totalOffsetMinutes;
    maxDateTime: typeof maxDateTime;
    minDateTime: typeof minDateTime;
    now: typeof now;
    hasSubset: typeof hasSubset;
    hasSubsequence: typeof hasSubsequence;
    endsWith: typeof import("../common/filter/filter-functions").endsWith;
    startsWith: typeof import("../common/filter/filter-functions").startsWith;
    length: typeof import("../common/filter/filter-functions").length;
    indexOf: typeof import("../common/filter/filter-functions").indexOf;
    substring: typeof import("../common/filter/filter-functions").substring;
    toLower: typeof import("../common/filter/filter-functions").toLower;
    toUpper: typeof import("../common/filter/filter-functions").toUpper;
    trim: typeof import("../common/filter/filter-functions").trim;
    concat: typeof import("../common/filter/filter-functions").concat;
    round: typeof import("../common/filter/filter-functions").round;
    floor: typeof import("../common/filter/filter-functions").floor;
    ceiling: typeof import("../common/filter/filter-functions").ceiling;
    day: typeof import("../common/filter/filter-functions").day;
    hour: typeof import("../common/filter/filter-functions").hour;
    minute: typeof import("../common/filter/filter-functions").minute;
    month: typeof import("../common/filter/filter-functions").month;
    second: typeof import("../common/filter/filter-functions").second;
    year: typeof import("../common/filter/filter-functions").year;
    isOf: typeof import("../common/filter/filter-functions").isOf;
};
//# sourceMappingURL=filter-functions.d.ts.map