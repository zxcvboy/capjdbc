"use strict";
/* Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved. */
/* eslint-disable valid-jsdoc */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tsToEdm = exports.edmToTs = void 0;
var moment_1 = __importDefault(require("moment"));
var payload_value_converter_1 = require("../common/payload-value-converter");
/**
 * @hidden
 */
function edmToTs(value, edmType) {
    if (value === null || typeof value === 'undefined') {
        return value;
    }
    if (deserializers[edmType]) {
        return deserializers[edmType](value);
    }
    return value;
}
exports.edmToTs = edmToTs;
/**
 * @hidden
 */
function tsToEdm(value, edmType) {
    if (value === null) {
        return 'null';
    }
    if (serializers[edmType]) {
        return serializers[edmType](value);
    }
    return value;
}
exports.tsToEdm = tsToEdm;
function edmDateToMoment(date) {
    var parsed = moment_1.default.utc(date, 'YYYY-MM-DD', true);
    if (!parsed.isValid()) {
        throw new Error("Provided date value " + date + " does not follow the Edm.Date pattern: YYYY-MM-DD");
    }
    return parsed;
}
function edmDateTimeOffsetToMoment(dateTime) {
    var prefix = 'YYYY-MM-DDTHH:mm';
    // In moment the Z is either Offset from UTC as +-HH:mm, +-HHmm, or Z
    var validFormats = [prefix + "Z", prefix + ":ssZ", prefix + ":ss.SSSZ"];
    var parsed = moment_1.default(dateTime, validFormats, true);
    if (!parsed.isValid()) {
        throw new Error("Provided date-time value " + dateTime + " does not follow the Edm.DateTimeOffset pattern: YYYY-MM-DDTHH:mm(:ss(.SSS))Z");
    }
    return parsed;
}
function edmDurationToMoment(value) {
    var durationPattern = /([\+,\-]{1,1})?P(\d{1,2}D)?(T(\d{1,2}H)?(\d{1,2}M)?(\d{1,2}S)?(\d{2,2}\.\d+S)?)?/;
    var captured = durationPattern.exec(value);
    if (!captured || captured[0] !== value) {
        throw new Error("Provided duration value " + value + " does not follow the Edm.Duration pattern: +/- P0DT0H0M0S");
    }
    return moment_1.default.duration(value);
}
function edmTimeOfDayToTime(value) {
    var timeComponents = /(\d{2,2}):(\d{2,2}):(\d{2,2}(\.\d{1,12}){0,1})?/.exec(value);
    if (!timeComponents) {
        throw new Error("Provided time value " + value + " does not follow the Edm.TimeOfDay pattern: HH:MM:SS(.S)");
    }
    return {
        hours: parseInt(timeComponents[1]),
        minutes: parseInt(timeComponents[2]),
        seconds: parseFloat(timeComponents[3])
    };
}
function momentToEdmDate(value) {
    return value.format('YYYY-MM-DD');
}
function momentToEdmDateTimeOffsetToMoment(value) {
    return value.utc().format('YYYY-MM-DDTHH:mm:ss.SSS') + 'Z';
}
function durationToEdmDuration(value) {
    return value.toISOString();
}
function timeToEdmTimeOfDay(value) {
    return value.hours + ":" + value.minutes + ":" + value.seconds;
}
var deserializers = __assign(__assign({}, payload_value_converter_1.deserializersCommon), { 'Edm.Date': edmDateToMoment, 'Edm.DateTimeOffset': edmDateTimeOffsetToMoment, 'Edm.Duration': edmDurationToMoment, 'Edm.TimeOfDay': edmTimeOfDayToTime });
var serializers = __assign(__assign({}, payload_value_converter_1.serializersCommom), { 'Edm.Date': momentToEdmDate, 'Edm.DateTimeOffset': momentToEdmDateTimeOffsetToMoment, 'Edm.Duration': durationToEdmDuration, 'Edm.TimeOfDay': timeToEdmTimeOfDay });
//# sourceMappingURL=payload-value-converter.js.map