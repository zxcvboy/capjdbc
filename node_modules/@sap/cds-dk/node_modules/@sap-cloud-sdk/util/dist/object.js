"use strict";
/* Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved. */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renameKeys = exports.mergeSome = exports.assocSome = exports.propertyExists = void 0;
var rambda_1 = require("rambda");
/**
 * Checks if a chain of properties exists on the given object.
 *
 * @param obj - The object to be checked.
 * @param properties - Chained properties.
 * @returns True if the property chain leads to a truthy value, false otherwise.
 */
function propertyExists(obj) {
    var properties = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        properties[_i - 1] = arguments[_i];
    }
    if (!properties.length) {
        return true;
    }
    if (obj && obj.hasOwnProperty(properties[0])) {
        return propertyExists.apply(void 0, __spreadArrays([obj[properties[0]]], properties.slice(1)));
    }
    return false;
}
exports.propertyExists = propertyExists;
/**
 * Calls rambda's assoc function if the provided value is neither null nor undefined.
 * Note that this is different to JS idiomatic checks for truthy/falsy values, i.e. an empty string will result in assoc being called.
 *
 * @param key - The key to associate with the given value.
 * @param value - The value to associate with the given key.
 * @param obj - The object on which to create the association.
 * @returns A copy of the input object with the new key-value pair if the value is neither null nor undefined.
 */
exports.assocSome = function (key, value) { return function (obj) {
    if (typeof value !== 'undefined' && value !== null) {
        return rambda_1.assoc(key, value)(obj);
    }
    return obj;
}; };
/**
 * Calls rambda's merge function if second object is neither null nor undefined.
 *
 * @param a - The object to merge into.
 * @param b - The object which to merge into a.
 * @returns A copy of the merge(a, b) or a if b is undefined or null.
 */
exports.mergeSome = function (a, b) {
    if (typeof b !== 'undefined' && b !== null) {
        return rambda_1.merge(a, b);
    }
    return a;
};
/**
 * Takes an object and returns a new object whose keys are renamed according to the provided key mapping.
 * Any keys in the input object not present in the key mapping will be present in the output object as-is.
 * If a key in the key mapping is not present in the input object, the output object will contain the key with value "undefined".
 *
 * @param keyMapping - An object mapping keys of the input object to keys of the output object.
 * @param obj - The input object.
 * @returns An object with renamed keys.
 */
exports.renameKeys = function (keyMapping, obj) {
    var unchangedEntries = Object.keys(obj)
        .filter(function (k) { return !Object.keys(keyMapping).includes(k); })
        .reduce(function (newObj, key) {
        var _a;
        return (__assign(__assign({}, newObj), (_a = {}, _a[key] = obj[key], _a)));
    }, {});
    return Object.entries(keyMapping).reduce(function (newObj, _a) {
        var _b;
        var oldKey = _a[0], newKey = _a[1];
        return (__assign(__assign({}, newObj), (_b = {}, _b[newKey] = obj[oldKey], _b)));
    }, unchangedEntries);
};
//# sourceMappingURL=object.js.map