module.exports = Object.assign(deploy, {
  options: ['--to', '--tunnel-address', '--vcap-file'], flags: [ '--no-save', '--auto-undeploy', '--dry', '--with-mocks' ],
  shortcuts: ['-2'],
  help: `
# SYNOPSIS

    *cds deploy* [ <model> ] [ <options> ]

    Deploys the given model to a database. If no model is given it looks up
    according configuration from _package.json_ or _.cdsrc.json_ in key
    _cds.requires.db_.  Same for the database.

    Supported databases: sqlite, hana


# OPTIONS

    *-2* | *--to* <database> [ : <database specific parameter> ],

      Where <database> is 'sqlite' or 'hana', <database specific parameter>
      can be a path to the database file (sqlite) or the service name (hana).

    *--dry*

      Just print the SQL statements without executing them.

    *--with-mocks*

      Also create tables for all entities from imported models.

    *--no-save*

      Do not modify the package.json file.

    *--auto-undeploy* (beta feature)

      Tell HDI deployer to automatically undeploy deleted resources.

    *--tunnel-address* (beta feature)

      Deploy through the given address (host:port) rather than the original
      database address.  The tunnel must have been opened before, e.g. using 'cf ssh'.

    *--vcap-file* (beta feature)

      Use credentials from the given file when deploying to *SAP HANA*, instead of
      creating new credentials. File must be in *default-env.json* format, with a root
      node *VCAP_SERVICES*.

# EXAMPLES
    cds deploy --to sqlite:db
    cds deploy --to hana:myService --auto-undeploy
    cds deploy --to hana --vcap-file ./secret/default-env.json

`})

const cds = require('@sap/cds/lib')

async function deploy ([_model], options) { // NOSONAR

  const { 'to':url, 'no-save':no_save = cds.env.deploy.no_save } = options
  if (!options.mocked) { options.mocked  = options['with-mocks'] }
  if (!url && !cds.env.requires.db)  throw new Error(
    `Please specify a database kind or url, e.g.:

    cds deploy --to sql
    cds deploy --to sqlite
    cds deploy --to sqlite:db/my.db
    `)

  const conf = cds.env.requires.db || {}
  const [,_kind,_db] = /(\w+)?(?::(.*))?/.exec(url||'')
  const kind = _kind || conf.use || conf.kind

  try {
    var deployer = require ('./to-'+kind)
  } catch (e) {
    if (e.code === 'MODULE_NOT_FOUND') {
      throw new Error(`Didn't find a deployer module for '${kind}'`)
    }
  }
  try {
    await deployer.deploy (_model, _db, options)
    if (options.dry)  return
    if (kind === 'hana')  return // REVISIT: the hana deployer is a bit special
    if (url && !no_save)  await updata_package_json (_kind, _model, _db)
  } catch (e) {
    if (e.code === 'MODEL_NOT_FOUND') {
      if (!_model) throw new Error ('No .cds models found, please specify one as an argument')
      throw new Error (`No cds models found at/in '${_model}'`)
    } else throw e
  }
}


async function updata_package_json (kind, model, database) {
  const {fs,path,promisify} = cds.utils, read = promisify (fs.readFile), write = promisify (fs.writeFile)
  const package_json = path.resolve ('package.json'), exists = fs.isfile (package_json)
  const conf = exists ? JSON.parse (await read (package_json)) : {}
  const requires = ['cds','requires'] .reduce ((p,n)=>p[n] || (p[n]={}), conf)
  requires.db = cds.env.requires.db = { kind, model }
  if (database)  requires.db.credentials = { database }
  await write (package_json, JSON.stringify(conf,null,'  '))
  console.log (`/> ${ exists ? 'updated' : 'created' } ./package.json`)
}

/* eslint no-console: off */
