module.exports = Object.assign ( compile, {
  options: [
  '--from', '--service', '--lang', '--for', '--to', '--dest', '--log-level'
  ],
  flags: [
  '--parse', '--all', '--beta', '--clean', '--conceptual', '--min', '--docs'
  ],
  shortcuts: [
  '-f', '-s', '-l', '-4', '-2', '-o', undefined, '-p'
  ],
  help: `
# SYNOPSIS

  *cds compile* [<models>] [<options>]

  Compiles the specified models to CSN format, applying processors to unfold
  and generate target outputs using the <options>.
  ${''
  // If no <models> are specified *cds* reads from stdin, which allows it to
  // be used with unix pipes, for example:
  // *cat* hy | *cds* -2 sql | *sqlite3* test.db
  }

# OPTIONS
  ${''
    // *-f, --from* <frontend>

    //     Use the specified frontend to parse the input. <frontend> can be one of
    //     the built-in parsers like *cdl*, *yaml*, or
    //     valid node module IDs of custom parsers.
  }

  *-2* | *--to* <target format>

    Compiles the given models to the specified <target format>.
    Currently supported:

    - json, yml
    - edm, edmx, edmx-v2, edmx-v4
    - sql, hana
    - xsuaa

  *-4* | *--for* <target>

    Use this option to merely unfold the compiled CSN
    for the specified <target> usages, or get a comma-separated list,
    without actually generating target formats.
    Currently supported:

    - odata
    - sql

  *-s* | *--service* <name> | all

    Chooses a specific service, in case a model contains multiple services.
    Specify _all_ to force output for all services.

  *-l* | *--lang* <languages> | all

    Localizes the output with given <languages>, a comma-separated list
    of language/locale codes or _all_. Localization is carried out before
    all other processors (-4/u) or backends (-2).

  *-o* | *--dest* <folder>

    Writes output to the given folder instead of stdout.

  *-p* | *--parse*

    Returns the parsed definitions and extensions, without applying the
    extensions or includes, and without imported definitions.

  *--clean*

    Tells the compiler to not add any derived information. Returns a
    CSN, which truely reflects what's written in the _.cds_ sources.

  *--docs*

    Preserves /**...*/ doc comments in 'doc' properties of CSN outputs,
    as well as in 'Core.Description' annotations of EDMX outputs.

  *--log-level* debug | info | warn | error

    Choose which level of compiler messages to log. The default log-level is *warn*.


# EXAMPLES

   *cds* compile model.cds
   *cds* c model.json --to sql
   *cds* srv -s all -l all -2 edmx -o _out

`})

function compile_all (root='.') {

  const {exec} = require ('child_process')
  const cds = require ('@sap/cds')

  exec(`find ${root} -name *.cds ! -path '*/node_modules/*'`, (_,stdout)=>{
    const all = stdout.split('\n').slice(0,-1)
    const info = `\n/ compiled ${all.length} cds models in`
    console.log (`Compiling ${all.length} cds models found in ${process.cwd()}...\n`)
    console.time (info)
    return Promise.all (all.map (each => cds.load(each)
      .then (()=> console.log (' ',each))
      .catch (()=> console.log (' \x1b[91m', each, '\x1b[0m'))
    )).then (()=>
      console.timeEnd (info)
    )
  })

}

function compile (models, options={}) {

  if (options.all)  return compile_all (models[0])

  const cds = require ('@sap/cds')

  let model, src, _suffix; //> be filled in below
  if (!options.as && !/,/.test(options.to))  options.as = 'str'
  if (options.beta)  options.betaMode = true
  if (options.parse) options.parseCdl = true
  if (typeof models === 'string')  models = [models]

  const messages=[]
  if (cds.env.features.snapi === 'runtime-only') cds.env.features.snapi = false
  if (cds.env.features.snapi)  options.messages = messages
  else  options._messages = messages  // some old apis have issues with options.messages

  if (Array.isArray(models) && models.length > 0) {  // any arguments?
    if (options.conceptual) model = require('@sap/cds/lib/alpha/_compile-clean') (models, options)
    else model = cds.load (models, options)
    src = models[0] .replace (/\.[^.]+$/,'')       //> excluding source file extension, e.g. .cds
  } else if (!process.stdin.isTTY && process.argv[1].endsWith('cds')) {  // else check for stdin
    model = readModelFromStdin()
    src = 'stdin'
  } else { // no args, no stdin
    throw new Error (`You must specify a model to compile.\nRun 'cds c -?' to learn more.`)
  }

  let chain = model.then (m => model=m)

  // add processors for compiling
  if (options.for) for (let each of options.for.split(',')) {
    chain = chain.then (next (processor ('for', each)))
  }

  // add processors for compiler backends
  if (options.to) for (let each of options.to.split(',')) {
    chain = chain.then (next (processor ('to', _suffix=each)))
  }

  // add processor for i18n
  if (options.lang) {
    if (options.lang === true)  options.lang = cds.env.i18n.languages // --language w/o value
    let lang = options.lang
    if (lang.split)  lang = lang.split(',') // string to array
    if (lang.length === 1 && options.lang !== '*' && options.lang !== 'all')  lang = lang[0]  // pick single
    const localize = each => cds.localize (model, lang, each)
    chain = chain.then (next (x => {
      if (isSingle(x)) return localize(x)
      else return function*(){
        for (let [each,o] of x)  yield [ localize(each), o ]
      }()
    }))
  }

  // add output processor
  const write = require ('@sap/cds/bin/utils/write')
  chain = chain.then (write.to ({
    folder: options.dest,
    file: options.file || src,
    suffix: options.suffix || suffix4(_suffix),
    [options.dest ? 'foreach' : 'log']: options.log || consoleLog
  }))

  // add processor for logging compiler messages and errors
  const log = this.log || require('@sap/cds/bin/utils/log')
  chain = chain.then ((results)=>{
    if (messages.length) log (messages, options)
    return results
  }, (e) => {
    if (e.errors)  { log (e.errors, options); process.exitCode = 1 }
    else throw e
  })

  // return to run
  return chain


  function processor (kind, tail) {
    let p = cds.compile[kind]
    for (let each of tail.split('.')) {
      p = p[each]
      if (!p) throw new Error (`Unknown model processor: cds.compile.${kind}.${tail}`)
    }
    return p
  }

  function next (proc) {
    return (prev) => function*(){
      if (isSingle(prev))  yield [ proc(prev,options) ]
      else for (let [outer,_outer] of prev) {
        let next = proc (outer, options)
        if (isSingle(next)) yield [ next, _outer ]
        else for (let [inner,_inner] of next) {
          yield [ inner, Object.assign({},_outer,_inner) ]
        }
      }
    }()
  }
  function isSingle (x) {
    return !(x[Symbol.iterator] && x.next)
  }

  function readModelFromStdin(){
    return new Promise ((_resolved, _error) => {
      let src=""; process.stdin
      .on ('data', chunk => src += chunk)
      .on ('end', ()=> _resolved (src[0] === '{' ? JSON.parse(src) : cds.parse(src)))
      .on ('error', _error)
    })
  }

  function consoleLog(o) {
    if (typeof o === 'string')  return console.log (o)
    // in non-tty cases write a proper JSON string
    if (!process.stdout.isTTY)  return console.log (JSON.stringify(o, null, 2))
    // tty: display formatted object
    return console.dir (o, {colors: true, depth: 111})
  }

  function suffix4 (x) { return x && ({
    edmx: '.xml',
    swgr: '.yml',
    cdl: '.cds',
    ddl: '.sql',
    sql: '.sql',
    edm: '.json'
  }[x] || '.'+x) }

}
/* eslint no-console:0 */
