const cp = require('child_process');
const os = require('os');

const { IS_WIN } = require('../constants');

const { nullLogger } = require('./logger');

class CommandUtil {

    /**
     * Execute a command and show output in console
     * spawn has problems with promisify so use native approach w/ Promise
     * @param cmd command
     * @param args command args
     * @param options spawn options
     * @param logger logger to use
     * @param collectResult if true, return complete console output as promise resolve value
     *                      this might result in a huge string!
     *
     * @returns Promise
     */
    async spawnCommand(cmd, args, options, logger = nullLogger, collectResult = false) {
        args = this._sanitizeArgs(args);
        return new Promise((resolve, reject) => {
            logger.debug(`[spawn] ${cmd} ${args.join(' ')}`);

            options = options || {};
            options.env = options.env || process.env;

            const spawnOptions = {
                shell: IS_WIN, // for windows only
                ...options
            }

            const child = cp.spawn(cmd, args, spawnOptions);

            // use inplace methods to ensure logger is called in context
            const stdLogBuffer = new LogBuffer((chunk) => logger.log(chunk), collectResult);
            child.stdout.on('data', (chunk) => {
                stdLogBuffer.handleChunk(chunk);
            });

            // use inplace methods to ensure logger is called in context
            const errLogBuffer = new LogBuffer((chunk) => logger.error(chunk), collectResult);
            child.stderr.on('data', (chunk) => {
                errLogBuffer.handleChunk(chunk);
            });

            child.on('close', (code) => {
                // dump buffer
                stdLogBuffer.flush();
                errLogBuffer.flush();

                if (code === 0) {
                    resolve(stdLogBuffer.getResult());
                } else {
                    reject(new Error(`${cmd} ${args.join(' ')} failed with code ${code}${os.EOL}${errLogBuffer.getResult()}`));
                }
            });

            child.on('error', (err) => {
                reject(err);
            });
        });
    }

    _sanitizeArgs(args) {
        const result = [];
        for (const arg of args) {
            result.push(arg.replace(/[&;|]/g, ''));
        }
        return result;
    }

}

class LogBuffer {

    constructor(logMethod, collectResult) {
        this.logMethod = logMethod;
        this.collectResult = collectResult;
        this.result = '';
        this.buffer = '';
    }

    handleChunk(chunk) {
        const chunkStr = chunk.toString();

        if (this.collectResult) {
            this.result = this.result + chunkStr;
        }

        const seq = chunkStr.split(os.EOL);
        this.buffer = this.buffer + seq.shift();
        for (const line of seq) {
            this.flush();
            this.buffer = line;
        }
    }

    flush() {
        if (this.logMethod && this.buffer) {
            this.logMethod(this.buffer);
            this.buffer = '';
        }
    }

    getResult() {
        return this.result.trim();
    }
}

module.exports = new CommandUtil();
