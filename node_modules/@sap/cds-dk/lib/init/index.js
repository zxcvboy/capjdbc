const path = require('path');

const { defaultLogger } = require('./util/logger');
const FsUtil = require('./util/fsUtil');

const { OPTION_HANA, OPTION_JAVA, OPTION_MTA, OPTION_PIPELINE, OPTION_SAMPLES, OPTION_PROJECT, PROJECT_FILES } = require('./constants');

module.exports = class CDSGenerator {
    constructor(fsUtil, logger) {
        this.fsUtil = fsUtil || new FsUtil();
        this.logger = logger || defaultLogger;

        this.config = {
            add: {
                title: `Features`,
                description: `Select the features for the new project.`,
                default: '',
                choices: [OPTION_HANA, OPTION_JAVA, OPTION_MTA, OPTION_PIPELINE, OPTION_SAMPLES],
                multiple: true,
                promptOrder: 10
            },
            force: {
                default: false
            }
        }
    }

    /**
     * @param {string} templates, comma separated list of templates, no blanks
     * @param {any} options, additional options
     */
    async addCmd(templates, options = {}) {
        options.add = templates;

        this._initialize(null, options);
        options._cmd = 'add';
        this._greetings(options._cmd);

        const folderContent = await this.fsUtil.readdir(this.projectPath);
        if (!folderContent.includes('package.json')) {
            throw new Error(`The current folder doesn't seem to contain a project (package.json is missing).`);
        }

        if (options.add.has(OPTION_JAVA)) {
            throw new Error('Cannot change the type of an existing project.');
        }

        await this._process(options);
        await this.stepEnd(options);
    }

    /**
     * @param {string} projectName, the project name
     * @param {any} options, additional options
     */
    async initCmd(projectName, options = {}) {
        await this.stepInit(projectName, options);
        await this.stepEnd();
    }

    async stepInit(projectName, options = {}) {
        options.add = OPTION_PROJECT + (options.add ? `,${options.add}` : '');

        this._initialize(projectName, options);
        options._cmd = 'init';
        this._greetings(options._cmd);

        await this._process();
    }

    async findProjectFile() {
        for (const file of PROJECT_FILES) {
            if (await this.fsUtil.pathExists(path.join(this.projectPath, file))) {
                return file;
            }
        }

        return null;
    }

    _initialize(projectName, options = {}) {
        // deprecated, only for compatibility
        if (options.verbose) {
            process.env.DEBUG = true;
        }

        this.cwd = options.cwd || process.cwd();
        this.projectPath = path.resolve(this.cwd, projectName || '.');

        this.options = options;
        this._cleanupOptions();
    }

    _greetings(cmd) {
        switch (cmd) {
            case 'init': {
                const relativeProjectPath = path.relative(this.cwd, this.projectPath);
                const folderName = (relativeProjectPath ? `.${path.sep}${relativeProjectPath}` : 'current folder');
                this.logger.log(`[cds] - creating new project in ${folderName}`);
                break;
            }

            case 'add':
                this.logger.log(`[cds] - adding feature(s) to project in current folder`);
                break;

            default:
        }

        if (this.options.force) {
            this.logger.log(`Using '--force' ... existing files will be overwritten...!`);
        }
    }

    async _process() {
        this.logger.debug(`Project path: ${this.projectPath}`);

        await this._fillTemplateList();

        for (const template of this.templateList) {
            if (!template.isInternal) {
                this.logger.log(`> adding feature '${template.name}'...`);
            }
            await template.run();
        }

        this.logger.log(`done.`);
        this.logger.log();
    }

    async _fillTemplateList() {
        this.templateList = [];

        for (const addOption of this.options.add) {
            if (addOption !== OPTION_JAVA) {
                let Template;
                try {
                    Template = require(`./template/${addOption}`);
                } catch (err) {
                    throw new Error(`feature '${addOption}' not found. ${err}`);
                }
                const template = new Template(this.projectPath, this);
                this.templateList.push(template);
            }
        }

        this.templateList.sort((a, b) => {
            const prioA = a.getPriority();
            const prioB = b.getPriority();
            return prioB - prioA;
        });

        const newList = [];
        for (const template of this.templateList) {
            // checkEnabled might throw error if call is invalid to abort execution
            this.logger.debug(`Checking feature '${template.name}'`);
            if (await template.checkEnabled()) {
                this.logger.debug(`Adding feature '${template.name}'`);
                newList.push(template);
            }
        }
        this.templateList = newList;

        // check debug to avoid lengthy computation when not debug
        if (process.env.DEBUG) {
            this.logger.debug(`Features: ${this.templateList.map((obj) => {
                return obj.name;
            }).join(', ')}`);
        }
    }

    async stepEnd() {
        for (const template of this.templateList) {
            await template.finalize();
        }

        if (process.env.DEBUG) {
            this._showFiles();
        }
    }

    _showFiles() {
        const files = this.fsUtil.getTouchedFiles();
        if (files && files.length > 0) {
            this.logger.log();
            this.logger.log(`Added / changed files`);
            for (const file of files) {
                this.logger.log(`- ${file}`);
            }
        }
    }

    _cleanupOptions() {
        let tokens = [];

        if (typeof this.options.add === 'string') {
            tokens = this.options.add.split(/[,\s]/);

        } else if (Array.isArray(this.options.add)) {
            tokens = this.options.add

        } else if (this.options.add instanceof Set) {
            tokens = [...this.options.add];
        }

        const trimmedTokens = tokens.map((token) => {
            return token.trim();
        }).filter((token) => {
            return !!token;
        });

        // set is ordered ... always
        this.options.add = new Set(trimmedTokens);
    }
}
