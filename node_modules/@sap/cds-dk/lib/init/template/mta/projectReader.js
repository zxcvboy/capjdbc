const path = require('path')
const { nullLogger } = require('../../util/logger')
const BuildTaskFactory = require('@sap/cds/lib/build/buildTaskFactory')
const { BUILD_TASK_HANA, BUILD_TASK_FIORI, BUILD_TASK_JAVA, BUILD_TASK_NODE, BUILD_TASK_MTX } = require("@sap/cds/lib/build/constants")

const P_LANGUAGE_JAVA = 'java'
const P_LANGUAGE_NODEJS = 'nodejs'
const DEFAULT_P_LANGUAGE = P_LANGUAGE_NODEJS

module.exports = class ProjectReader {

    constructor(template) {
        this.template = template
    }

    /**
     * Returns cds.env using 'production' profile by default as mta deployment is executed with having production profile set.
     */
    async getEnv(profile = 'production') {
        const cdsEnvVar = process.env.CDS_ENV
        process.env.CDS_ENV = profile
        let env
        try {
            env = await this.template.getEnv(true);
        } finally {
            cdsEnvVar ? process.env.CDS_ENV = cdsEnvVar : delete process.env.CDS_ENV
        }
        return env
    }

    get fsUtil() {
        return this.template.fsUtil
    }

    get logger() {
        return this.template.logger
    }

    get projectPath() {
        return this.template.projectPath
    }

    async read() {
        const env = await this.getEnv();
        if (process.env.DEBUG) {
            this.logger.log(JSON.stringify(env, null, 1))
        }

        const capDescriptor = await this._getCapDescriptor(env)
        const uiDescriptor = await this._getUiDescriptor(env)
        const projectDescriptor = {
            cap: capDescriptor,
            ui: uiDescriptor
        }

        await this._validate(projectDescriptor)

        if (process.env.DEBUG) {
            this.logger.log(JSON.stringify(projectDescriptor, null, 1))
        }

        return projectDescriptor
    }

    async _getCapDescriptor(env) {
        const appDetails = await this._getAppDetails()
        const capDescriptor = {
            appId: appDetails.id,
            appName: appDetails.name,
            appVersion: appDetails.version,
            appDescription: appDetails.description,
            pLanguage: DEFAULT_P_LANGUAGE,
            srvPath: null,
            db: [],
            requires: [],
            get isMultiTenant() {
                return this.requires.some(req => req.resource.isMultiTenant)
            },
            get isNodejs() {
                return this.pLanguage == P_LANGUAGE_NODEJS
            },
            get isJava() {
                return this.pLanguage == P_LANGUAGE_JAVA
            },
            get hasRequires() {
                return this.requires.length > 0
            },
            get hasRequiresDb() {
                return this.db.length > 0
            },
            get needsSidecar() {
                // {{#if (and (gt cap.db.length 0) (or (eq cap.pLanguage 'java') (ne cap.multiTenant true) ) ) }}
                return this.db.length > 0 && (this.isJava || !this.isMultiTenant)
            },
        }

        // setting the effective env as it might have changed by already executed 'add' commands, e.g. cds init foo --add hana,mta
        const cds = require('@sap/cds/lib')
        cds.env = env;

        const buildTasks = await new BuildTaskFactory(process.env.DEBUG ? this.logger : nullLogger, cds).getTasks({ root: this.projectPath, resolve: true, mta: false })

        buildTasks.forEach((task) => {
            const relDestPath = ProjectReader._slash(path.relative(this.projectPath, task.dest))

            switch (task.for) {
                case BUILD_TASK_HANA:
                    // check whether we have a hana service binding defined as a hana build task is returned by default for compatibility reasons if neither hana, nor sqlite has been defined
                    if (this._hasHanaServiceBinding(env)) {
                        capDescriptor.db.push({ path: relDestPath, name: path.basename(task.src) })
                    }
                    break

                case BUILD_TASK_JAVA:
                    capDescriptor.pLanguage = P_LANGUAGE_JAVA
                    capDescriptor.srvPath = relDestPath
                    break

                case BUILD_TASK_NODE:
                    capDescriptor.srvPath = relDestPath
                    break

                case BUILD_TASK_FIORI:
                case BUILD_TASK_MTX:
                    break

                default:
                    this.logger.warn(`Unknown build task type ${task.for}`)
            }
        })

        this._addResourceDependencies(env, capDescriptor)

        return capDescriptor
    }

    async _getUiDescriptor(env) {
        const uiDescriptor = {
            appPath: null
        }

        if (await this.fsUtil.pathExists(path.join(this.projectPath, env.folders.app))) {
            uiDescriptor.appPath = env.folders.app
        }


        return uiDescriptor
    }

    async _addResourceDependencies(env, capDescriptor) {
        const hanaResources = new Map()
        const otherResources = new Map()

        for (let key of Object.keys(env.requires)) {
            if (env.requires[key].kind === 'hana') {
                hanaResources.set(key, env.requires[key])
            } else {
                otherResources.set(key, env.requires[key])
            }
        }
        for (let [key, value] of hanaResources) {
            let resource = this._getReqResource(key, value, capDescriptor)
            if (resource) {
                // using production profile
                capDescriptor.requires.push({ resource })
            }
        }
        // add after hana resource dependencies have been handled as multitenant information is required
        for (let [key, value] of otherResources) {
            let resource = this._getReqResource(key, value, capDescriptor)
            if (resource) {
                // using production profile
                capDescriptor.requires.push({ resource })
            }
        }
    }

    _hasHanaServiceBinding(env) {
        const kind = ProjectReader._getProperty(env, 'requires.db.kind')
        return kind === 'hana' || (kind === 'sql' && ProjectReader._getProperty(env, 'requires.db.use') === 'hana')
    }

    _getReqResource(key, reqEntry, capDescriptor) {
        const resource = {
            name: ProjectReader._getResourceName(key, capDescriptor),
            service: '',
            get isMultiTenant() {
                return reqEntry.multiTenant || false
            },
            vcap: reqEntry.vcap || {},
            get isManagedHana() {
                return this.service == 'managed-hana'
            },
            get isPlainHana() {
                return this.service == 'hana'
            },
            get isHana() {
                return this.isPlainHana || this.isManagedHana
            },
            get isXsuaa() {
                return this.service == 'xsuaa'
            },
        }

        switch (reqEntry.kind) {
            case 'sql':
            case 'hana':
                if (reqEntry.kind === 'sql' && reqEntry.use !== 'hana') {
                    break
                }
                // use different service name to avoid conflicts when switching from single tenant to multitenant
                // otherwise we would enforce that users have to delete the db container first
                if (resource.isMultiTenant) {
                    resource.name += '-mt'
                }
                resource.service = resource.isMultiTenant ? 'managed-hana' : 'hana'
                resource.vcap.plan = 'hdi-shared'
                break

            case 'xsuaa':
                if (capDescriptor.isMultiTenant) {
                    resource.name += '-mt'
                }
                resource.service = reqEntry.kind
                resource.vcap.plan = 'application'
                break

            default: {
                if (ProjectReader._getProperty(reqEntry, 'vcap.plan')) {
                    resource.service = reqEntry.kind
                } else if (process.env.DEBUG) {
                    this.logger.log(`Skip resource ${key}`)
                }
            }
        }
        return resource.service ? resource : null
    }

    async _validate(projectDescriptor) {
        const capDescriptor = projectDescriptor.cap
        if (capDescriptor.db.length > 0) {
            if (capDescriptor.isJava) {
                //ensure package.json exists in db module
                await Promise.all(capDescriptor.db.map(async db => {
                    const dbPath = path.join(this.projectPath, db.path, "package.json")
                    if (!await this.fsUtil.pathExists(dbPath)) {
                        this.logger.error(`Missing package.json file in folder ${db.path} - 'cds add hana' will add the configuration for SAP HANA deployment`) //NOSONAR
                    }
                }))
            }
        } else {
            this.logger.warn(`No SAP HANA service binding defined in the requires section of the project's package.json. Database module omitted`) //NOSONAR
        }
    }

    static _slash(filename) {
        return filename ? filename.replace(/\\/g, '/') : filename
    }

    static _getResourceName(key, capDescriptor) {
        let name = key
        // only if not already present
        if (!name.includes(capDescriptor.appName)) {
            name = capDescriptor.appName + '-' + name
        }
        return name
    }

    async _getAppDetails() {
        const details = {
        }
        // 1. use mta data if existing
        // const mtaFile = path.join(this.projectPath, 'mta.yaml')
        // let mta
        // if (await this.fsUtil.pathExists(mtaFile)) {
        //     try {
        //         const yaml = require('@sap/cds-foss')('yaml')
        //         const content = await this.fsUtil.readFile(mtaFile, 'utf-8')
        //         mta = yaml.parse(content)
        //     } catch (e) {
        //         this.logger.error(`Failed to load ${mtaFile} - skip mta data`)
        //         this.logger.error(e)
        //     }
        // }

        // if (mta) {
        //     details.id = mta.ID
        //     details.description = mta.description
        //     details.version = mta.version
        //     if (mta.ID) {
        //         details.name = mta.ID.replace('.', '-')
        //     }
        // }
        // 2. use package.json data if existing
        const packageJsonPath = path.join(this.projectPath, 'package.json')
        if (await this.fsUtil.pathExists(packageJsonPath)) {
            try {
                const packageJson = await this.fsUtil.readJSON(packageJsonPath, 'utf-8')
                if (!details.description && packageJson.description) {
                    details.description = packageJson.description
                }
                if (!details.version && packageJson.version) {
                    details.version = packageJson.version
                }
                if (packageJson.name) {
                    let segments = packageJson.name.trim().split('/')
                    // scope as namespace
                    if (segments[0].startsWith('@')) {
                        segments[0] = segments[0].replace('@', '')
                    }
                    segments = segments.map(segment => segment.startsWith('@') ? encodeURIComponent(segment.replace('@', '')) : encodeURIComponent(segment))
                    if (!details.name) {
                        details.name = segments[segments.length - 1]
                    }
                    if (!details.id) {
                        details.id = segments.join('.')
                    }
                    if (!details.description) {
                        details.description = segments[segments.length - 1]
                    }
                }
            } catch (e) {
                this.logger.error(`Failed to load ${packageJsonPath} - skip application data`)
                this.logger.error(e)
            }
        }
        // 3. use project name and static default values
        const projectName = path.basename(this.projectPath)
        if (!details.name) {
            details.name = projectName
        }
        if (!details.description) {
            details.description = projectName
        }
        if (!details.id) {
            details.id = projectName
        }
        if (!details.version) {
            details.version = '1.0.0'
        }
        return details
    }

    static _getProperty(src, segments) {
        segments = Array.isArray(segments) ? segments : segments.split('.')
        return segments.reduce((p, n) => p && p[n], src)
    }
}
