const path = require('path');

const commandUtil = require('../../util/commandUtil');
const mvnArchetypes = require('../../util/mvnArchetypeUtil');

const TemplateBase = require('../templateBase');

const { PROJECT_TYPE, OPTION_JAVA, KINDS, KIND_SQL } = require('../../constants');


module.exports = class HanaTemplate extends TemplateBase {
    constructor(projectPath, generator) {
        super(projectPath, generator, __dirname);
    }

    async checkEnabled() {
        if (this.options.force) {
            return true;
        }

        const env = await this.getEnv();
        const hdiConfigPath = path.join(this.projectPath, env.folders.db, 'src/.hdiconfig');
        if (await this.fsUtil.pathExists(hdiConfigPath)) {
            const configFilePath = path.join(env.folders.db, 'src/.hdiconfig');
            throw new Error(`Database config file ${configFilePath} already exists. Use --force to overwrite.`);
        }

        return true;
    }

    async run() {
        const env = await this.getEnv();

        await this.templateUtil.copyFiles('common', path.join(this.projectPath, env.folders.db), {
            projectName: this.projectName
        }, this.options.force);

        switch (await this.getProjectType()) {
            case PROJECT_TYPE.nodejs:
                await this._updatePackageJson(path.join(this.projectPath, 'package.json'), 'db');
                break;

            case PROJECT_TYPE.java:
                await this.templateUtil.copyFiles('java', path.join(this.projectPath, env.folders.db), {}, this.options.force);

                await this._updatePomXml();
                break;

            default:
                break;
        }
    }

    async _updatePomXml() {
        // if called during cds init the project generation call to AT will add settings
        if (!this.options.add.has(OPTION_JAVA)) {
            const mvnAddHanaArgs = mvnArchetypes.getAddHanaCmdArgs(this.options);
            await commandUtil.spawnCommand('mvn', mvnAddHanaArgs, {
                cwd: this.projectPath
            },  this.logger);
        }
    }

    async _updatePackageJson(packageJsonPath, modelName) { //NOSONAR
        if (await this.fsUtil.pathExists(packageJsonPath)) {
            let changed;
            const packageJson = await this.fsUtil.readJSON(packageJsonPath);

            if (process.env.DEBUG) {
                this.logger.debug(`_updatePackageJson before: ${JSON.stringify(packageJson, null, 2)}`);
            }

            if (!packageJson.dependencies || (!packageJson.dependencies.hdb && !packageJson.dependencies['@sap/hana-client'])) {
                packageJson.dependencies = packageJson.dependencies || {};
                packageJson.dependencies['@sap/hana-client'] = '^2.4.177';
                changed = true;
            }

            packageJson.cds = packageJson.cds || {};
            packageJson.cds.requires = packageJson.cds.requires || {};
            packageJson.cds.requires[modelName] = packageJson.cds.requires[modelName] || {};

            if (!KINDS.includes(packageJson.cds.requires[modelName].kind)) {
                packageJson.cds.requires[modelName].kind = KIND_SQL;
                changed = true;
            }

            if (changed) {
                await this.fsUtil.writeJSON(packageJsonPath, packageJson);
            }

            if (process.env.DEBUG) {
                this.logger.debug(`_updatePackageJson written: ${JSON.stringify(packageJson, null, 2)}`);
            }
        }
    }
}
